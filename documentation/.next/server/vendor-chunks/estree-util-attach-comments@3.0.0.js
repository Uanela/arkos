"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/estree-util-attach-comments@3.0.0";
exports.ids = ["vendor-chunks/estree-util-attach-comments@3.0.0"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/estree-util-attach-comments@3.0.0/node_modules/estree-util-attach-comments/lib/index.js":
/*!*********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/estree-util-attach-comments@3.0.0/node_modules/estree-util-attach-comments/lib/index.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   attachComments: () => (/* binding */ attachComments)\n/* harmony export */ });\n/**\n * @typedef {import('estree').Comment} Comment\n * @typedef {import('estree').Node} Nodes\n */\n\n/**\n * @typedef Fields\n *   Fields.\n * @property {boolean} leading\n *   Whether it’s leading.\n * @property {boolean} trailing\n *   Whether it’s trailing.\n *\n * @typedef State\n *   Info passed around.\n * @property {Array<Comment>} comments\n *   Comments.\n * @property {number} index\n *   Index of comment.\n */\n\nconst own = {}.hasOwnProperty\n\n/** @type {Array<Comment>} */\nconst emptyComments = []\n\n/**\n * Attach semistandard estree comment nodes to the tree.\n *\n * This mutates the given `tree`.\n * It takes `comments`, walks the tree, and adds comments as close as possible\n * to where they originated.\n *\n * Comment nodes are given two boolean fields: `leading` (`true` for\n * `/* a *\\/ b`) and `trailing` (`true` for `a /* b *\\/`).\n * Both fields are `false` for dangling comments: `[/* a *\\/]`.\n * This is what `recast` uses too, and is somewhat similar to Babel, which is\n * not estree but instead uses `leadingComments`, `trailingComments`, and\n * `innerComments` arrays on nodes.\n *\n * The algorithm checks any node: even recent (or future) proposals or\n * nonstandard syntax such as JSX, because it ducktypes to find nodes instead\n * of having a list of visitor keys.\n *\n * The algorithm supports `loc` fields (line/column), `range` fields (offsets),\n * and direct `start` / `end` fields.\n *\n * @template {Nodes} Tree\n *   Node type.\n * @param {Tree} tree\n *   Tree to attach to.\n * @param {Array<Comment> | null | undefined} [comments]\n *   List of comments (optional).\n * @returns {undefined}\n *   Nothing.\n */\nfunction attachComments(tree, comments) {\n  const list = comments ? [...comments].sort(compare) : emptyComments\n  if (list.length > 0) walk(tree, {comments: list, index: 0})\n}\n\n/**\n * Attach semistandard estree comment nodes to the tree.\n *\n * @param {Nodes} node\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {undefined}\n *   Nothing.\n */\nfunction walk(node, state) {\n  // Done, we can quit.\n  if (state.index === state.comments.length) {\n    return\n  }\n\n  /** @type {Array<Nodes>} */\n  const children = []\n  /** @type {Array<Comment>} */\n  const comments = []\n  /** @type {string} */\n  let key\n\n  // Find all children of `node`\n  for (key in node) {\n    if (own.call(node, key)) {\n      /** @type {Array<Nodes> | Nodes} */\n      // @ts-expect-error: indexable.\n      const value = node[key]\n\n      // Ignore comments.\n      if (value && typeof value === 'object' && key !== 'comments') {\n        if (Array.isArray(value)) {\n          let index = -1\n\n          while (++index < value.length) {\n            if (value[index] && typeof value[index].type === 'string') {\n              children.push(value[index])\n            }\n          }\n        } else if (typeof value.type === 'string') {\n          children.push(value)\n        }\n      }\n    }\n  }\n\n  // Sort the children.\n  children.sort(compare)\n\n  // Initial comments.\n  comments.push(...slice(state, node, false, {leading: true, trailing: false}))\n\n  let index = -1\n\n  while (++index < children.length) {\n    walk(children[index], state)\n  }\n\n  // Dangling or trailing comments.\n  comments.push(\n    ...slice(state, node, true, {\n      leading: false,\n      trailing: children.length > 0\n    })\n  )\n\n  if (comments.length > 0) {\n    // @ts-expect-error, yes, because they’re nonstandard.\n    node.comments = comments\n  }\n}\n\n/**\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Node.\n * @param {boolean} compareEnd\n *   Whether to compare on the end (default is on start).\n * @param {Fields} fields\n *   Fields.\n * @returns {Array<Comment>}\n *   Slice from `state.comments`.\n */\nfunction slice(state, node, compareEnd, fields) {\n  /** @type {Array<Comment>} */\n  const result = []\n\n  while (\n    state.comments[state.index] &&\n    compare(state.comments[state.index], node, compareEnd) < 1\n  ) {\n    result.push(Object.assign({}, state.comments[state.index++], fields))\n  }\n\n  return result\n}\n\n/**\n * Sort two nodes (or comments).\n *\n * @param {Comment | Nodes} left\n *   A node.\n * @param {Comment | Nodes} right\n *   The other node.\n * @param {boolean | undefined} [compareEnd=false]\n *   Compare on `end` of `right`, default is to compare on `start` (default:\n *   `false`).\n * @returns {number}\n *   Sorting.\n */\nfunction compare(left, right, compareEnd) {\n  const field = compareEnd ? 'end' : 'start'\n\n  // Offsets.\n  if (left.range && right.range) {\n    return left.range[0] - right.range[compareEnd ? 1 : 0]\n  }\n\n  // Points.\n  if (left.loc && left.loc.start && right.loc && right.loc[field]) {\n    return (\n      left.loc.start.line - right.loc[field].line ||\n      left.loc.start.column - right.loc[field].column\n    )\n  }\n\n  // Just `start` (and `end`) on nodes.\n  // Default in most parsers.\n  if ('start' in left && field in right) {\n    // @ts-expect-error Added by Acorn\n    return left.start - right[field]\n  }\n\n  return Number.NaN\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2VzdHJlZS11dGlsLWF0dGFjaC1jb21tZW50c0AzLjAuMC9ub2RlX21vZHVsZXMvZXN0cmVlLXV0aWwtYXR0YWNoLWNvbW1lbnRzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QyxhQUFhLHVCQUF1QjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBLGNBQWM7O0FBRWQsV0FBVyxnQkFBZ0I7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQSxtQ0FBbUMseUJBQXlCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGNBQWM7QUFDM0I7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsK0JBQStCOztBQUU3RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy91YW5lbGFfY29tby9Eb2N1bWVudHMvZGV2ZWxvcG1lbnQvbm9kZWpzL2Fya29zL25vZGVfbW9kdWxlcy8ucG5wbS9lc3RyZWUtdXRpbC1hdHRhY2gtY29tbWVudHNAMy4wLjAvbm9kZV9tb2R1bGVzL2VzdHJlZS11dGlsLWF0dGFjaC1jb21tZW50cy9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUnKS5Db21tZW50fSBDb21tZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUnKS5Ob2RlfSBOb2Rlc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYgRmllbGRzXG4gKiAgIEZpZWxkcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbGVhZGluZ1xuICogICBXaGV0aGVyIGl04oCZcyBsZWFkaW5nLlxuICogQHByb3BlcnR5IHtib29sZWFufSB0cmFpbGluZ1xuICogICBXaGV0aGVyIGl04oCZcyB0cmFpbGluZy5cbiAqXG4gKiBAdHlwZWRlZiBTdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcHJvcGVydHkge0FycmF5PENvbW1lbnQ+fSBjb21tZW50c1xuICogICBDb21tZW50cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmRleFxuICogICBJbmRleCBvZiBjb21tZW50LlxuICovXG5cbmNvbnN0IG93biA9IHt9Lmhhc093blByb3BlcnR5XG5cbi8qKiBAdHlwZSB7QXJyYXk8Q29tbWVudD59ICovXG5jb25zdCBlbXB0eUNvbW1lbnRzID0gW11cblxuLyoqXG4gKiBBdHRhY2ggc2VtaXN0YW5kYXJkIGVzdHJlZSBjb21tZW50IG5vZGVzIHRvIHRoZSB0cmVlLlxuICpcbiAqIFRoaXMgbXV0YXRlcyB0aGUgZ2l2ZW4gYHRyZWVgLlxuICogSXQgdGFrZXMgYGNvbW1lbnRzYCwgd2Fsa3MgdGhlIHRyZWUsIGFuZCBhZGRzIGNvbW1lbnRzIGFzIGNsb3NlIGFzIHBvc3NpYmxlXG4gKiB0byB3aGVyZSB0aGV5IG9yaWdpbmF0ZWQuXG4gKlxuICogQ29tbWVudCBub2RlcyBhcmUgZ2l2ZW4gdHdvIGJvb2xlYW4gZmllbGRzOiBgbGVhZGluZ2AgKGB0cnVlYCBmb3JcbiAqIGAvKiBhICpcXC8gYmApIGFuZCBgdHJhaWxpbmdgIChgdHJ1ZWAgZm9yIGBhIC8qIGIgKlxcL2ApLlxuICogQm90aCBmaWVsZHMgYXJlIGBmYWxzZWAgZm9yIGRhbmdsaW5nIGNvbW1lbnRzOiBgWy8qIGEgKlxcL11gLlxuICogVGhpcyBpcyB3aGF0IGByZWNhc3RgIHVzZXMgdG9vLCBhbmQgaXMgc29tZXdoYXQgc2ltaWxhciB0byBCYWJlbCwgd2hpY2ggaXNcbiAqIG5vdCBlc3RyZWUgYnV0IGluc3RlYWQgdXNlcyBgbGVhZGluZ0NvbW1lbnRzYCwgYHRyYWlsaW5nQ29tbWVudHNgLCBhbmRcbiAqIGBpbm5lckNvbW1lbnRzYCBhcnJheXMgb24gbm9kZXMuXG4gKlxuICogVGhlIGFsZ29yaXRobSBjaGVja3MgYW55IG5vZGU6IGV2ZW4gcmVjZW50IChvciBmdXR1cmUpIHByb3Bvc2FscyBvclxuICogbm9uc3RhbmRhcmQgc3ludGF4IHN1Y2ggYXMgSlNYLCBiZWNhdXNlIGl0IGR1Y2t0eXBlcyB0byBmaW5kIG5vZGVzIGluc3RlYWRcbiAqIG9mIGhhdmluZyBhIGxpc3Qgb2YgdmlzaXRvciBrZXlzLlxuICpcbiAqIFRoZSBhbGdvcml0aG0gc3VwcG9ydHMgYGxvY2AgZmllbGRzIChsaW5lL2NvbHVtbiksIGByYW5nZWAgZmllbGRzIChvZmZzZXRzKSxcbiAqIGFuZCBkaXJlY3QgYHN0YXJ0YCAvIGBlbmRgIGZpZWxkcy5cbiAqXG4gKiBAdGVtcGxhdGUge05vZGVzfSBUcmVlXG4gKiAgIE5vZGUgdHlwZS5cbiAqIEBwYXJhbSB7VHJlZX0gdHJlZVxuICogICBUcmVlIHRvIGF0dGFjaCB0by5cbiAqIEBwYXJhbSB7QXJyYXk8Q29tbWVudD4gfCBudWxsIHwgdW5kZWZpbmVkfSBbY29tbWVudHNdXG4gKiAgIExpc3Qgb2YgY29tbWVudHMgKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRhY2hDb21tZW50cyh0cmVlLCBjb21tZW50cykge1xuICBjb25zdCBsaXN0ID0gY29tbWVudHMgPyBbLi4uY29tbWVudHNdLnNvcnQoY29tcGFyZSkgOiBlbXB0eUNvbW1lbnRzXG4gIGlmIChsaXN0Lmxlbmd0aCA+IDApIHdhbGsodHJlZSwge2NvbW1lbnRzOiBsaXN0LCBpbmRleDogMH0pXG59XG5cbi8qKlxuICogQXR0YWNoIHNlbWlzdGFuZGFyZCBlc3RyZWUgY29tbWVudCBub2RlcyB0byB0aGUgdHJlZS5cbiAqXG4gKiBAcGFyYW0ge05vZGVzfSBub2RlXG4gKiAgIE5vZGUuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiB3YWxrKG5vZGUsIHN0YXRlKSB7XG4gIC8vIERvbmUsIHdlIGNhbiBxdWl0LlxuICBpZiAoc3RhdGUuaW5kZXggPT09IHN0YXRlLmNvbW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyoqIEB0eXBlIHtBcnJheTxOb2Rlcz59ICovXG4gIGNvbnN0IGNoaWxkcmVuID0gW11cbiAgLyoqIEB0eXBlIHtBcnJheTxDb21tZW50Pn0gKi9cbiAgY29uc3QgY29tbWVudHMgPSBbXVxuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgbGV0IGtleVxuXG4gIC8vIEZpbmQgYWxsIGNoaWxkcmVuIG9mIGBub2RlYFxuICBmb3IgKGtleSBpbiBub2RlKSB7XG4gICAgaWYgKG93bi5jYWxsKG5vZGUsIGtleSkpIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8Tm9kZXM+IHwgTm9kZXN9ICovXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbmRleGFibGUuXG4gICAgICBjb25zdCB2YWx1ZSA9IG5vZGVba2V5XVxuXG4gICAgICAvLyBJZ25vcmUgY29tbWVudHMuXG4gICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBrZXkgIT09ICdjb21tZW50cycpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgbGV0IGluZGV4ID0gLTFcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVbaW5kZXhdICYmIHR5cGVvZiB2YWx1ZVtpbmRleF0udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh2YWx1ZVtpbmRleF0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2godmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTb3J0IHRoZSBjaGlsZHJlbi5cbiAgY2hpbGRyZW4uc29ydChjb21wYXJlKVxuXG4gIC8vIEluaXRpYWwgY29tbWVudHMuXG4gIGNvbW1lbnRzLnB1c2goLi4uc2xpY2Uoc3RhdGUsIG5vZGUsIGZhbHNlLCB7bGVhZGluZzogdHJ1ZSwgdHJhaWxpbmc6IGZhbHNlfSkpXG5cbiAgbGV0IGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHdhbGsoY2hpbGRyZW5baW5kZXhdLCBzdGF0ZSlcbiAgfVxuXG4gIC8vIERhbmdsaW5nIG9yIHRyYWlsaW5nIGNvbW1lbnRzLlxuICBjb21tZW50cy5wdXNoKFxuICAgIC4uLnNsaWNlKHN0YXRlLCBub2RlLCB0cnVlLCB7XG4gICAgICBsZWFkaW5nOiBmYWxzZSxcbiAgICAgIHRyYWlsaW5nOiBjaGlsZHJlbi5sZW5ndGggPiAwXG4gICAgfSlcbiAgKVxuXG4gIGlmIChjb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciwgeWVzLCBiZWNhdXNlIHRoZXnigJlyZSBub25zdGFuZGFyZC5cbiAgICBub2RlLmNvbW1lbnRzID0gY29tbWVudHNcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7Tm9kZXN9IG5vZGVcbiAqICAgTm9kZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcGFyZUVuZFxuICogICBXaGV0aGVyIHRvIGNvbXBhcmUgb24gdGhlIGVuZCAoZGVmYXVsdCBpcyBvbiBzdGFydCkuXG4gKiBAcGFyYW0ge0ZpZWxkc30gZmllbGRzXG4gKiAgIEZpZWxkcy5cbiAqIEByZXR1cm5zIHtBcnJheTxDb21tZW50Pn1cbiAqICAgU2xpY2UgZnJvbSBgc3RhdGUuY29tbWVudHNgLlxuICovXG5mdW5jdGlvbiBzbGljZShzdGF0ZSwgbm9kZSwgY29tcGFyZUVuZCwgZmllbGRzKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXk8Q29tbWVudD59ICovXG4gIGNvbnN0IHJlc3VsdCA9IFtdXG5cbiAgd2hpbGUgKFxuICAgIHN0YXRlLmNvbW1lbnRzW3N0YXRlLmluZGV4XSAmJlxuICAgIGNvbXBhcmUoc3RhdGUuY29tbWVudHNbc3RhdGUuaW5kZXhdLCBub2RlLCBjb21wYXJlRW5kKSA8IDFcbiAgKSB7XG4gICAgcmVzdWx0LnB1c2goT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuY29tbWVudHNbc3RhdGUuaW5kZXgrK10sIGZpZWxkcykpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogU29ydCB0d28gbm9kZXMgKG9yIGNvbW1lbnRzKS5cbiAqXG4gKiBAcGFyYW0ge0NvbW1lbnQgfCBOb2Rlc30gbGVmdFxuICogICBBIG5vZGUuXG4gKiBAcGFyYW0ge0NvbW1lbnQgfCBOb2Rlc30gcmlnaHRcbiAqICAgVGhlIG90aGVyIG5vZGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCB1bmRlZmluZWR9IFtjb21wYXJlRW5kPWZhbHNlXVxuICogICBDb21wYXJlIG9uIGBlbmRgIG9mIGByaWdodGAsIGRlZmF1bHQgaXMgdG8gY29tcGFyZSBvbiBgc3RhcnRgIChkZWZhdWx0OlxuICogICBgZmFsc2VgKS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKiAgIFNvcnRpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUobGVmdCwgcmlnaHQsIGNvbXBhcmVFbmQpIHtcbiAgY29uc3QgZmllbGQgPSBjb21wYXJlRW5kID8gJ2VuZCcgOiAnc3RhcnQnXG5cbiAgLy8gT2Zmc2V0cy5cbiAgaWYgKGxlZnQucmFuZ2UgJiYgcmlnaHQucmFuZ2UpIHtcbiAgICByZXR1cm4gbGVmdC5yYW5nZVswXSAtIHJpZ2h0LnJhbmdlW2NvbXBhcmVFbmQgPyAxIDogMF1cbiAgfVxuXG4gIC8vIFBvaW50cy5cbiAgaWYgKGxlZnQubG9jICYmIGxlZnQubG9jLnN0YXJ0ICYmIHJpZ2h0LmxvYyAmJiByaWdodC5sb2NbZmllbGRdKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGxlZnQubG9jLnN0YXJ0LmxpbmUgLSByaWdodC5sb2NbZmllbGRdLmxpbmUgfHxcbiAgICAgIGxlZnQubG9jLnN0YXJ0LmNvbHVtbiAtIHJpZ2h0LmxvY1tmaWVsZF0uY29sdW1uXG4gICAgKVxuICB9XG5cbiAgLy8gSnVzdCBgc3RhcnRgIChhbmQgYGVuZGApIG9uIG5vZGVzLlxuICAvLyBEZWZhdWx0IGluIG1vc3QgcGFyc2Vycy5cbiAgaWYgKCdzdGFydCcgaW4gbGVmdCAmJiBmaWVsZCBpbiByaWdodCkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQWRkZWQgYnkgQWNvcm5cbiAgICByZXR1cm4gbGVmdC5zdGFydCAtIHJpZ2h0W2ZpZWxkXVxuICB9XG5cbiAgcmV0dXJuIE51bWJlci5OYU5cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/estree-util-attach-comments@3.0.0/node_modules/estree-util-attach-comments/lib/index.js\n");

/***/ })

};
;