"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/retext-smartypants@6.2.0";
exports.ids = ["vendor-chunks/retext-smartypants@6.2.0"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/retext-smartypants@6.2.0/node_modules/retext-smartypants/lib/index.js":
/*!***************************************************************************************************!*\
  !*** ../node_modules/.pnpm/retext-smartypants@6.2.0/node_modules/retext-smartypants/lib/index.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ retextSmartypants)\n/* harmony export */ });\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-visit */ \"(rsc)/../node_modules/.pnpm/unist-util-visit@5.0.0/node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var nlcst_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! nlcst-to-string */ \"(rsc)/../node_modules/.pnpm/nlcst-to-string@4.0.0/node_modules/nlcst-to-string/lib/index.js\");\n/**\n * @import {Parents, Punctuation, Root, SentenceContent, Symbol} from 'nlcst'\n */\n\n/**\n * @callback Method\n *   Transform.\n * @param {State} state\n *   Info passed around.\n * @param {Punctuation | Symbol} node\n *   Node.\n * @param {number} index\n *   Position of `node` in `parent`.\n * @param {Parents} parent\n *   Parent of `node`.\n * @returns {boolean | undefined | void}\n *   Whether to remove the node (`true`); or not (otherwise).\n *\n * @typedef Options\n *   Configuration.\n * @property {'all' | boolean | null | undefined} [backticks=true]\n *   Transform backticks (default: `true`); when `true`, turns double\n *   backticks into an opening double quote and double straight single quotes\n *   into a closing double quote; when `'all'`, does that and turns single\n *   backticks into an opening single quote and a straight single quotes into\n *   a closing single smart quote; `quotes: false` must be used with\n *   `backticks: 'all'`.\n * @property {QuoteCharacterMap | null | undefined} [closingQuotes]\n *   Closing quotes to use (default: `{double: '”', single: '’'}`).\n * @property {'inverted' | 'oldschool' | boolean | null | undefined} [dashes=true]\n *   Transform dashes (default: `true`);\n *   when `true`, turns two dashes into an em dash character;\n *   when `'oldschool'`, turns three dashes into an em dash and two into an en\n *   dash;\n *   when `'inverted'`, turns three dashes into an en dash and two into an em\n *   dash.\n * @property {'spaced' | 'unspaced' | boolean | null | undefined} [ellipses=true]\n *   Transform triple dots (default: `true`).\n *   when `'spaced'`, turns triple dots with spaces into ellipses;\n *   when `'unspaced'`, turns triple dots without spaces into ellipses;\n *   when `true`, turns triple dots with or without spaces into ellipses.\n * @property {QuoteCharacterMap | null | undefined} [openingQuotes]\n *   Opening quotes to use (default: `{double: '“', single: '‘'}`).\n * @property {boolean | null | undefined} [quotes=true]\n *   Transform straight quotes into smart quotes (default: `true`).\n *\n * @typedef State\n *   Info passed around.\n * @property {Quotes} close\n *   Closing quotes.\n * @property {Quotes} open\n *   Opening quotes.\n *\n * @typedef QuoteCharacterMap\n *   Quote characters.\n * @property {string} double\n *   Character to use for double quotes.\n * @property {string} single\n *   Character to use for single quotes.\n *\n * @typedef {[string, string]} Quotes\n *   Quotes.\n */\n\n\n\n\n/** @type {Quotes} */\nconst defaultClosingQuotes = ['”', '’']\n/** @type {Quotes} */\nconst defaultOpeningQuotes = ['“', '‘']\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n\n/**\n * Replace straight punctuation marks with curly ones.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nfunction retextSmartypants(options) {\n  const settings = options || emptyOptions\n  /** @type {Array<Method>} */\n  const methods = []\n\n  if (settings.quotes !== false) {\n    methods.push(quotesDefault)\n  }\n\n  if (settings.ellipses === 'spaced') {\n    methods.push(ellipsesSpaced)\n  } else if (settings.ellipses === 'unspaced') {\n    methods.push(ellipsesUnspaced)\n  } else if (settings.ellipses !== false) {\n    methods.push(ellipsesDefault)\n  }\n\n  if (settings.backticks === 'all') {\n    if (settings.quotes !== false) {\n      throw new Error(\"Cannot accept `backticks: 'all'` with `quotes: true`\")\n    }\n\n    methods.push(backticksAll)\n  } else if (settings.backticks !== false) {\n    methods.push(backticksDefault)\n  }\n\n  if (settings.dashes === 'inverted') {\n    methods.push(dashesInverted)\n  } else if (settings.dashes === 'oldschool') {\n    methods.push(dashesOldschool)\n  } else if (settings.dashes !== false) {\n    methods.push(dashesDefault)\n  }\n\n  /** @type {State} */\n  const state = {\n    close: settings.closingQuotes\n      ? [settings.closingQuotes.double, settings.closingQuotes.single]\n      : defaultClosingQuotes,\n    open: settings.openingQuotes\n      ? [settings.openingQuotes.double, settings.openingQuotes.single]\n      : defaultOpeningQuotes\n  }\n\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    ;(0,unist_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(tree, function (node, position, parent) {\n      let index = -1\n\n      if (\n        parent &&\n        position !== undefined &&\n        (node.type === 'PunctuationNode' || node.type === 'SymbolNode')\n      ) {\n        while (++index < methods.length) {\n          const result = methods[index](state, node, position, parent)\n          if (result === true) {\n            console.log('drop', node)\n            parent.children.splice(position, 1)\n            return position\n          }\n        }\n      }\n    })\n  }\n}\n\n/**\n * Transform single and double backticks and single quotes into smart quotes.\n *\n * @type {Method}\n */\nfunction backticksAll(state, node, index, parent) {\n  backticksDefault(state, node, index, parent)\n\n  if (node.value === '`') {\n    node.value = '‘'\n  } else if (node.value === \"'\") {\n    node.value = '’'\n  }\n}\n\n/**\n * Transform double backticks and single quotes into smart quotes.\n *\n * @type {Method}\n */\nfunction backticksDefault(_, node) {\n  if (node.value === '``') {\n    node.value = '“'\n  } else if (node.value === \"''\") {\n    node.value = '”'\n  }\n}\n\n/**\n * Transform two dashes into an em dash.\n *\n * @type {Method}\n */\nfunction dashesDefault(_, node) {\n  if (node.value === '--') {\n    node.value = '—'\n  }\n}\n\n/**\n * Transform three dashes into an en dash, and two into an em dash.\n *\n * @type {Method}\n */\nfunction dashesInverted(_, node, index, parent) {\n  const next = parent.children[index + 1]\n\n  if (\n    node.value === '—' &&\n    next &&\n    next.type === 'PunctuationNode' &&\n    next.value === '-'\n  ) {\n    next.value = '–'\n    return true\n  }\n\n  if (node.value === '---') {\n    node.value = '–'\n  } else if (node.value === '--') {\n    node.value = '—'\n  }\n}\n\n/**\n * Transform three dashes into an em dash, and two into an en dash.\n *\n * @type {Method}\n */\nfunction dashesOldschool(_, node, index, parent) {\n  const next = parent.children[index + 1]\n\n  if (\n    node.value === '–' &&\n    next &&\n    next.type === 'PunctuationNode' &&\n    next.value === '-'\n  ) {\n    next.value = '—'\n    return true\n  }\n\n  if (node.value === '---') {\n    node.value = '—'\n  } else if (node.value === '--') {\n    node.value = '–'\n  }\n}\n\n/**\n * Transform multiple dots into unicode ellipses.\n *\n * @type {Method}\n */\nfunction ellipsesDefault(_, node, index, parent) {\n  ellipsesSpaced(_, node, index, parent)\n  ellipsesUnspaced(_, node, index, parent)\n}\n\n/**\n * Transform multiple dots with spaces into unicode ellipses.\n *\n * @type {Method}\n */\nfunction ellipsesSpaced(_, node, index, parent) {\n  const value = node.value\n  const siblings = parent.children\n\n  if (!/^\\.+$/.test(value)) {\n    return\n  }\n\n  // Search for dot-nodes with whitespace between.\n  /** @type {Array<SentenceContent>} */\n  const nodes = []\n  let position = index\n  let count = 1\n\n  // It’s possible that the node is merged with an adjacent word-node.  In that\n  // code, we cannot transform it because there’s no reference to the\n  // grandparent.\n  while (--position > 0) {\n    let sibling = siblings[position]\n\n    if (sibling.type !== 'WhiteSpaceNode') {\n      break\n    }\n\n    const queue = sibling\n    sibling = siblings[--position]\n\n    if (\n      sibling &&\n      (sibling.type === 'PunctuationNode' || sibling.type === 'SymbolNode') &&\n      /^\\.+$/.test(sibling.value)\n    ) {\n      nodes.push(queue, sibling)\n\n      count++\n\n      continue\n    }\n\n    break\n  }\n\n  if (count < 3) {\n    return\n  }\n\n  siblings.splice(index - nodes.length, nodes.length)\n\n  node.value = '…'\n}\n\n/**\n * Transform multiple dots without spaces into unicode ellipses.\n *\n * @type {Method}\n */\nfunction ellipsesUnspaced(_, node) {\n  // Simple node with three dots and without whitespace.\n  if (/^\\.{3,}$/.test(node.value)) {\n    node.value = '…'\n  }\n}\n\n/**\n * Transform straight single- and double quotes into smart quotes.\n *\n * @type {Method}\n */\n// eslint-disable-next-line complexity\nfunction quotesDefault(state, node, index, parent) {\n  const siblings = parent.children\n  const value = node.value\n\n  if (value !== '\"' && value !== \"'\") {\n    return\n  }\n\n  const quoteIndex = value === '\"' ? 0 : 1\n  const previous = siblings[index - 1]\n  const next = siblings[index + 1]\n  const nextNext = siblings[index + 2]\n  const nextValue = next ? (0,nlcst_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(next) : ''\n\n  if (\n    next &&\n    (next.type === 'PunctuationNode' || next.type === 'SymbolNode') &&\n    (!nextNext || nextNext.type !== 'WordNode')\n  ) {\n    // Special case if the very first character is a quote followed by\n    // punctuation at a non-word-break. Close the quotes by brute force.\n    node.value = state.close[quoteIndex]\n  } else if (\n    next &&\n    (next.type === 'PunctuationNode' || next.type === 'SymbolNode') &&\n    (nextValue === '\"' || nextValue === \"'\") &&\n    nextNext &&\n    nextNext.type === 'WordNode'\n  ) {\n    // Special case for double sets of quotes:\n    // `He said, \"'Quoted' words in a larger quote.\"`\n    node.value = state.open[quoteIndex]\n    next.value = state.open[nextValue === '\"' ? 0 : 1]\n  } else if (next && /^\\d\\ds$/.test(nextValue)) {\n    // Special case for decade abbreviations: `the '80s`\n    node.value = state.close[quoteIndex]\n  } else if (\n    previous &&\n    (previous.type === 'WhiteSpaceNode' ||\n      previous.type === 'PunctuationNode' ||\n      previous.type === 'SymbolNode') &&\n    next &&\n    next.type === 'WordNode'\n  ) {\n    // Get most opening single quotes.\n    node.value = state.open[quoteIndex]\n  } else if (\n    previous &&\n    previous.type !== 'WhiteSpaceNode' &&\n    previous.type !== 'SymbolNode' &&\n    previous.type !== 'PunctuationNode'\n  ) {\n    // Closing quotes.\n    node.value = state.close[quoteIndex]\n  } else if (\n    !next ||\n    next.type === 'WhiteSpaceNode' ||\n    (value === \"'\" && nextValue === 's')\n  ) {\n    node.value = state.close[quoteIndex]\n  } else {\n    node.value = state.open[quoteIndex]\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JldGV4dC1zbWFydHlwYW50c0A2LjIuMC9ub2RlX21vZHVsZXMvcmV0ZXh0LXNtYXJ0eXBhbnRzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBLFlBQVkscURBQXFEO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLG9DQUFvQztBQUNsRCw0Q0FBNEM7QUFDNUM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxjQUFjLHNDQUFzQztBQUNwRCx1Q0FBdUMseUJBQXlCO0FBQ2hFLGNBQWMsdURBQXVEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0RBQW9EO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQ0FBc0M7QUFDcEQsdUNBQXVDLHlCQUF5QjtBQUNoRSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTs7QUFFc0M7QUFDRTs7QUFFeEMsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25COztBQUVBLFdBQVcsbUJBQW1CO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0NBQXNDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBLGFBQWEsZUFBZTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdEQUFLO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlEQUFROztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdWFuZWxhX2NvbW8vRG9jdW1lbnRzL2RldmVsb3BtZW50L25vZGVqcy9hcmtvcy9ub2RlX21vZHVsZXMvLnBucG0vcmV0ZXh0LXNtYXJ0eXBhbnRzQDYuMi4wL25vZGVfbW9kdWxlcy9yZXRleHQtc21hcnR5cGFudHMvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7UGFyZW50cywgUHVuY3R1YXRpb24sIFJvb3QsIFNlbnRlbmNlQ29udGVudCwgU3ltYm9sfSBmcm9tICdubGNzdCdcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBNZXRob2RcbiAqICAgVHJhbnNmb3JtLlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHBhcmFtIHtQdW5jdHVhdGlvbiB8IFN5bWJvbH0gbm9kZVxuICogICBOb2RlLlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiAgIFBvc2l0aW9uIG9mIGBub2RlYCBpbiBgcGFyZW50YC5cbiAqIEBwYXJhbSB7UGFyZW50c30gcGFyZW50XG4gKiAgIFBhcmVudCBvZiBgbm9kZWAuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbiB8IHVuZGVmaW5lZCB8IHZvaWR9XG4gKiAgIFdoZXRoZXIgdG8gcmVtb3ZlIHRoZSBub2RlIChgdHJ1ZWApOyBvciBub3QgKG90aGVyd2lzZSkuXG4gKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uLlxuICogQHByb3BlcnR5IHsnYWxsJyB8IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbYmFja3RpY2tzPXRydWVdXG4gKiAgIFRyYW5zZm9ybSBiYWNrdGlja3MgKGRlZmF1bHQ6IGB0cnVlYCk7IHdoZW4gYHRydWVgLCB0dXJucyBkb3VibGVcbiAqICAgYmFja3RpY2tzIGludG8gYW4gb3BlbmluZyBkb3VibGUgcXVvdGUgYW5kIGRvdWJsZSBzdHJhaWdodCBzaW5nbGUgcXVvdGVzXG4gKiAgIGludG8gYSBjbG9zaW5nIGRvdWJsZSBxdW90ZTsgd2hlbiBgJ2FsbCdgLCBkb2VzIHRoYXQgYW5kIHR1cm5zIHNpbmdsZVxuICogICBiYWNrdGlja3MgaW50byBhbiBvcGVuaW5nIHNpbmdsZSBxdW90ZSBhbmQgYSBzdHJhaWdodCBzaW5nbGUgcXVvdGVzIGludG9cbiAqICAgYSBjbG9zaW5nIHNpbmdsZSBzbWFydCBxdW90ZTsgYHF1b3RlczogZmFsc2VgIG11c3QgYmUgdXNlZCB3aXRoXG4gKiAgIGBiYWNrdGlja3M6ICdhbGwnYC5cbiAqIEBwcm9wZXJ0eSB7UXVvdGVDaGFyYWN0ZXJNYXAgfCBudWxsIHwgdW5kZWZpbmVkfSBbY2xvc2luZ1F1b3Rlc11cbiAqICAgQ2xvc2luZyBxdW90ZXMgdG8gdXNlIChkZWZhdWx0OiBge2RvdWJsZTogJ+KAnScsIHNpbmdsZTogJ+KAmSd9YCkuXG4gKiBAcHJvcGVydHkgeydpbnZlcnRlZCcgfCAnb2xkc2Nob29sJyB8IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbZGFzaGVzPXRydWVdXG4gKiAgIFRyYW5zZm9ybSBkYXNoZXMgKGRlZmF1bHQ6IGB0cnVlYCk7XG4gKiAgIHdoZW4gYHRydWVgLCB0dXJucyB0d28gZGFzaGVzIGludG8gYW4gZW0gZGFzaCBjaGFyYWN0ZXI7XG4gKiAgIHdoZW4gYCdvbGRzY2hvb2wnYCwgdHVybnMgdGhyZWUgZGFzaGVzIGludG8gYW4gZW0gZGFzaCBhbmQgdHdvIGludG8gYW4gZW5cbiAqICAgZGFzaDtcbiAqICAgd2hlbiBgJ2ludmVydGVkJ2AsIHR1cm5zIHRocmVlIGRhc2hlcyBpbnRvIGFuIGVuIGRhc2ggYW5kIHR3byBpbnRvIGFuIGVtXG4gKiAgIGRhc2guXG4gKiBAcHJvcGVydHkgeydzcGFjZWQnIHwgJ3Vuc3BhY2VkJyB8IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbZWxsaXBzZXM9dHJ1ZV1cbiAqICAgVHJhbnNmb3JtIHRyaXBsZSBkb3RzIChkZWZhdWx0OiBgdHJ1ZWApLlxuICogICB3aGVuIGAnc3BhY2VkJ2AsIHR1cm5zIHRyaXBsZSBkb3RzIHdpdGggc3BhY2VzIGludG8gZWxsaXBzZXM7XG4gKiAgIHdoZW4gYCd1bnNwYWNlZCdgLCB0dXJucyB0cmlwbGUgZG90cyB3aXRob3V0IHNwYWNlcyBpbnRvIGVsbGlwc2VzO1xuICogICB3aGVuIGB0cnVlYCwgdHVybnMgdHJpcGxlIGRvdHMgd2l0aCBvciB3aXRob3V0IHNwYWNlcyBpbnRvIGVsbGlwc2VzLlxuICogQHByb3BlcnR5IHtRdW90ZUNoYXJhY3Rlck1hcCB8IG51bGwgfCB1bmRlZmluZWR9IFtvcGVuaW5nUXVvdGVzXVxuICogICBPcGVuaW5nIHF1b3RlcyB0byB1c2UgKGRlZmF1bHQ6IGB7ZG91YmxlOiAn4oCcJywgc2luZ2xlOiAn4oCYJ31gKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtxdW90ZXM9dHJ1ZV1cbiAqICAgVHJhbnNmb3JtIHN0cmFpZ2h0IHF1b3RlcyBpbnRvIHNtYXJ0IHF1b3RlcyAoZGVmYXVsdDogYHRydWVgKS5cbiAqXG4gKiBAdHlwZWRlZiBTdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcHJvcGVydHkge1F1b3Rlc30gY2xvc2VcbiAqICAgQ2xvc2luZyBxdW90ZXMuXG4gKiBAcHJvcGVydHkge1F1b3Rlc30gb3BlblxuICogICBPcGVuaW5nIHF1b3Rlcy5cbiAqXG4gKiBAdHlwZWRlZiBRdW90ZUNoYXJhY3Rlck1hcFxuICogICBRdW90ZSBjaGFyYWN0ZXJzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRvdWJsZVxuICogICBDaGFyYWN0ZXIgdG8gdXNlIGZvciBkb3VibGUgcXVvdGVzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNpbmdsZVxuICogICBDaGFyYWN0ZXIgdG8gdXNlIGZvciBzaW5nbGUgcXVvdGVzLlxuICpcbiAqIEB0eXBlZGVmIHtbc3RyaW5nLCBzdHJpbmddfSBRdW90ZXNcbiAqICAgUXVvdGVzLlxuICovXG5cbmltcG9ydCB7dmlzaXR9IGZyb20gJ3VuaXN0LXV0aWwtdmlzaXQnXG5pbXBvcnQge3RvU3RyaW5nfSBmcm9tICdubGNzdC10by1zdHJpbmcnXG5cbi8qKiBAdHlwZSB7UXVvdGVzfSAqL1xuY29uc3QgZGVmYXVsdENsb3NpbmdRdW90ZXMgPSBbJ+KAnScsICfigJknXVxuLyoqIEB0eXBlIHtRdW90ZXN9ICovXG5jb25zdCBkZWZhdWx0T3BlbmluZ1F1b3RlcyA9IFsn4oCcJywgJ+KAmCddXG5cbi8qKiBAdHlwZSB7UmVhZG9ubHk8T3B0aW9ucz59ICovXG5jb25zdCBlbXB0eU9wdGlvbnMgPSB7fVxuXG4vKipcbiAqIFJlcGxhY2Ugc3RyYWlnaHQgcHVuY3R1YXRpb24gbWFya3Mgd2l0aCBjdXJseSBvbmVzLlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHk8T3B0aW9ucz4gfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAqICAgQ29uZmlndXJhdGlvbiAob3B0aW9uYWwpLlxuICogQHJldHVybnNcbiAqICAgVHJhbnNmb3JtLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXRleHRTbWFydHlwYW50cyhvcHRpb25zKSB7XG4gIGNvbnN0IHNldHRpbmdzID0gb3B0aW9ucyB8fCBlbXB0eU9wdGlvbnNcbiAgLyoqIEB0eXBlIHtBcnJheTxNZXRob2Q+fSAqL1xuICBjb25zdCBtZXRob2RzID0gW11cblxuICBpZiAoc2V0dGluZ3MucXVvdGVzICE9PSBmYWxzZSkge1xuICAgIG1ldGhvZHMucHVzaChxdW90ZXNEZWZhdWx0KVxuICB9XG5cbiAgaWYgKHNldHRpbmdzLmVsbGlwc2VzID09PSAnc3BhY2VkJykge1xuICAgIG1ldGhvZHMucHVzaChlbGxpcHNlc1NwYWNlZClcbiAgfSBlbHNlIGlmIChzZXR0aW5ncy5lbGxpcHNlcyA9PT0gJ3Vuc3BhY2VkJykge1xuICAgIG1ldGhvZHMucHVzaChlbGxpcHNlc1Vuc3BhY2VkKVxuICB9IGVsc2UgaWYgKHNldHRpbmdzLmVsbGlwc2VzICE9PSBmYWxzZSkge1xuICAgIG1ldGhvZHMucHVzaChlbGxpcHNlc0RlZmF1bHQpXG4gIH1cblxuICBpZiAoc2V0dGluZ3MuYmFja3RpY2tzID09PSAnYWxsJykge1xuICAgIGlmIChzZXR0aW5ncy5xdW90ZXMgIT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWNjZXB0IGBiYWNrdGlja3M6ICdhbGwnYCB3aXRoIGBxdW90ZXM6IHRydWVgXCIpXG4gICAgfVxuXG4gICAgbWV0aG9kcy5wdXNoKGJhY2t0aWNrc0FsbClcbiAgfSBlbHNlIGlmIChzZXR0aW5ncy5iYWNrdGlja3MgIT09IGZhbHNlKSB7XG4gICAgbWV0aG9kcy5wdXNoKGJhY2t0aWNrc0RlZmF1bHQpXG4gIH1cblxuICBpZiAoc2V0dGluZ3MuZGFzaGVzID09PSAnaW52ZXJ0ZWQnKSB7XG4gICAgbWV0aG9kcy5wdXNoKGRhc2hlc0ludmVydGVkKVxuICB9IGVsc2UgaWYgKHNldHRpbmdzLmRhc2hlcyA9PT0gJ29sZHNjaG9vbCcpIHtcbiAgICBtZXRob2RzLnB1c2goZGFzaGVzT2xkc2Nob29sKVxuICB9IGVsc2UgaWYgKHNldHRpbmdzLmRhc2hlcyAhPT0gZmFsc2UpIHtcbiAgICBtZXRob2RzLnB1c2goZGFzaGVzRGVmYXVsdClcbiAgfVxuXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIGNsb3NlOiBzZXR0aW5ncy5jbG9zaW5nUXVvdGVzXG4gICAgICA/IFtzZXR0aW5ncy5jbG9zaW5nUXVvdGVzLmRvdWJsZSwgc2V0dGluZ3MuY2xvc2luZ1F1b3Rlcy5zaW5nbGVdXG4gICAgICA6IGRlZmF1bHRDbG9zaW5nUXVvdGVzLFxuICAgIG9wZW46IHNldHRpbmdzLm9wZW5pbmdRdW90ZXNcbiAgICAgID8gW3NldHRpbmdzLm9wZW5pbmdRdW90ZXMuZG91YmxlLCBzZXR0aW5ncy5vcGVuaW5nUXVvdGVzLnNpbmdsZV1cbiAgICAgIDogZGVmYXVsdE9wZW5pbmdRdW90ZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0uXG4gICAqXG4gICAqIEBwYXJhbSB7Um9vdH0gdHJlZVxuICAgKiAgIFRyZWUuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqICAgTm90aGluZy5cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiAodHJlZSkge1xuICAgIHZpc2l0KHRyZWUsIGZ1bmN0aW9uIChub2RlLCBwb3NpdGlvbiwgcGFyZW50KSB7XG4gICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICBpZiAoXG4gICAgICAgIHBhcmVudCAmJlxuICAgICAgICBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIChub2RlLnR5cGUgPT09ICdQdW5jdHVhdGlvbk5vZGUnIHx8IG5vZGUudHlwZSA9PT0gJ1N5bWJvbE5vZGUnKVxuICAgICAgKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbWV0aG9kcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtZXRob2RzW2luZGV4XShzdGF0ZSwgbm9kZSwgcG9zaXRpb24sIHBhcmVudClcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZHJvcCcsIG5vZGUpXG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHBvc2l0aW9uLCAxKVxuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBzaW5nbGUgYW5kIGRvdWJsZSBiYWNrdGlja3MgYW5kIHNpbmdsZSBxdW90ZXMgaW50byBzbWFydCBxdW90ZXMuXG4gKlxuICogQHR5cGUge01ldGhvZH1cbiAqL1xuZnVuY3Rpb24gYmFja3RpY2tzQWxsKHN0YXRlLCBub2RlLCBpbmRleCwgcGFyZW50KSB7XG4gIGJhY2t0aWNrc0RlZmF1bHQoc3RhdGUsIG5vZGUsIGluZGV4LCBwYXJlbnQpXG5cbiAgaWYgKG5vZGUudmFsdWUgPT09ICdgJykge1xuICAgIG5vZGUudmFsdWUgPSAn4oCYJ1xuICB9IGVsc2UgaWYgKG5vZGUudmFsdWUgPT09IFwiJ1wiKSB7XG4gICAgbm9kZS52YWx1ZSA9ICfigJknXG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gZG91YmxlIGJhY2t0aWNrcyBhbmQgc2luZ2xlIHF1b3RlcyBpbnRvIHNtYXJ0IHF1b3Rlcy5cbiAqXG4gKiBAdHlwZSB7TWV0aG9kfVxuICovXG5mdW5jdGlvbiBiYWNrdGlja3NEZWZhdWx0KF8sIG5vZGUpIHtcbiAgaWYgKG5vZGUudmFsdWUgPT09ICdgYCcpIHtcbiAgICBub2RlLnZhbHVlID0gJ+KAnCdcbiAgfSBlbHNlIGlmIChub2RlLnZhbHVlID09PSBcIicnXCIpIHtcbiAgICBub2RlLnZhbHVlID0gJ+KAnSdcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSB0d28gZGFzaGVzIGludG8gYW4gZW0gZGFzaC5cbiAqXG4gKiBAdHlwZSB7TWV0aG9kfVxuICovXG5mdW5jdGlvbiBkYXNoZXNEZWZhdWx0KF8sIG5vZGUpIHtcbiAgaWYgKG5vZGUudmFsdWUgPT09ICctLScpIHtcbiAgICBub2RlLnZhbHVlID0gJ+KAlCdcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSB0aHJlZSBkYXNoZXMgaW50byBhbiBlbiBkYXNoLCBhbmQgdHdvIGludG8gYW4gZW0gZGFzaC5cbiAqXG4gKiBAdHlwZSB7TWV0aG9kfVxuICovXG5mdW5jdGlvbiBkYXNoZXNJbnZlcnRlZChfLCBub2RlLCBpbmRleCwgcGFyZW50KSB7XG4gIGNvbnN0IG5leHQgPSBwYXJlbnQuY2hpbGRyZW5baW5kZXggKyAxXVxuXG4gIGlmIChcbiAgICBub2RlLnZhbHVlID09PSAn4oCUJyAmJlxuICAgIG5leHQgJiZcbiAgICBuZXh0LnR5cGUgPT09ICdQdW5jdHVhdGlvbk5vZGUnICYmXG4gICAgbmV4dC52YWx1ZSA9PT0gJy0nXG4gICkge1xuICAgIG5leHQudmFsdWUgPSAn4oCTJ1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAobm9kZS52YWx1ZSA9PT0gJy0tLScpIHtcbiAgICBub2RlLnZhbHVlID0gJ+KAkydcbiAgfSBlbHNlIGlmIChub2RlLnZhbHVlID09PSAnLS0nKSB7XG4gICAgbm9kZS52YWx1ZSA9ICfigJQnXG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhyZWUgZGFzaGVzIGludG8gYW4gZW0gZGFzaCwgYW5kIHR3byBpbnRvIGFuIGVuIGRhc2guXG4gKlxuICogQHR5cGUge01ldGhvZH1cbiAqL1xuZnVuY3Rpb24gZGFzaGVzT2xkc2Nob29sKF8sIG5vZGUsIGluZGV4LCBwYXJlbnQpIHtcbiAgY29uc3QgbmV4dCA9IHBhcmVudC5jaGlsZHJlbltpbmRleCArIDFdXG5cbiAgaWYgKFxuICAgIG5vZGUudmFsdWUgPT09ICfigJMnICYmXG4gICAgbmV4dCAmJlxuICAgIG5leHQudHlwZSA9PT0gJ1B1bmN0dWF0aW9uTm9kZScgJiZcbiAgICBuZXh0LnZhbHVlID09PSAnLSdcbiAgKSB7XG4gICAgbmV4dC52YWx1ZSA9ICfigJQnXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChub2RlLnZhbHVlID09PSAnLS0tJykge1xuICAgIG5vZGUudmFsdWUgPSAn4oCUJ1xuICB9IGVsc2UgaWYgKG5vZGUudmFsdWUgPT09ICctLScpIHtcbiAgICBub2RlLnZhbHVlID0gJ+KAkydcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBtdWx0aXBsZSBkb3RzIGludG8gdW5pY29kZSBlbGxpcHNlcy5cbiAqXG4gKiBAdHlwZSB7TWV0aG9kfVxuICovXG5mdW5jdGlvbiBlbGxpcHNlc0RlZmF1bHQoXywgbm9kZSwgaW5kZXgsIHBhcmVudCkge1xuICBlbGxpcHNlc1NwYWNlZChfLCBub2RlLCBpbmRleCwgcGFyZW50KVxuICBlbGxpcHNlc1Vuc3BhY2VkKF8sIG5vZGUsIGluZGV4LCBwYXJlbnQpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIG11bHRpcGxlIGRvdHMgd2l0aCBzcGFjZXMgaW50byB1bmljb2RlIGVsbGlwc2VzLlxuICpcbiAqIEB0eXBlIHtNZXRob2R9XG4gKi9cbmZ1bmN0aW9uIGVsbGlwc2VzU3BhY2VkKF8sIG5vZGUsIGluZGV4LCBwYXJlbnQpIHtcbiAgY29uc3QgdmFsdWUgPSBub2RlLnZhbHVlXG4gIGNvbnN0IHNpYmxpbmdzID0gcGFyZW50LmNoaWxkcmVuXG5cbiAgaWYgKCEvXlxcLiskLy50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gU2VhcmNoIGZvciBkb3Qtbm9kZXMgd2l0aCB3aGl0ZXNwYWNlIGJldHdlZW4uXG4gIC8qKiBAdHlwZSB7QXJyYXk8U2VudGVuY2VDb250ZW50Pn0gKi9cbiAgY29uc3Qgbm9kZXMgPSBbXVxuICBsZXQgcG9zaXRpb24gPSBpbmRleFxuICBsZXQgY291bnQgPSAxXG5cbiAgLy8gSXTigJlzIHBvc3NpYmxlIHRoYXQgdGhlIG5vZGUgaXMgbWVyZ2VkIHdpdGggYW4gYWRqYWNlbnQgd29yZC1ub2RlLiAgSW4gdGhhdFxuICAvLyBjb2RlLCB3ZSBjYW5ub3QgdHJhbnNmb3JtIGl0IGJlY2F1c2UgdGhlcmXigJlzIG5vIHJlZmVyZW5jZSB0byB0aGVcbiAgLy8gZ3JhbmRwYXJlbnQuXG4gIHdoaWxlICgtLXBvc2l0aW9uID4gMCkge1xuICAgIGxldCBzaWJsaW5nID0gc2libGluZ3NbcG9zaXRpb25dXG5cbiAgICBpZiAoc2libGluZy50eXBlICE9PSAnV2hpdGVTcGFjZU5vZGUnKSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGNvbnN0IHF1ZXVlID0gc2libGluZ1xuICAgIHNpYmxpbmcgPSBzaWJsaW5nc1stLXBvc2l0aW9uXVxuXG4gICAgaWYgKFxuICAgICAgc2libGluZyAmJlxuICAgICAgKHNpYmxpbmcudHlwZSA9PT0gJ1B1bmN0dWF0aW9uTm9kZScgfHwgc2libGluZy50eXBlID09PSAnU3ltYm9sTm9kZScpICYmXG4gICAgICAvXlxcLiskLy50ZXN0KHNpYmxpbmcudmFsdWUpXG4gICAgKSB7XG4gICAgICBub2Rlcy5wdXNoKHF1ZXVlLCBzaWJsaW5nKVxuXG4gICAgICBjb3VudCsrXG5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgYnJlYWtcbiAgfVxuXG4gIGlmIChjb3VudCA8IDMpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHNpYmxpbmdzLnNwbGljZShpbmRleCAtIG5vZGVzLmxlbmd0aCwgbm9kZXMubGVuZ3RoKVxuXG4gIG5vZGUudmFsdWUgPSAn4oCmJ1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBtdWx0aXBsZSBkb3RzIHdpdGhvdXQgc3BhY2VzIGludG8gdW5pY29kZSBlbGxpcHNlcy5cbiAqXG4gKiBAdHlwZSB7TWV0aG9kfVxuICovXG5mdW5jdGlvbiBlbGxpcHNlc1Vuc3BhY2VkKF8sIG5vZGUpIHtcbiAgLy8gU2ltcGxlIG5vZGUgd2l0aCB0aHJlZSBkb3RzIGFuZCB3aXRob3V0IHdoaXRlc3BhY2UuXG4gIGlmICgvXlxcLnszLH0kLy50ZXN0KG5vZGUudmFsdWUpKSB7XG4gICAgbm9kZS52YWx1ZSA9ICfigKYnXG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gc3RyYWlnaHQgc2luZ2xlLSBhbmQgZG91YmxlIHF1b3RlcyBpbnRvIHNtYXJ0IHF1b3Rlcy5cbiAqXG4gKiBAdHlwZSB7TWV0aG9kfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gcXVvdGVzRGVmYXVsdChzdGF0ZSwgbm9kZSwgaW5kZXgsIHBhcmVudCkge1xuICBjb25zdCBzaWJsaW5ncyA9IHBhcmVudC5jaGlsZHJlblxuICBjb25zdCB2YWx1ZSA9IG5vZGUudmFsdWVcblxuICBpZiAodmFsdWUgIT09ICdcIicgJiYgdmFsdWUgIT09IFwiJ1wiKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBxdW90ZUluZGV4ID0gdmFsdWUgPT09ICdcIicgPyAwIDogMVxuICBjb25zdCBwcmV2aW91cyA9IHNpYmxpbmdzW2luZGV4IC0gMV1cbiAgY29uc3QgbmV4dCA9IHNpYmxpbmdzW2luZGV4ICsgMV1cbiAgY29uc3QgbmV4dE5leHQgPSBzaWJsaW5nc1tpbmRleCArIDJdXG4gIGNvbnN0IG5leHRWYWx1ZSA9IG5leHQgPyB0b1N0cmluZyhuZXh0KSA6ICcnXG5cbiAgaWYgKFxuICAgIG5leHQgJiZcbiAgICAobmV4dC50eXBlID09PSAnUHVuY3R1YXRpb25Ob2RlJyB8fCBuZXh0LnR5cGUgPT09ICdTeW1ib2xOb2RlJykgJiZcbiAgICAoIW5leHROZXh0IHx8IG5leHROZXh0LnR5cGUgIT09ICdXb3JkTm9kZScpXG4gICkge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBpZiB0aGUgdmVyeSBmaXJzdCBjaGFyYWN0ZXIgaXMgYSBxdW90ZSBmb2xsb3dlZCBieVxuICAgIC8vIHB1bmN0dWF0aW9uIGF0IGEgbm9uLXdvcmQtYnJlYWsuIENsb3NlIHRoZSBxdW90ZXMgYnkgYnJ1dGUgZm9yY2UuXG4gICAgbm9kZS52YWx1ZSA9IHN0YXRlLmNsb3NlW3F1b3RlSW5kZXhdXG4gIH0gZWxzZSBpZiAoXG4gICAgbmV4dCAmJlxuICAgIChuZXh0LnR5cGUgPT09ICdQdW5jdHVhdGlvbk5vZGUnIHx8IG5leHQudHlwZSA9PT0gJ1N5bWJvbE5vZGUnKSAmJlxuICAgIChuZXh0VmFsdWUgPT09ICdcIicgfHwgbmV4dFZhbHVlID09PSBcIidcIikgJiZcbiAgICBuZXh0TmV4dCAmJlxuICAgIG5leHROZXh0LnR5cGUgPT09ICdXb3JkTm9kZSdcbiAgKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBkb3VibGUgc2V0cyBvZiBxdW90ZXM6XG4gICAgLy8gYEhlIHNhaWQsIFwiJ1F1b3RlZCcgd29yZHMgaW4gYSBsYXJnZXIgcXVvdGUuXCJgXG4gICAgbm9kZS52YWx1ZSA9IHN0YXRlLm9wZW5bcXVvdGVJbmRleF1cbiAgICBuZXh0LnZhbHVlID0gc3RhdGUub3BlbltuZXh0VmFsdWUgPT09ICdcIicgPyAwIDogMV1cbiAgfSBlbHNlIGlmIChuZXh0ICYmIC9eXFxkXFxkcyQvLnRlc3QobmV4dFZhbHVlKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgZGVjYWRlIGFiYnJldmlhdGlvbnM6IGB0aGUgJzgwc2BcbiAgICBub2RlLnZhbHVlID0gc3RhdGUuY2xvc2VbcXVvdGVJbmRleF1cbiAgfSBlbHNlIGlmIChcbiAgICBwcmV2aW91cyAmJlxuICAgIChwcmV2aW91cy50eXBlID09PSAnV2hpdGVTcGFjZU5vZGUnIHx8XG4gICAgICBwcmV2aW91cy50eXBlID09PSAnUHVuY3R1YXRpb25Ob2RlJyB8fFxuICAgICAgcHJldmlvdXMudHlwZSA9PT0gJ1N5bWJvbE5vZGUnKSAmJlxuICAgIG5leHQgJiZcbiAgICBuZXh0LnR5cGUgPT09ICdXb3JkTm9kZSdcbiAgKSB7XG4gICAgLy8gR2V0IG1vc3Qgb3BlbmluZyBzaW5nbGUgcXVvdGVzLlxuICAgIG5vZGUudmFsdWUgPSBzdGF0ZS5vcGVuW3F1b3RlSW5kZXhdXG4gIH0gZWxzZSBpZiAoXG4gICAgcHJldmlvdXMgJiZcbiAgICBwcmV2aW91cy50eXBlICE9PSAnV2hpdGVTcGFjZU5vZGUnICYmXG4gICAgcHJldmlvdXMudHlwZSAhPT0gJ1N5bWJvbE5vZGUnICYmXG4gICAgcHJldmlvdXMudHlwZSAhPT0gJ1B1bmN0dWF0aW9uTm9kZSdcbiAgKSB7XG4gICAgLy8gQ2xvc2luZyBxdW90ZXMuXG4gICAgbm9kZS52YWx1ZSA9IHN0YXRlLmNsb3NlW3F1b3RlSW5kZXhdXG4gIH0gZWxzZSBpZiAoXG4gICAgIW5leHQgfHxcbiAgICBuZXh0LnR5cGUgPT09ICdXaGl0ZVNwYWNlTm9kZScgfHxcbiAgICAodmFsdWUgPT09IFwiJ1wiICYmIG5leHRWYWx1ZSA9PT0gJ3MnKVxuICApIHtcbiAgICBub2RlLnZhbHVlID0gc3RhdGUuY2xvc2VbcXVvdGVJbmRleF1cbiAgfSBlbHNlIHtcbiAgICBub2RlLnZhbHVlID0gc3RhdGUub3BlbltxdW90ZUluZGV4XVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/retext-smartypants@6.2.0/node_modules/retext-smartypants/lib/index.js\n");

/***/ })

};
;