"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@shikijs+core@3.13.0";
exports.ids = ["vendor-chunks/@shikijs+core@3.13.0"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/@shikijs+core@3.13.0/node_modules/@shikijs/core/dist/index.mjs":
/*!********************************************************************************************!*\
  !*** ../node_modules/.pnpm/@shikijs+core@3.13.0/node_modules/@shikijs/core/dist/index.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShikiError: () => (/* reexport safe */ _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError),\n/* harmony export */   addClassToHast: () => (/* binding */ addClassToHast),\n/* harmony export */   applyColorReplacements: () => (/* binding */ applyColorReplacements),\n/* harmony export */   codeToHast: () => (/* binding */ codeToHast),\n/* harmony export */   codeToHtml: () => (/* binding */ codeToHtml),\n/* harmony export */   codeToTokens: () => (/* binding */ codeToTokens),\n/* harmony export */   codeToTokensBase: () => (/* binding */ codeToTokensBase),\n/* harmony export */   codeToTokensWithThemes: () => (/* binding */ codeToTokensWithThemes),\n/* harmony export */   createCssVariablesTheme: () => (/* binding */ createCssVariablesTheme),\n/* harmony export */   createHighlighterCore: () => (/* binding */ createHighlighterCore),\n/* harmony export */   createHighlighterCoreSync: () => (/* binding */ createHighlighterCoreSync),\n/* harmony export */   createPositionConverter: () => (/* binding */ createPositionConverter),\n/* harmony export */   createShikiInternal: () => (/* binding */ createShikiInternal),\n/* harmony export */   createShikiInternalSync: () => (/* binding */ createShikiInternalSync),\n/* harmony export */   createSingletonShorthands: () => (/* binding */ createSingletonShorthands),\n/* harmony export */   createdBundledHighlighter: () => (/* binding */ createdBundledHighlighter),\n/* harmony export */   enableDeprecationWarnings: () => (/* binding */ enableDeprecationWarnings),\n/* harmony export */   flatTokenVariants: () => (/* binding */ flatTokenVariants),\n/* harmony export */   getSingletonHighlighterCore: () => (/* binding */ getSingletonHighlighterCore),\n/* harmony export */   getTokenStyleObject: () => (/* binding */ getTokenStyleObject),\n/* harmony export */   guessEmbeddedLanguages: () => (/* binding */ guessEmbeddedLanguages),\n/* harmony export */   hastToHtml: () => (/* binding */ hastToHtml),\n/* harmony export */   isNoneTheme: () => (/* binding */ isNoneTheme),\n/* harmony export */   isPlainLang: () => (/* binding */ isPlainLang),\n/* harmony export */   isSpecialLang: () => (/* binding */ isSpecialLang),\n/* harmony export */   isSpecialTheme: () => (/* binding */ isSpecialTheme),\n/* harmony export */   makeSingletonHighlighter: () => (/* binding */ makeSingletonHighlighter),\n/* harmony export */   makeSingletonHighlighterCore: () => (/* binding */ makeSingletonHighlighterCore),\n/* harmony export */   normalizeGetter: () => (/* binding */ normalizeGetter),\n/* harmony export */   normalizeTheme: () => (/* binding */ normalizeTheme),\n/* harmony export */   resolveColorReplacements: () => (/* binding */ resolveColorReplacements),\n/* harmony export */   splitLines: () => (/* binding */ splitLines),\n/* harmony export */   splitToken: () => (/* binding */ splitToken),\n/* harmony export */   splitTokens: () => (/* binding */ splitTokens),\n/* harmony export */   stringifyTokenStyle: () => (/* binding */ stringifyTokenStyle),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   tokenizeAnsiWithTheme: () => (/* binding */ tokenizeAnsiWithTheme),\n/* harmony export */   tokenizeWithTheme: () => (/* binding */ tokenizeWithTheme),\n/* harmony export */   tokensToHast: () => (/* binding */ tokensToHast),\n/* harmony export */   transformerDecorations: () => (/* binding */ transformerDecorations),\n/* harmony export */   warnDeprecated: () => (/* binding */ warnDeprecated)\n/* harmony export */ });\n/* harmony import */ var _shikijs_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shikijs/types */ \"(rsc)/../node_modules/.pnpm/@shikijs+types@3.13.0/node_modules/@shikijs/types/dist/index.mjs\");\n/* harmony import */ var _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shikijs/vscode-textmate */ \"(rsc)/../node_modules/.pnpm/@shikijs+vscode-textmate@10.0.2/node_modules/@shikijs/vscode-textmate/dist/index.js\");\n/* harmony import */ var hast_util_to_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-to-html */ \"(rsc)/../node_modules/.pnpm/hast-util-to-html@9.0.5/node_modules/hast-util-to-html/lib/index.js\");\n\n\n\n\n\nfunction resolveColorReplacements(theme, options) {\n  const replacements = typeof theme === \"string\" ? {} : { ...theme.colorReplacements };\n  const themeName = typeof theme === \"string\" ? theme : theme.name;\n  for (const [key, value] of Object.entries(options?.colorReplacements || {})) {\n    if (typeof value === \"string\")\n      replacements[key] = value;\n    else if (key === themeName)\n      Object.assign(replacements, value);\n  }\n  return replacements;\n}\nfunction applyColorReplacements(color, replacements) {\n  if (!color)\n    return color;\n  return replacements?.[color?.toLowerCase()] || color;\n}\n\nfunction toArray(x) {\n  return Array.isArray(x) ? x : [x];\n}\nasync function normalizeGetter(p) {\n  return Promise.resolve(typeof p === \"function\" ? p() : p).then((r) => r.default || r);\n}\nfunction isPlainLang(lang) {\n  return !lang || [\"plaintext\", \"txt\", \"text\", \"plain\"].includes(lang);\n}\nfunction isSpecialLang(lang) {\n  return lang === \"ansi\" || isPlainLang(lang);\n}\nfunction isNoneTheme(theme) {\n  return theme === \"none\";\n}\nfunction isSpecialTheme(theme) {\n  return isNoneTheme(theme);\n}\n\nfunction addClassToHast(node, className) {\n  if (!className)\n    return node;\n  node.properties ||= {};\n  node.properties.class ||= [];\n  if (typeof node.properties.class === \"string\")\n    node.properties.class = node.properties.class.split(/\\s+/g);\n  if (!Array.isArray(node.properties.class))\n    node.properties.class = [];\n  const targets = Array.isArray(className) ? className : className.split(/\\s+/g);\n  for (const c of targets) {\n    if (c && !node.properties.class.includes(c))\n      node.properties.class.push(c);\n  }\n  return node;\n}\n\nfunction splitLines(code, preserveEnding = false) {\n  const parts = code.split(/(\\r?\\n)/g);\n  let index = 0;\n  const lines = [];\n  for (let i = 0; i < parts.length; i += 2) {\n    const line = preserveEnding ? parts[i] + (parts[i + 1] || \"\") : parts[i];\n    lines.push([line, index]);\n    index += parts[i].length;\n    index += parts[i + 1]?.length || 0;\n  }\n  return lines;\n}\nfunction createPositionConverter(code) {\n  const lines = splitLines(code, true).map(([line]) => line);\n  function indexToPos(index) {\n    if (index === code.length) {\n      return {\n        line: lines.length - 1,\n        character: lines[lines.length - 1].length\n      };\n    }\n    let character = index;\n    let line = 0;\n    for (const lineText of lines) {\n      if (character < lineText.length)\n        break;\n      character -= lineText.length;\n      line++;\n    }\n    return { line, character };\n  }\n  function posToIndex(line, character) {\n    let index = 0;\n    for (let i = 0; i < line; i++)\n      index += lines[i].length;\n    index += character;\n    return index;\n  }\n  return {\n    lines,\n    indexToPos,\n    posToIndex\n  };\n}\nfunction guessEmbeddedLanguages(code, _lang, highlighter) {\n  const langs = /* @__PURE__ */ new Set();\n  for (const match of code.matchAll(/lang=[\"']([\\w-]+)[\"']/g)) {\n    langs.add(match[1]);\n  }\n  for (const match of code.matchAll(/(?:```|~~~)([\\w-]+)/g)) {\n    langs.add(match[1]);\n  }\n  for (const match of code.matchAll(/\\\\begin\\{([\\w-]+)\\}/g)) {\n    langs.add(match[1]);\n  }\n  if (!highlighter)\n    return Array.from(langs);\n  const bundle = highlighter.getBundledLanguages();\n  return Array.from(langs).filter((l) => l && bundle[l]);\n}\n\nconst DEFAULT_COLOR_LIGHT_DARK = \"light-dark()\";\nconst COLOR_KEYS = [\"color\", \"background-color\"];\n\nfunction splitToken(token, offsets) {\n  let lastOffset = 0;\n  const tokens = [];\n  for (const offset of offsets) {\n    if (offset > lastOffset) {\n      tokens.push({\n        ...token,\n        content: token.content.slice(lastOffset, offset),\n        offset: token.offset + lastOffset\n      });\n    }\n    lastOffset = offset;\n  }\n  if (lastOffset < token.content.length) {\n    tokens.push({\n      ...token,\n      content: token.content.slice(lastOffset),\n      offset: token.offset + lastOffset\n    });\n  }\n  return tokens;\n}\nfunction splitTokens(tokens, breakpoints) {\n  const sorted = Array.from(breakpoints instanceof Set ? breakpoints : new Set(breakpoints)).sort((a, b) => a - b);\n  if (!sorted.length)\n    return tokens;\n  return tokens.map((line) => {\n    return line.flatMap((token) => {\n      const breakpointsInToken = sorted.filter((i) => token.offset < i && i < token.offset + token.content.length).map((i) => i - token.offset).sort((a, b) => a - b);\n      if (!breakpointsInToken.length)\n        return token;\n      return splitToken(token, breakpointsInToken);\n    });\n  });\n}\nfunction flatTokenVariants(merged, variantsOrder, cssVariablePrefix, defaultColor, colorsRendering = \"css-vars\") {\n  const token = {\n    content: merged.content,\n    explanation: merged.explanation,\n    offset: merged.offset\n  };\n  const styles = variantsOrder.map((t) => getTokenStyleObject(merged.variants[t]));\n  const styleKeys = new Set(styles.flatMap((t) => Object.keys(t)));\n  const mergedStyles = {};\n  const varKey = (idx, key) => {\n    const keyName = key === \"color\" ? \"\" : key === \"background-color\" ? \"-bg\" : `-${key}`;\n    return cssVariablePrefix + variantsOrder[idx] + (key === \"color\" ? \"\" : keyName);\n  };\n  styles.forEach((cur, idx) => {\n    for (const key of styleKeys) {\n      const value = cur[key] || \"inherit\";\n      if (idx === 0 && defaultColor && COLOR_KEYS.includes(key)) {\n        if (defaultColor === DEFAULT_COLOR_LIGHT_DARK && styles.length > 1) {\n          const lightIndex = variantsOrder.findIndex((t) => t === \"light\");\n          const darkIndex = variantsOrder.findIndex((t) => t === \"dark\");\n          if (lightIndex === -1 || darkIndex === -1)\n            throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError('When using `defaultColor: \"light-dark()\"`, you must provide both `light` and `dark` themes');\n          const lightValue = styles[lightIndex][key] || \"inherit\";\n          const darkValue = styles[darkIndex][key] || \"inherit\";\n          mergedStyles[key] = `light-dark(${lightValue}, ${darkValue})`;\n          if (colorsRendering === \"css-vars\")\n            mergedStyles[varKey(idx, key)] = value;\n        } else {\n          mergedStyles[key] = value;\n        }\n      } else {\n        if (colorsRendering === \"css-vars\")\n          mergedStyles[varKey(idx, key)] = value;\n      }\n    }\n  });\n  token.htmlStyle = mergedStyles;\n  return token;\n}\nfunction getTokenStyleObject(token) {\n  const styles = {};\n  if (token.color)\n    styles.color = token.color;\n  if (token.bgColor)\n    styles[\"background-color\"] = token.bgColor;\n  if (token.fontStyle) {\n    if (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Italic)\n      styles[\"font-style\"] = \"italic\";\n    if (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Bold)\n      styles[\"font-weight\"] = \"bold\";\n    const decorations = [];\n    if (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Underline)\n      decorations.push(\"underline\");\n    if (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Strikethrough)\n      decorations.push(\"line-through\");\n    if (decorations.length)\n      styles[\"text-decoration\"] = decorations.join(\" \");\n  }\n  return styles;\n}\nfunction stringifyTokenStyle(token) {\n  if (typeof token === \"string\")\n    return token;\n  return Object.entries(token).map(([key, value]) => `${key}:${value}`).join(\";\");\n}\n\nconst _grammarStateMap = /* @__PURE__ */ new WeakMap();\nfunction setLastGrammarStateToMap(keys, state) {\n  _grammarStateMap.set(keys, state);\n}\nfunction getLastGrammarStateFromMap(keys) {\n  return _grammarStateMap.get(keys);\n}\nclass GrammarState {\n  /**\n   * Theme to Stack mapping\n   */\n  _stacks = {};\n  lang;\n  get themes() {\n    return Object.keys(this._stacks);\n  }\n  get theme() {\n    return this.themes[0];\n  }\n  get _stack() {\n    return this._stacks[this.theme];\n  }\n  /**\n   * Static method to create a initial grammar state.\n   */\n  static initial(lang, themes) {\n    return new GrammarState(\n      Object.fromEntries(toArray(themes).map((theme) => [theme, _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.INITIAL])),\n      lang\n    );\n  }\n  constructor(...args) {\n    if (args.length === 2) {\n      const [stacksMap, lang] = args;\n      this.lang = lang;\n      this._stacks = stacksMap;\n    } else {\n      const [stack, lang, theme] = args;\n      this.lang = lang;\n      this._stacks = { [theme]: stack };\n    }\n  }\n  /**\n   * Get the internal stack object.\n   * @internal\n   */\n  getInternalStack(theme = this.theme) {\n    return this._stacks[theme];\n  }\n  getScopes(theme = this.theme) {\n    return getScopes(this._stacks[theme]);\n  }\n  toJSON() {\n    return {\n      lang: this.lang,\n      theme: this.theme,\n      themes: this.themes,\n      scopes: this.getScopes()\n    };\n  }\n}\nfunction getScopes(stack) {\n  const scopes = [];\n  const visited = /* @__PURE__ */ new Set();\n  function pushScope(stack2) {\n    if (visited.has(stack2))\n      return;\n    visited.add(stack2);\n    const name = stack2?.nameScopesList?.scopeName;\n    if (name)\n      scopes.push(name);\n    if (stack2.parent)\n      pushScope(stack2.parent);\n  }\n  pushScope(stack);\n  return scopes;\n}\nfunction getGrammarStack(state, theme) {\n  if (!(state instanceof GrammarState))\n    throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"Invalid grammar state\");\n  return state.getInternalStack(theme);\n}\n\nfunction transformerDecorations() {\n  const map = /* @__PURE__ */ new WeakMap();\n  function getContext(shiki) {\n    if (!map.has(shiki.meta)) {\n      let normalizePosition = function(p) {\n        if (typeof p === \"number\") {\n          if (p < 0 || p > shiki.source.length)\n            throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Invalid decoration offset: ${p}. Code length: ${shiki.source.length}`);\n          return {\n            ...converter.indexToPos(p),\n            offset: p\n          };\n        } else {\n          const line = converter.lines[p.line];\n          if (line === void 0)\n            throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Invalid decoration position ${JSON.stringify(p)}. Lines length: ${converter.lines.length}`);\n          let character = p.character;\n          if (character < 0)\n            character = line.length + character;\n          if (character < 0 || character > line.length)\n            throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Invalid decoration position ${JSON.stringify(p)}. Line ${p.line} length: ${line.length}`);\n          return {\n            ...p,\n            character,\n            offset: converter.posToIndex(p.line, character)\n          };\n        }\n      };\n      const converter = createPositionConverter(shiki.source);\n      const decorations = (shiki.options.decorations || []).map((d) => ({\n        ...d,\n        start: normalizePosition(d.start),\n        end: normalizePosition(d.end)\n      }));\n      verifyIntersections(decorations);\n      map.set(shiki.meta, {\n        decorations,\n        converter,\n        source: shiki.source\n      });\n    }\n    return map.get(shiki.meta);\n  }\n  return {\n    name: \"shiki:decorations\",\n    tokens(tokens) {\n      if (!this.options.decorations?.length)\n        return;\n      const ctx = getContext(this);\n      const breakpoints = ctx.decorations.flatMap((d) => [d.start.offset, d.end.offset]);\n      const splitted = splitTokens(tokens, breakpoints);\n      return splitted;\n    },\n    code(codeEl) {\n      if (!this.options.decorations?.length)\n        return;\n      const ctx = getContext(this);\n      const lines = Array.from(codeEl.children).filter((i) => i.type === \"element\" && i.tagName === \"span\");\n      if (lines.length !== ctx.converter.lines.length)\n        throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Number of lines in code element (${lines.length}) does not match the number of lines in the source (${ctx.converter.lines.length}). Failed to apply decorations.`);\n      function applyLineSection(line, start, end, decoration) {\n        const lineEl = lines[line];\n        let text = \"\";\n        let startIndex = -1;\n        let endIndex = -1;\n        if (start === 0)\n          startIndex = 0;\n        if (end === 0)\n          endIndex = 0;\n        if (end === Number.POSITIVE_INFINITY)\n          endIndex = lineEl.children.length;\n        if (startIndex === -1 || endIndex === -1) {\n          for (let i = 0; i < lineEl.children.length; i++) {\n            text += stringify(lineEl.children[i]);\n            if (startIndex === -1 && text.length === start)\n              startIndex = i + 1;\n            if (endIndex === -1 && text.length === end)\n              endIndex = i + 1;\n          }\n        }\n        if (startIndex === -1)\n          throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Failed to find start index for decoration ${JSON.stringify(decoration.start)}`);\n        if (endIndex === -1)\n          throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Failed to find end index for decoration ${JSON.stringify(decoration.end)}`);\n        const children = lineEl.children.slice(startIndex, endIndex);\n        if (!decoration.alwaysWrap && children.length === lineEl.children.length) {\n          applyDecoration(lineEl, decoration, \"line\");\n        } else if (!decoration.alwaysWrap && children.length === 1 && children[0].type === \"element\") {\n          applyDecoration(children[0], decoration, \"token\");\n        } else {\n          const wrapper = {\n            type: \"element\",\n            tagName: \"span\",\n            properties: {},\n            children\n          };\n          applyDecoration(wrapper, decoration, \"wrapper\");\n          lineEl.children.splice(startIndex, children.length, wrapper);\n        }\n      }\n      function applyLine(line, decoration) {\n        lines[line] = applyDecoration(lines[line], decoration, \"line\");\n      }\n      function applyDecoration(el, decoration, type) {\n        const properties = decoration.properties || {};\n        const transform = decoration.transform || ((i) => i);\n        el.tagName = decoration.tagName || \"span\";\n        el.properties = {\n          ...el.properties,\n          ...properties,\n          class: el.properties.class\n        };\n        if (decoration.properties?.class)\n          addClassToHast(el, decoration.properties.class);\n        el = transform(el, type) || el;\n        return el;\n      }\n      const lineApplies = [];\n      const sorted = ctx.decorations.sort((a, b) => b.start.offset - a.start.offset || a.end.offset - b.end.offset);\n      for (const decoration of sorted) {\n        const { start, end } = decoration;\n        if (start.line === end.line) {\n          applyLineSection(start.line, start.character, end.character, decoration);\n        } else if (start.line < end.line) {\n          applyLineSection(start.line, start.character, Number.POSITIVE_INFINITY, decoration);\n          for (let i = start.line + 1; i < end.line; i++)\n            lineApplies.unshift(() => applyLine(i, decoration));\n          applyLineSection(end.line, 0, end.character, decoration);\n        }\n      }\n      lineApplies.forEach((i) => i());\n    }\n  };\n}\nfunction verifyIntersections(items) {\n  for (let i = 0; i < items.length; i++) {\n    const foo = items[i];\n    if (foo.start.offset > foo.end.offset)\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Invalid decoration range: ${JSON.stringify(foo.start)} - ${JSON.stringify(foo.end)}`);\n    for (let j = i + 1; j < items.length; j++) {\n      const bar = items[j];\n      const isFooHasBarStart = foo.start.offset <= bar.start.offset && bar.start.offset < foo.end.offset;\n      const isFooHasBarEnd = foo.start.offset < bar.end.offset && bar.end.offset <= foo.end.offset;\n      const isBarHasFooStart = bar.start.offset <= foo.start.offset && foo.start.offset < bar.end.offset;\n      const isBarHasFooEnd = bar.start.offset < foo.end.offset && foo.end.offset <= bar.end.offset;\n      if (isFooHasBarStart || isFooHasBarEnd || isBarHasFooStart || isBarHasFooEnd) {\n        if (isFooHasBarStart && isFooHasBarEnd)\n          continue;\n        if (isBarHasFooStart && isBarHasFooEnd)\n          continue;\n        if (isBarHasFooStart && foo.start.offset === foo.end.offset)\n          continue;\n        if (isFooHasBarEnd && bar.start.offset === bar.end.offset)\n          continue;\n        throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Decorations ${JSON.stringify(foo.start)} and ${JSON.stringify(bar.start)} intersect.`);\n      }\n    }\n  }\n}\nfunction stringify(el) {\n  if (el.type === \"text\")\n    return el.value;\n  if (el.type === \"element\")\n    return el.children.map(stringify).join(\"\");\n  return \"\";\n}\n\nconst builtInTransformers = [\n  /* @__PURE__ */ transformerDecorations()\n];\nfunction getTransformers(options) {\n  const transformers = sortTransformersByEnforcement(options.transformers || []);\n  return [\n    ...transformers.pre,\n    ...transformers.normal,\n    ...transformers.post,\n    ...builtInTransformers\n  ];\n}\nfunction sortTransformersByEnforcement(transformers) {\n  const pre = [];\n  const post = [];\n  const normal = [];\n  for (const transformer of transformers) {\n    switch (transformer.enforce) {\n      case \"pre\":\n        pre.push(transformer);\n        break;\n      case \"post\":\n        post.push(transformer);\n        break;\n      default:\n        normal.push(transformer);\n    }\n  }\n  return { pre, post, normal };\n}\n\n// src/colors.ts\nvar namedColors = [\n  \"black\",\n  \"red\",\n  \"green\",\n  \"yellow\",\n  \"blue\",\n  \"magenta\",\n  \"cyan\",\n  \"white\",\n  \"brightBlack\",\n  \"brightRed\",\n  \"brightGreen\",\n  \"brightYellow\",\n  \"brightBlue\",\n  \"brightMagenta\",\n  \"brightCyan\",\n  \"brightWhite\"\n];\n\n// src/decorations.ts\nvar decorations = {\n  1: \"bold\",\n  2: \"dim\",\n  3: \"italic\",\n  4: \"underline\",\n  7: \"reverse\",\n  8: \"hidden\",\n  9: \"strikethrough\"\n};\n\n// src/parser.ts\nfunction findSequence(value, position) {\n  const nextEscape = value.indexOf(\"\\x1B\", position);\n  if (nextEscape !== -1) {\n    if (value[nextEscape + 1] === \"[\") {\n      const nextClose = value.indexOf(\"m\", nextEscape);\n      if (nextClose !== -1) {\n        return {\n          sequence: value.substring(nextEscape + 2, nextClose).split(\";\"),\n          startPosition: nextEscape,\n          position: nextClose + 1\n        };\n      }\n    }\n  }\n  return {\n    position: value.length\n  };\n}\nfunction parseColor(sequence) {\n  const colorMode = sequence.shift();\n  if (colorMode === \"2\") {\n    const rgb = sequence.splice(0, 3).map((x) => Number.parseInt(x));\n    if (rgb.length !== 3 || rgb.some((x) => Number.isNaN(x)))\n      return;\n    return {\n      type: \"rgb\",\n      rgb\n    };\n  } else if (colorMode === \"5\") {\n    const index = sequence.shift();\n    if (index) {\n      return { type: \"table\", index: Number(index) };\n    }\n  }\n}\nfunction parseSequence(sequence) {\n  const commands = [];\n  while (sequence.length > 0) {\n    const code = sequence.shift();\n    if (!code)\n      continue;\n    const codeInt = Number.parseInt(code);\n    if (Number.isNaN(codeInt))\n      continue;\n    if (codeInt === 0) {\n      commands.push({ type: \"resetAll\" });\n    } else if (codeInt <= 9) {\n      const decoration = decorations[codeInt];\n      if (decoration) {\n        commands.push({\n          type: \"setDecoration\",\n          value: decorations[codeInt]\n        });\n      }\n    } else if (codeInt <= 29) {\n      const decoration = decorations[codeInt - 20];\n      if (decoration) {\n        commands.push({\n          type: \"resetDecoration\",\n          value: decoration\n        });\n        if (decoration === \"dim\") {\n          commands.push({\n            type: \"resetDecoration\",\n            value: \"bold\"\n          });\n        }\n      }\n    } else if (codeInt <= 37) {\n      commands.push({\n        type: \"setForegroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 30] }\n      });\n    } else if (codeInt === 38) {\n      const color = parseColor(sequence);\n      if (color) {\n        commands.push({\n          type: \"setForegroundColor\",\n          value: color\n        });\n      }\n    } else if (codeInt === 39) {\n      commands.push({\n        type: \"resetForegroundColor\"\n      });\n    } else if (codeInt <= 47) {\n      commands.push({\n        type: \"setBackgroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 40] }\n      });\n    } else if (codeInt === 48) {\n      const color = parseColor(sequence);\n      if (color) {\n        commands.push({\n          type: \"setBackgroundColor\",\n          value: color\n        });\n      }\n    } else if (codeInt === 49) {\n      commands.push({\n        type: \"resetBackgroundColor\"\n      });\n    } else if (codeInt === 53) {\n      commands.push({\n        type: \"setDecoration\",\n        value: \"overline\"\n      });\n    } else if (codeInt === 55) {\n      commands.push({\n        type: \"resetDecoration\",\n        value: \"overline\"\n      });\n    } else if (codeInt >= 90 && codeInt <= 97) {\n      commands.push({\n        type: \"setForegroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 90 + 8] }\n      });\n    } else if (codeInt >= 100 && codeInt <= 107) {\n      commands.push({\n        type: \"setBackgroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 100 + 8] }\n      });\n    }\n  }\n  return commands;\n}\nfunction createAnsiSequenceParser() {\n  let foreground = null;\n  let background = null;\n  let decorations2 = /* @__PURE__ */ new Set();\n  return {\n    parse(value) {\n      const tokens = [];\n      let position = 0;\n      do {\n        const findResult = findSequence(value, position);\n        const text = findResult.sequence ? value.substring(position, findResult.startPosition) : value.substring(position);\n        if (text.length > 0) {\n          tokens.push({\n            value: text,\n            foreground,\n            background,\n            decorations: new Set(decorations2)\n          });\n        }\n        if (findResult.sequence) {\n          const commands = parseSequence(findResult.sequence);\n          for (const styleToken of commands) {\n            if (styleToken.type === \"resetAll\") {\n              foreground = null;\n              background = null;\n              decorations2.clear();\n            } else if (styleToken.type === \"resetForegroundColor\") {\n              foreground = null;\n            } else if (styleToken.type === \"resetBackgroundColor\") {\n              background = null;\n            } else if (styleToken.type === \"resetDecoration\") {\n              decorations2.delete(styleToken.value);\n            }\n          }\n          for (const styleToken of commands) {\n            if (styleToken.type === \"setForegroundColor\") {\n              foreground = styleToken.value;\n            } else if (styleToken.type === \"setBackgroundColor\") {\n              background = styleToken.value;\n            } else if (styleToken.type === \"setDecoration\") {\n              decorations2.add(styleToken.value);\n            }\n          }\n        }\n        position = findResult.position;\n      } while (position < value.length);\n      return tokens;\n    }\n  };\n}\n\n// src/palette.ts\nvar defaultNamedColorsMap = {\n  black: \"#000000\",\n  red: \"#bb0000\",\n  green: \"#00bb00\",\n  yellow: \"#bbbb00\",\n  blue: \"#0000bb\",\n  magenta: \"#ff00ff\",\n  cyan: \"#00bbbb\",\n  white: \"#eeeeee\",\n  brightBlack: \"#555555\",\n  brightRed: \"#ff5555\",\n  brightGreen: \"#00ff00\",\n  brightYellow: \"#ffff55\",\n  brightBlue: \"#5555ff\",\n  brightMagenta: \"#ff55ff\",\n  brightCyan: \"#55ffff\",\n  brightWhite: \"#ffffff\"\n};\nfunction createColorPalette(namedColorsMap = defaultNamedColorsMap) {\n  function namedColor(name) {\n    return namedColorsMap[name];\n  }\n  function rgbColor(rgb) {\n    return `#${rgb.map((x) => Math.max(0, Math.min(x, 255)).toString(16).padStart(2, \"0\")).join(\"\")}`;\n  }\n  let colorTable;\n  function getColorTable() {\n    if (colorTable) {\n      return colorTable;\n    }\n    colorTable = [];\n    for (let i = 0; i < namedColors.length; i++) {\n      colorTable.push(namedColor(namedColors[i]));\n    }\n    let levels = [0, 95, 135, 175, 215, 255];\n    for (let r = 0; r < 6; r++) {\n      for (let g = 0; g < 6; g++) {\n        for (let b = 0; b < 6; b++) {\n          colorTable.push(rgbColor([levels[r], levels[g], levels[b]]));\n        }\n      }\n    }\n    let level = 8;\n    for (let i = 0; i < 24; i++, level += 10) {\n      colorTable.push(rgbColor([level, level, level]));\n    }\n    return colorTable;\n  }\n  function tableColor(index) {\n    return getColorTable()[index];\n  }\n  function value(color) {\n    switch (color.type) {\n      case \"named\":\n        return namedColor(color.name);\n      case \"rgb\":\n        return rgbColor(color.rgb);\n      case \"table\":\n        return tableColor(color.index);\n    }\n  }\n  return {\n    value\n  };\n}\n\nfunction tokenizeAnsiWithTheme(theme, fileContents, options) {\n  const colorReplacements = resolveColorReplacements(theme, options);\n  const lines = splitLines(fileContents);\n  const colorPalette = createColorPalette(\n    Object.fromEntries(\n      namedColors.map((name) => [\n        name,\n        theme.colors?.[`terminal.ansi${name[0].toUpperCase()}${name.substring(1)}`]\n      ])\n    )\n  );\n  const parser = createAnsiSequenceParser();\n  return lines.map(\n    (line) => parser.parse(line[0]).map((token) => {\n      let color;\n      let bgColor;\n      if (token.decorations.has(\"reverse\")) {\n        color = token.background ? colorPalette.value(token.background) : theme.bg;\n        bgColor = token.foreground ? colorPalette.value(token.foreground) : theme.fg;\n      } else {\n        color = token.foreground ? colorPalette.value(token.foreground) : theme.fg;\n        bgColor = token.background ? colorPalette.value(token.background) : void 0;\n      }\n      color = applyColorReplacements(color, colorReplacements);\n      bgColor = applyColorReplacements(bgColor, colorReplacements);\n      if (token.decorations.has(\"dim\"))\n        color = dimColor(color);\n      let fontStyle = _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.None;\n      if (token.decorations.has(\"bold\"))\n        fontStyle |= _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Bold;\n      if (token.decorations.has(\"italic\"))\n        fontStyle |= _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Italic;\n      if (token.decorations.has(\"underline\"))\n        fontStyle |= _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Underline;\n      if (token.decorations.has(\"strikethrough\"))\n        fontStyle |= _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Strikethrough;\n      return {\n        content: token.value,\n        offset: line[1],\n        // TODO: more accurate offset? might need to fork ansi-sequence-parser\n        color,\n        bgColor,\n        fontStyle\n      };\n    })\n  );\n}\nfunction dimColor(color) {\n  const hexMatch = color.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);\n  if (hexMatch) {\n    if (hexMatch[3]) {\n      const alpha = Math.round(Number.parseInt(hexMatch[3], 16) / 2).toString(16).padStart(2, \"0\");\n      return `#${hexMatch[1]}${hexMatch[2]}${alpha}`;\n    } else if (hexMatch[2]) {\n      return `#${hexMatch[1]}${hexMatch[2]}80`;\n    } else {\n      return `#${Array.from(hexMatch[1]).map((x) => `${x}${x}`).join(\"\")}80`;\n    }\n  }\n  const cssVarMatch = color.match(/var\\((--[\\w-]+-ansi-[\\w-]+)\\)/);\n  if (cssVarMatch)\n    return `var(${cssVarMatch[1]}-dim)`;\n  return color;\n}\n\nfunction codeToTokensBase(internal, code, options = {}) {\n  const {\n    lang = \"text\",\n    theme: themeName = internal.getLoadedThemes()[0]\n  } = options;\n  if (isPlainLang(lang) || isNoneTheme(themeName))\n    return splitLines(code).map((line) => [{ content: line[0], offset: line[1] }]);\n  const { theme, colorMap } = internal.setTheme(themeName);\n  if (lang === \"ansi\")\n    return tokenizeAnsiWithTheme(theme, code, options);\n  const _grammar = internal.getLanguage(lang);\n  if (options.grammarState) {\n    if (options.grammarState.lang !== _grammar.name) {\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Grammar state language \"${options.grammarState.lang}\" does not match highlight language \"${_grammar.name}\"`);\n    }\n    if (!options.grammarState.themes.includes(theme.name)) {\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Grammar state themes \"${options.grammarState.themes}\" do not contain highlight theme \"${theme.name}\"`);\n    }\n  }\n  return tokenizeWithTheme(code, _grammar, theme, colorMap, options);\n}\nfunction getLastGrammarState(...args) {\n  if (args.length === 2) {\n    return getLastGrammarStateFromMap(args[1]);\n  }\n  const [internal, code, options = {}] = args;\n  const {\n    lang = \"text\",\n    theme: themeName = internal.getLoadedThemes()[0]\n  } = options;\n  if (isPlainLang(lang) || isNoneTheme(themeName))\n    throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"Plain language does not have grammar state\");\n  if (lang === \"ansi\")\n    throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"ANSI language does not have grammar state\");\n  const { theme, colorMap } = internal.setTheme(themeName);\n  const _grammar = internal.getLanguage(lang);\n  return new GrammarState(\n    _tokenizeWithTheme(code, _grammar, theme, colorMap, options).stateStack,\n    _grammar.name,\n    theme.name\n  );\n}\nfunction tokenizeWithTheme(code, grammar, theme, colorMap, options) {\n  const result = _tokenizeWithTheme(code, grammar, theme, colorMap, options);\n  const grammarState = new GrammarState(\n    _tokenizeWithTheme(code, grammar, theme, colorMap, options).stateStack,\n    grammar.name,\n    theme.name\n  );\n  setLastGrammarStateToMap(result.tokens, grammarState);\n  return result.tokens;\n}\nfunction _tokenizeWithTheme(code, grammar, theme, colorMap, options) {\n  const colorReplacements = resolveColorReplacements(theme, options);\n  const {\n    tokenizeMaxLineLength = 0,\n    tokenizeTimeLimit = 500\n  } = options;\n  const lines = splitLines(code);\n  let stateStack = options.grammarState ? getGrammarStack(options.grammarState, theme.name) ?? _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.INITIAL : options.grammarContextCode != null ? _tokenizeWithTheme(\n    options.grammarContextCode,\n    grammar,\n    theme,\n    colorMap,\n    {\n      ...options,\n      grammarState: void 0,\n      grammarContextCode: void 0\n    }\n  ).stateStack : _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.INITIAL;\n  let actual = [];\n  const final = [];\n  for (let i = 0, len = lines.length; i < len; i++) {\n    const [line, lineOffset] = lines[i];\n    if (line === \"\") {\n      actual = [];\n      final.push([]);\n      continue;\n    }\n    if (tokenizeMaxLineLength > 0 && line.length >= tokenizeMaxLineLength) {\n      actual = [];\n      final.push([{\n        content: line,\n        offset: lineOffset,\n        color: \"\",\n        fontStyle: 0\n      }]);\n      continue;\n    }\n    let resultWithScopes;\n    let tokensWithScopes;\n    let tokensWithScopesIndex;\n    if (options.includeExplanation) {\n      resultWithScopes = grammar.tokenizeLine(line, stateStack, tokenizeTimeLimit);\n      tokensWithScopes = resultWithScopes.tokens;\n      tokensWithScopesIndex = 0;\n    }\n    const result = grammar.tokenizeLine2(line, stateStack, tokenizeTimeLimit);\n    const tokensLength = result.tokens.length / 2;\n    for (let j = 0; j < tokensLength; j++) {\n      const startIndex = result.tokens[2 * j];\n      const nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line.length;\n      if (startIndex === nextStartIndex)\n        continue;\n      const metadata = result.tokens[2 * j + 1];\n      const color = applyColorReplacements(\n        colorMap[_shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.EncodedTokenMetadata.getForeground(metadata)],\n        colorReplacements\n      );\n      const fontStyle = _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.EncodedTokenMetadata.getFontStyle(metadata);\n      const token = {\n        content: line.substring(startIndex, nextStartIndex),\n        offset: lineOffset + startIndex,\n        color,\n        fontStyle\n      };\n      if (options.includeExplanation) {\n        const themeSettingsSelectors = [];\n        if (options.includeExplanation !== \"scopeName\") {\n          for (const setting of theme.settings) {\n            let selectors;\n            switch (typeof setting.scope) {\n              case \"string\":\n                selectors = setting.scope.split(/,/).map((scope) => scope.trim());\n                break;\n              case \"object\":\n                selectors = setting.scope;\n                break;\n              default:\n                continue;\n            }\n            themeSettingsSelectors.push({\n              settings: setting,\n              selectors: selectors.map((selector) => selector.split(/ /))\n            });\n          }\n        }\n        token.explanation = [];\n        let offset = 0;\n        while (startIndex + offset < nextStartIndex) {\n          const tokenWithScopes = tokensWithScopes[tokensWithScopesIndex];\n          const tokenWithScopesText = line.substring(\n            tokenWithScopes.startIndex,\n            tokenWithScopes.endIndex\n          );\n          offset += tokenWithScopesText.length;\n          token.explanation.push({\n            content: tokenWithScopesText,\n            scopes: options.includeExplanation === \"scopeName\" ? explainThemeScopesNameOnly(\n              tokenWithScopes.scopes\n            ) : explainThemeScopesFull(\n              themeSettingsSelectors,\n              tokenWithScopes.scopes\n            )\n          });\n          tokensWithScopesIndex += 1;\n        }\n      }\n      actual.push(token);\n    }\n    final.push(actual);\n    actual = [];\n    stateStack = result.ruleStack;\n  }\n  return {\n    tokens: final,\n    stateStack\n  };\n}\nfunction explainThemeScopesNameOnly(scopes) {\n  return scopes.map((scope) => ({ scopeName: scope }));\n}\nfunction explainThemeScopesFull(themeSelectors, scopes) {\n  const result = [];\n  for (let i = 0, len = scopes.length; i < len; i++) {\n    const scope = scopes[i];\n    result[i] = {\n      scopeName: scope,\n      themeMatches: explainThemeScope(themeSelectors, scope, scopes.slice(0, i))\n    };\n  }\n  return result;\n}\nfunction matchesOne(selector, scope) {\n  return selector === scope || scope.substring(0, selector.length) === selector && scope[selector.length] === \".\";\n}\nfunction matches(selectors, scope, parentScopes) {\n  if (!matchesOne(selectors[selectors.length - 1], scope))\n    return false;\n  let selectorParentIndex = selectors.length - 2;\n  let parentIndex = parentScopes.length - 1;\n  while (selectorParentIndex >= 0 && parentIndex >= 0) {\n    if (matchesOne(selectors[selectorParentIndex], parentScopes[parentIndex]))\n      selectorParentIndex -= 1;\n    parentIndex -= 1;\n  }\n  if (selectorParentIndex === -1)\n    return true;\n  return false;\n}\nfunction explainThemeScope(themeSettingsSelectors, scope, parentScopes) {\n  const result = [];\n  for (const { selectors, settings } of themeSettingsSelectors) {\n    for (const selectorPieces of selectors) {\n      if (matches(selectorPieces, scope, parentScopes)) {\n        result.push(settings);\n        break;\n      }\n    }\n  }\n  return result;\n}\n\nfunction codeToTokensWithThemes(internal, code, options) {\n  const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] }));\n  const themedTokens = themes.map((t) => {\n    const tokens2 = codeToTokensBase(internal, code, {\n      ...options,\n      theme: t.theme\n    });\n    const state = getLastGrammarStateFromMap(tokens2);\n    const theme = typeof t.theme === \"string\" ? t.theme : t.theme.name;\n    return {\n      tokens: tokens2,\n      state,\n      theme\n    };\n  });\n  const tokens = syncThemesTokenization(\n    ...themedTokens.map((i) => i.tokens)\n  );\n  const mergedTokens = tokens[0].map(\n    (line, lineIdx) => line.map((_token, tokenIdx) => {\n      const mergedToken = {\n        content: _token.content,\n        variants: {},\n        offset: _token.offset\n      };\n      if (\"includeExplanation\" in options && options.includeExplanation) {\n        mergedToken.explanation = _token.explanation;\n      }\n      tokens.forEach((t, themeIdx) => {\n        const {\n          content: _,\n          explanation: __,\n          offset: ___,\n          ...styles\n        } = t[lineIdx][tokenIdx];\n        mergedToken.variants[themes[themeIdx].color] = styles;\n      });\n      return mergedToken;\n    })\n  );\n  const mergedGrammarState = themedTokens[0].state ? new GrammarState(\n    Object.fromEntries(themedTokens.map((s) => [s.theme, s.state?.getInternalStack(s.theme)])),\n    themedTokens[0].state.lang\n  ) : void 0;\n  if (mergedGrammarState)\n    setLastGrammarStateToMap(mergedTokens, mergedGrammarState);\n  return mergedTokens;\n}\nfunction syncThemesTokenization(...themes) {\n  const outThemes = themes.map(() => []);\n  const count = themes.length;\n  for (let i = 0; i < themes[0].length; i++) {\n    const lines = themes.map((t) => t[i]);\n    const outLines = outThemes.map(() => []);\n    outThemes.forEach((t, i2) => t.push(outLines[i2]));\n    const indexes = lines.map(() => 0);\n    const current = lines.map((l) => l[0]);\n    while (current.every((t) => t)) {\n      const minLength = Math.min(...current.map((t) => t.content.length));\n      for (let n = 0; n < count; n++) {\n        const token = current[n];\n        if (token.content.length === minLength) {\n          outLines[n].push(token);\n          indexes[n] += 1;\n          current[n] = lines[n][indexes[n]];\n        } else {\n          outLines[n].push({\n            ...token,\n            content: token.content.slice(0, minLength)\n          });\n          current[n] = {\n            ...token,\n            content: token.content.slice(minLength),\n            offset: token.offset + minLength\n          };\n        }\n      }\n    }\n  }\n  return outThemes;\n}\n\nfunction codeToTokens(internal, code, options) {\n  let bg;\n  let fg;\n  let tokens;\n  let themeName;\n  let rootStyle;\n  let grammarState;\n  if (\"themes\" in options) {\n    const {\n      defaultColor = \"light\",\n      cssVariablePrefix = \"--shiki-\",\n      colorsRendering = \"css-vars\"\n    } = options;\n    const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] })).sort((a, b) => a.color === defaultColor ? -1 : b.color === defaultColor ? 1 : 0);\n    if (themes.length === 0)\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"`themes` option must not be empty\");\n    const themeTokens = codeToTokensWithThemes(\n      internal,\n      code,\n      options\n    );\n    grammarState = getLastGrammarStateFromMap(themeTokens);\n    if (defaultColor && DEFAULT_COLOR_LIGHT_DARK !== defaultColor && !themes.find((t) => t.color === defaultColor))\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`\\`themes\\` option must contain the defaultColor key \\`${defaultColor}\\``);\n    const themeRegs = themes.map((t) => internal.getTheme(t.theme));\n    const themesOrder = themes.map((t) => t.color);\n    tokens = themeTokens.map((line) => line.map((token) => flatTokenVariants(token, themesOrder, cssVariablePrefix, defaultColor, colorsRendering)));\n    if (grammarState)\n      setLastGrammarStateToMap(tokens, grammarState);\n    const themeColorReplacements = themes.map((t) => resolveColorReplacements(t.theme, options));\n    fg = mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, \"fg\", colorsRendering);\n    bg = mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, \"bg\", colorsRendering);\n    themeName = `shiki-themes ${themeRegs.map((t) => t.name).join(\" \")}`;\n    rootStyle = defaultColor ? void 0 : [fg, bg].join(\";\");\n  } else if (\"theme\" in options) {\n    const colorReplacements = resolveColorReplacements(options.theme, options);\n    tokens = codeToTokensBase(\n      internal,\n      code,\n      options\n    );\n    const _theme = internal.getTheme(options.theme);\n    bg = applyColorReplacements(_theme.bg, colorReplacements);\n    fg = applyColorReplacements(_theme.fg, colorReplacements);\n    themeName = _theme.name;\n    grammarState = getLastGrammarStateFromMap(tokens);\n  } else {\n    throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"Invalid options, either `theme` or `themes` must be provided\");\n  }\n  return {\n    tokens,\n    fg,\n    bg,\n    themeName,\n    rootStyle,\n    grammarState\n  };\n}\nfunction mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, property, colorsRendering) {\n  return themes.map((t, idx) => {\n    const value = applyColorReplacements(themeRegs[idx][property], themeColorReplacements[idx]) || \"inherit\";\n    const cssVar = `${cssVariablePrefix + t.color}${property === \"bg\" ? \"-bg\" : \"\"}:${value}`;\n    if (idx === 0 && defaultColor) {\n      if (defaultColor === DEFAULT_COLOR_LIGHT_DARK && themes.length > 1) {\n        const lightIndex = themes.findIndex((t2) => t2.color === \"light\");\n        const darkIndex = themes.findIndex((t2) => t2.color === \"dark\");\n        if (lightIndex === -1 || darkIndex === -1)\n          throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError('When using `defaultColor: \"light-dark()\"`, you must provide both `light` and `dark` themes');\n        const lightValue = applyColorReplacements(themeRegs[lightIndex][property], themeColorReplacements[lightIndex]) || \"inherit\";\n        const darkValue = applyColorReplacements(themeRegs[darkIndex][property], themeColorReplacements[darkIndex]) || \"inherit\";\n        return `light-dark(${lightValue}, ${darkValue});${cssVar}`;\n      }\n      return value;\n    }\n    if (colorsRendering === \"css-vars\") {\n      return cssVar;\n    }\n    return null;\n  }).filter((i) => !!i).join(\";\");\n}\n\nfunction codeToHast(internal, code, options, transformerContext = {\n  meta: {},\n  options,\n  codeToHast: (_code, _options) => codeToHast(internal, _code, _options),\n  codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)\n}) {\n  let input = code;\n  for (const transformer of getTransformers(options))\n    input = transformer.preprocess?.call(transformerContext, input, options) || input;\n  let {\n    tokens,\n    fg,\n    bg,\n    themeName,\n    rootStyle,\n    grammarState\n  } = codeToTokens(internal, input, options);\n  const {\n    mergeWhitespaces = true,\n    mergeSameStyleTokens = false\n  } = options;\n  if (mergeWhitespaces === true)\n    tokens = mergeWhitespaceTokens(tokens);\n  else if (mergeWhitespaces === \"never\")\n    tokens = splitWhitespaceTokens(tokens);\n  if (mergeSameStyleTokens) {\n    tokens = mergeAdjacentStyledTokens(tokens);\n  }\n  const contextSource = {\n    ...transformerContext,\n    get source() {\n      return input;\n    }\n  };\n  for (const transformer of getTransformers(options))\n    tokens = transformer.tokens?.call(contextSource, tokens) || tokens;\n  return tokensToHast(\n    tokens,\n    {\n      ...options,\n      fg,\n      bg,\n      themeName,\n      rootStyle\n    },\n    contextSource,\n    grammarState\n  );\n}\nfunction tokensToHast(tokens, options, transformerContext, grammarState = getLastGrammarStateFromMap(tokens)) {\n  const transformers = getTransformers(options);\n  const lines = [];\n  const root = {\n    type: \"root\",\n    children: []\n  };\n  const {\n    structure = \"classic\",\n    tabindex = \"0\"\n  } = options;\n  let preNode = {\n    type: \"element\",\n    tagName: \"pre\",\n    properties: {\n      class: `shiki ${options.themeName || \"\"}`,\n      style: options.rootStyle || `background-color:${options.bg};color:${options.fg}`,\n      ...tabindex !== false && tabindex != null ? {\n        tabindex: tabindex.toString()\n      } : {},\n      ...Object.fromEntries(\n        Array.from(\n          Object.entries(options.meta || {})\n        ).filter(([key]) => !key.startsWith(\"_\"))\n      )\n    },\n    children: []\n  };\n  let codeNode = {\n    type: \"element\",\n    tagName: \"code\",\n    properties: {},\n    children: lines\n  };\n  const lineNodes = [];\n  const context = {\n    ...transformerContext,\n    structure,\n    addClassToHast,\n    get source() {\n      return transformerContext.source;\n    },\n    get tokens() {\n      return tokens;\n    },\n    get options() {\n      return options;\n    },\n    get root() {\n      return root;\n    },\n    get pre() {\n      return preNode;\n    },\n    get code() {\n      return codeNode;\n    },\n    get lines() {\n      return lineNodes;\n    }\n  };\n  tokens.forEach((line, idx) => {\n    if (idx) {\n      if (structure === \"inline\")\n        root.children.push({ type: \"element\", tagName: \"br\", properties: {}, children: [] });\n      else if (structure === \"classic\")\n        lines.push({ type: \"text\", value: \"\\n\" });\n    }\n    let lineNode = {\n      type: \"element\",\n      tagName: \"span\",\n      properties: { class: \"line\" },\n      children: []\n    };\n    let col = 0;\n    for (const token of line) {\n      let tokenNode = {\n        type: \"element\",\n        tagName: \"span\",\n        properties: {\n          ...token.htmlAttrs\n        },\n        children: [{ type: \"text\", value: token.content }]\n      };\n      const style = stringifyTokenStyle(token.htmlStyle || getTokenStyleObject(token));\n      if (style)\n        tokenNode.properties.style = style;\n      for (const transformer of transformers)\n        tokenNode = transformer?.span?.call(context, tokenNode, idx + 1, col, lineNode, token) || tokenNode;\n      if (structure === \"inline\")\n        root.children.push(tokenNode);\n      else if (structure === \"classic\")\n        lineNode.children.push(tokenNode);\n      col += token.content.length;\n    }\n    if (structure === \"classic\") {\n      for (const transformer of transformers)\n        lineNode = transformer?.line?.call(context, lineNode, idx + 1) || lineNode;\n      lineNodes.push(lineNode);\n      lines.push(lineNode);\n    }\n  });\n  if (structure === \"classic\") {\n    for (const transformer of transformers)\n      codeNode = transformer?.code?.call(context, codeNode) || codeNode;\n    preNode.children.push(codeNode);\n    for (const transformer of transformers)\n      preNode = transformer?.pre?.call(context, preNode) || preNode;\n    root.children.push(preNode);\n  }\n  let result = root;\n  for (const transformer of transformers)\n    result = transformer?.root?.call(context, result) || result;\n  if (grammarState)\n    setLastGrammarStateToMap(result, grammarState);\n  return result;\n}\nfunction mergeWhitespaceTokens(tokens) {\n  return tokens.map((line) => {\n    const newLine = [];\n    let carryOnContent = \"\";\n    let firstOffset = 0;\n    line.forEach((token, idx) => {\n      const isDecorated = token.fontStyle && (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Underline || token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Strikethrough);\n      const couldMerge = !isDecorated;\n      if (couldMerge && token.content.match(/^\\s+$/) && line[idx + 1]) {\n        if (!firstOffset)\n          firstOffset = token.offset;\n        carryOnContent += token.content;\n      } else {\n        if (carryOnContent) {\n          if (couldMerge) {\n            newLine.push({\n              ...token,\n              offset: firstOffset,\n              content: carryOnContent + token.content\n            });\n          } else {\n            newLine.push(\n              {\n                content: carryOnContent,\n                offset: firstOffset\n              },\n              token\n            );\n          }\n          firstOffset = 0;\n          carryOnContent = \"\";\n        } else {\n          newLine.push(token);\n        }\n      }\n    });\n    return newLine;\n  });\n}\nfunction splitWhitespaceTokens(tokens) {\n  return tokens.map((line) => {\n    return line.flatMap((token) => {\n      if (token.content.match(/^\\s+$/))\n        return token;\n      const match = token.content.match(/^(\\s*)(.*?)(\\s*)$/);\n      if (!match)\n        return token;\n      const [, leading, content, trailing] = match;\n      if (!leading && !trailing)\n        return token;\n      const expanded = [{\n        ...token,\n        offset: token.offset + leading.length,\n        content\n      }];\n      if (leading) {\n        expanded.unshift({\n          content: leading,\n          offset: token.offset\n        });\n      }\n      if (trailing) {\n        expanded.push({\n          content: trailing,\n          offset: token.offset + leading.length + content.length\n        });\n      }\n      return expanded;\n    });\n  });\n}\nfunction mergeAdjacentStyledTokens(tokens) {\n  return tokens.map((line) => {\n    const newLine = [];\n    for (const token of line) {\n      if (newLine.length === 0) {\n        newLine.push({ ...token });\n        continue;\n      }\n      const prevToken = newLine[newLine.length - 1];\n      const prevStyle = stringifyTokenStyle(prevToken.htmlStyle || getTokenStyleObject(prevToken));\n      const currentStyle = stringifyTokenStyle(token.htmlStyle || getTokenStyleObject(token));\n      const isPrevDecorated = prevToken.fontStyle && (prevToken.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Underline || prevToken.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Strikethrough);\n      const isDecorated = token.fontStyle && (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Underline || token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Strikethrough);\n      if (!isPrevDecorated && !isDecorated && prevStyle === currentStyle) {\n        prevToken.content += token.content;\n      } else {\n        newLine.push({ ...token });\n      }\n    }\n    return newLine;\n  });\n}\n\nconst hastToHtml = hast_util_to_html__WEBPACK_IMPORTED_MODULE_2__.toHtml;\nfunction codeToHtml(internal, code, options) {\n  const context = {\n    meta: {},\n    options,\n    codeToHast: (_code, _options) => codeToHast(internal, _code, _options),\n    codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)\n  };\n  let result = hastToHtml(codeToHast(internal, code, options, context));\n  for (const transformer of getTransformers(options))\n    result = transformer.postprocess?.call(context, result, options) || result;\n  return result;\n}\n\nconst VSCODE_FALLBACK_EDITOR_FG = { light: \"#333333\", dark: \"#bbbbbb\" };\nconst VSCODE_FALLBACK_EDITOR_BG = { light: \"#fffffe\", dark: \"#1e1e1e\" };\nconst RESOLVED_KEY = \"__shiki_resolved\";\nfunction normalizeTheme(rawTheme) {\n  if (rawTheme?.[RESOLVED_KEY])\n    return rawTheme;\n  const theme = {\n    ...rawTheme\n  };\n  if (theme.tokenColors && !theme.settings) {\n    theme.settings = theme.tokenColors;\n    delete theme.tokenColors;\n  }\n  theme.type ||= \"dark\";\n  theme.colorReplacements = { ...theme.colorReplacements };\n  theme.settings ||= [];\n  let { bg, fg } = theme;\n  if (!bg || !fg) {\n    const globalSetting = theme.settings ? theme.settings.find((s) => !s.name && !s.scope) : void 0;\n    if (globalSetting?.settings?.foreground)\n      fg = globalSetting.settings.foreground;\n    if (globalSetting?.settings?.background)\n      bg = globalSetting.settings.background;\n    if (!fg && theme?.colors?.[\"editor.foreground\"])\n      fg = theme.colors[\"editor.foreground\"];\n    if (!bg && theme?.colors?.[\"editor.background\"])\n      bg = theme.colors[\"editor.background\"];\n    if (!fg)\n      fg = theme.type === \"light\" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark;\n    if (!bg)\n      bg = theme.type === \"light\" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark;\n    theme.fg = fg;\n    theme.bg = bg;\n  }\n  if (!(theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope)) {\n    theme.settings.unshift({\n      settings: {\n        foreground: theme.fg,\n        background: theme.bg\n      }\n    });\n  }\n  let replacementCount = 0;\n  const replacementMap = /* @__PURE__ */ new Map();\n  function getReplacementColor(value) {\n    if (replacementMap.has(value))\n      return replacementMap.get(value);\n    replacementCount += 1;\n    const hex = `#${replacementCount.toString(16).padStart(8, \"0\").toLowerCase()}`;\n    if (theme.colorReplacements?.[`#${hex}`])\n      return getReplacementColor(value);\n    replacementMap.set(value, hex);\n    return hex;\n  }\n  theme.settings = theme.settings.map((setting) => {\n    const replaceFg = setting.settings?.foreground && !setting.settings.foreground.startsWith(\"#\");\n    const replaceBg = setting.settings?.background && !setting.settings.background.startsWith(\"#\");\n    if (!replaceFg && !replaceBg)\n      return setting;\n    const clone = {\n      ...setting,\n      settings: {\n        ...setting.settings\n      }\n    };\n    if (replaceFg) {\n      const replacement = getReplacementColor(setting.settings.foreground);\n      theme.colorReplacements[replacement] = setting.settings.foreground;\n      clone.settings.foreground = replacement;\n    }\n    if (replaceBg) {\n      const replacement = getReplacementColor(setting.settings.background);\n      theme.colorReplacements[replacement] = setting.settings.background;\n      clone.settings.background = replacement;\n    }\n    return clone;\n  });\n  for (const key of Object.keys(theme.colors || {})) {\n    if (key === \"editor.foreground\" || key === \"editor.background\" || key.startsWith(\"terminal.ansi\")) {\n      if (!theme.colors[key]?.startsWith(\"#\")) {\n        const replacement = getReplacementColor(theme.colors[key]);\n        theme.colorReplacements[replacement] = theme.colors[key];\n        theme.colors[key] = replacement;\n      }\n    }\n  }\n  Object.defineProperty(theme, RESOLVED_KEY, {\n    enumerable: false,\n    writable: false,\n    value: true\n  });\n  return theme;\n}\n\nasync function resolveLangs(langs) {\n  return Array.from(new Set((await Promise.all(\n    langs.filter((l) => !isSpecialLang(l)).map(async (lang) => await normalizeGetter(lang).then((r) => Array.isArray(r) ? r : [r]))\n  )).flat()));\n}\nasync function resolveThemes(themes) {\n  const resolved = await Promise.all(\n    themes.map(\n      async (theme) => isSpecialTheme(theme) ? null : normalizeTheme(await normalizeGetter(theme))\n    )\n  );\n  return resolved.filter((i) => !!i);\n}\n\nlet _emitDeprecation = 3;\nlet _emitError = false;\nfunction enableDeprecationWarnings(emitDeprecation = true, emitError = false) {\n  _emitDeprecation = emitDeprecation;\n  _emitError = emitError;\n}\nfunction warnDeprecated(message, version = 3) {\n  if (!_emitDeprecation)\n    return;\n  if (typeof _emitDeprecation === \"number\" && version > _emitDeprecation)\n    return;\n  if (_emitError) {\n    throw new Error(`[SHIKI DEPRECATE]: ${message}`);\n  } else {\n    console.trace(`[SHIKI DEPRECATE]: ${message}`);\n  }\n}\n\nclass ShikiError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ShikiError\";\n  }\n}\n\nclass Registry extends _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.Registry {\n  constructor(_resolver, _themes, _langs, _alias = {}) {\n    super(_resolver);\n    this._resolver = _resolver;\n    this._themes = _themes;\n    this._langs = _langs;\n    this._alias = _alias;\n    this._themes.map((t) => this.loadTheme(t));\n    this.loadLanguages(this._langs);\n  }\n  _resolvedThemes = /* @__PURE__ */ new Map();\n  _resolvedGrammars = /* @__PURE__ */ new Map();\n  _langMap = /* @__PURE__ */ new Map();\n  _langGraph = /* @__PURE__ */ new Map();\n  _textmateThemeCache = /* @__PURE__ */ new WeakMap();\n  _loadedThemesCache = null;\n  _loadedLanguagesCache = null;\n  getTheme(theme) {\n    if (typeof theme === \"string\")\n      return this._resolvedThemes.get(theme);\n    else\n      return this.loadTheme(theme);\n  }\n  loadTheme(theme) {\n    const _theme = normalizeTheme(theme);\n    if (_theme.name) {\n      this._resolvedThemes.set(_theme.name, _theme);\n      this._loadedThemesCache = null;\n    }\n    return _theme;\n  }\n  getLoadedThemes() {\n    if (!this._loadedThemesCache)\n      this._loadedThemesCache = [...this._resolvedThemes.keys()];\n    return this._loadedThemesCache;\n  }\n  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`\n  // is expensive. Themes can switch often especially for dual-theme support.\n  //\n  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,\n  // we omit here so it's easier to cache the themes.\n  setTheme(theme) {\n    let textmateTheme = this._textmateThemeCache.get(theme);\n    if (!textmateTheme) {\n      textmateTheme = _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.Theme.createFromRawTheme(theme);\n      this._textmateThemeCache.set(theme, textmateTheme);\n    }\n    this._syncRegistry.setTheme(textmateTheme);\n  }\n  getGrammar(name) {\n    if (this._alias[name]) {\n      const resolved = /* @__PURE__ */ new Set([name]);\n      while (this._alias[name]) {\n        name = this._alias[name];\n        if (resolved.has(name))\n          throw new ShikiError(`Circular alias \\`${Array.from(resolved).join(\" -> \")} -> ${name}\\``);\n        resolved.add(name);\n      }\n    }\n    return this._resolvedGrammars.get(name);\n  }\n  loadLanguage(lang) {\n    if (this.getGrammar(lang.name))\n      return;\n    const embeddedLazilyBy = new Set(\n      [...this._langMap.values()].filter((i) => i.embeddedLangsLazy?.includes(lang.name))\n    );\n    this._resolver.addLanguage(lang);\n    const grammarConfig = {\n      balancedBracketSelectors: lang.balancedBracketSelectors || [\"*\"],\n      unbalancedBracketSelectors: lang.unbalancedBracketSelectors || []\n    };\n    this._syncRegistry._rawGrammars.set(lang.scopeName, lang);\n    const g = this.loadGrammarWithConfiguration(lang.scopeName, 1, grammarConfig);\n    g.name = lang.name;\n    this._resolvedGrammars.set(lang.name, g);\n    if (lang.aliases) {\n      lang.aliases.forEach((alias) => {\n        this._alias[alias] = lang.name;\n      });\n    }\n    this._loadedLanguagesCache = null;\n    if (embeddedLazilyBy.size) {\n      for (const e of embeddedLazilyBy) {\n        this._resolvedGrammars.delete(e.name);\n        this._loadedLanguagesCache = null;\n        this._syncRegistry?._injectionGrammars?.delete(e.scopeName);\n        this._syncRegistry?._grammars?.delete(e.scopeName);\n        this.loadLanguage(this._langMap.get(e.name));\n      }\n    }\n  }\n  dispose() {\n    super.dispose();\n    this._resolvedThemes.clear();\n    this._resolvedGrammars.clear();\n    this._langMap.clear();\n    this._langGraph.clear();\n    this._loadedThemesCache = null;\n  }\n  loadLanguages(langs) {\n    for (const lang of langs)\n      this.resolveEmbeddedLanguages(lang);\n    const langsGraphArray = Array.from(this._langGraph.entries());\n    const missingLangs = langsGraphArray.filter(([_, lang]) => !lang);\n    if (missingLangs.length) {\n      const dependents = langsGraphArray.filter(([_, lang]) => lang && lang.embeddedLangs?.some((l) => missingLangs.map(([name]) => name).includes(l))).filter((lang) => !missingLangs.includes(lang));\n      throw new ShikiError(`Missing languages ${missingLangs.map(([name]) => `\\`${name}\\``).join(\", \")}, required by ${dependents.map(([name]) => `\\`${name}\\``).join(\", \")}`);\n    }\n    for (const [_, lang] of langsGraphArray)\n      this._resolver.addLanguage(lang);\n    for (const [_, lang] of langsGraphArray)\n      this.loadLanguage(lang);\n  }\n  getLoadedLanguages() {\n    if (!this._loadedLanguagesCache) {\n      this._loadedLanguagesCache = [\n        .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])\n      ];\n    }\n    return this._loadedLanguagesCache;\n  }\n  resolveEmbeddedLanguages(lang) {\n    this._langMap.set(lang.name, lang);\n    this._langGraph.set(lang.name, lang);\n    if (lang.embeddedLangs) {\n      for (const embeddedLang of lang.embeddedLangs)\n        this._langGraph.set(embeddedLang, this._langMap.get(embeddedLang));\n    }\n  }\n}\n\nclass Resolver {\n  _langs = /* @__PURE__ */ new Map();\n  _scopeToLang = /* @__PURE__ */ new Map();\n  _injections = /* @__PURE__ */ new Map();\n  _onigLib;\n  constructor(engine, langs) {\n    this._onigLib = {\n      createOnigScanner: (patterns) => engine.createScanner(patterns),\n      createOnigString: (s) => engine.createString(s)\n    };\n    langs.forEach((i) => this.addLanguage(i));\n  }\n  get onigLib() {\n    return this._onigLib;\n  }\n  getLangRegistration(langIdOrAlias) {\n    return this._langs.get(langIdOrAlias);\n  }\n  loadGrammar(scopeName) {\n    return this._scopeToLang.get(scopeName);\n  }\n  addLanguage(l) {\n    this._langs.set(l.name, l);\n    if (l.aliases) {\n      l.aliases.forEach((a) => {\n        this._langs.set(a, l);\n      });\n    }\n    this._scopeToLang.set(l.scopeName, l);\n    if (l.injectTo) {\n      l.injectTo.forEach((i) => {\n        if (!this._injections.get(i))\n          this._injections.set(i, []);\n        this._injections.get(i).push(l.scopeName);\n      });\n    }\n  }\n  getInjections(scopeName) {\n    const scopeParts = scopeName.split(\".\");\n    let injections = [];\n    for (let i = 1; i <= scopeParts.length; i++) {\n      const subScopeName = scopeParts.slice(0, i).join(\".\");\n      injections = [...injections, ...this._injections.get(subScopeName) || []];\n    }\n    return injections;\n  }\n}\n\nlet instancesCount = 0;\nfunction createShikiInternalSync(options) {\n  instancesCount += 1;\n  if (options.warnings !== false && instancesCount >= 10 && instancesCount % 10 === 0)\n    console.warn(`[Shiki] ${instancesCount} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \\`highlighter.dispose()\\` to release unused instances.`);\n  let isDisposed = false;\n  if (!options.engine)\n    throw new ShikiError(\"`engine` option is required for synchronous mode\");\n  const langs = (options.langs || []).flat(1);\n  const themes = (options.themes || []).flat(1).map(normalizeTheme);\n  const resolver = new Resolver(options.engine, langs);\n  const _registry = new Registry(resolver, themes, langs, options.langAlias);\n  let _lastTheme;\n  function getLanguage(name) {\n    ensureNotDisposed();\n    const _lang = _registry.getGrammar(typeof name === \"string\" ? name : name.name);\n    if (!_lang)\n      throw new ShikiError(`Language \\`${name}\\` not found, you may need to load it first`);\n    return _lang;\n  }\n  function getTheme(name) {\n    if (name === \"none\")\n      return { bg: \"\", fg: \"\", name: \"none\", settings: [], type: \"dark\" };\n    ensureNotDisposed();\n    const _theme = _registry.getTheme(name);\n    if (!_theme)\n      throw new ShikiError(`Theme \\`${name}\\` not found, you may need to load it first`);\n    return _theme;\n  }\n  function setTheme(name) {\n    ensureNotDisposed();\n    const theme = getTheme(name);\n    if (_lastTheme !== name) {\n      _registry.setTheme(theme);\n      _lastTheme = name;\n    }\n    const colorMap = _registry.getColorMap();\n    return {\n      theme,\n      colorMap\n    };\n  }\n  function getLoadedThemes() {\n    ensureNotDisposed();\n    return _registry.getLoadedThemes();\n  }\n  function getLoadedLanguages() {\n    ensureNotDisposed();\n    return _registry.getLoadedLanguages();\n  }\n  function loadLanguageSync(...langs2) {\n    ensureNotDisposed();\n    _registry.loadLanguages(langs2.flat(1));\n  }\n  async function loadLanguage(...langs2) {\n    return loadLanguageSync(await resolveLangs(langs2));\n  }\n  function loadThemeSync(...themes2) {\n    ensureNotDisposed();\n    for (const theme of themes2.flat(1)) {\n      _registry.loadTheme(theme);\n    }\n  }\n  async function loadTheme(...themes2) {\n    ensureNotDisposed();\n    return loadThemeSync(await resolveThemes(themes2));\n  }\n  function ensureNotDisposed() {\n    if (isDisposed)\n      throw new ShikiError(\"Shiki instance has been disposed\");\n  }\n  function dispose() {\n    if (isDisposed)\n      return;\n    isDisposed = true;\n    _registry.dispose();\n    instancesCount -= 1;\n  }\n  return {\n    setTheme,\n    getTheme,\n    getLanguage,\n    getLoadedThemes,\n    getLoadedLanguages,\n    loadLanguage,\n    loadLanguageSync,\n    loadTheme,\n    loadThemeSync,\n    dispose,\n    [Symbol.dispose]: dispose\n  };\n}\n\nasync function createShikiInternal(options) {\n  if (!options.engine) {\n    warnDeprecated(\"`engine` option is required. Use `createOnigurumaEngine` or `createJavaScriptRegexEngine` to create an engine.\");\n  }\n  const [\n    themes,\n    langs,\n    engine\n  ] = await Promise.all([\n    resolveThemes(options.themes || []),\n    resolveLangs(options.langs || []),\n    options.engine\n  ]);\n  return createShikiInternalSync({\n    ...options,\n    themes,\n    langs,\n    engine\n  });\n}\n\nasync function createHighlighterCore(options) {\n  const internal = await createShikiInternal(options);\n  return {\n    getLastGrammarState: (...args) => getLastGrammarState(internal, ...args),\n    codeToTokensBase: (code, options2) => codeToTokensBase(internal, code, options2),\n    codeToTokensWithThemes: (code, options2) => codeToTokensWithThemes(internal, code, options2),\n    codeToTokens: (code, options2) => codeToTokens(internal, code, options2),\n    codeToHast: (code, options2) => codeToHast(internal, code, options2),\n    codeToHtml: (code, options2) => codeToHtml(internal, code, options2),\n    getBundledLanguages: () => ({}),\n    getBundledThemes: () => ({}),\n    ...internal,\n    getInternalContext: () => internal\n  };\n}\nfunction createHighlighterCoreSync(options) {\n  const internal = createShikiInternalSync(options);\n  return {\n    getLastGrammarState: (...args) => getLastGrammarState(internal, ...args),\n    codeToTokensBase: (code, options2) => codeToTokensBase(internal, code, options2),\n    codeToTokensWithThemes: (code, options2) => codeToTokensWithThemes(internal, code, options2),\n    codeToTokens: (code, options2) => codeToTokens(internal, code, options2),\n    codeToHast: (code, options2) => codeToHast(internal, code, options2),\n    codeToHtml: (code, options2) => codeToHtml(internal, code, options2),\n    getBundledLanguages: () => ({}),\n    getBundledThemes: () => ({}),\n    ...internal,\n    getInternalContext: () => internal\n  };\n}\nfunction makeSingletonHighlighterCore(createHighlighter) {\n  let _shiki;\n  async function getSingletonHighlighterCore2(options) {\n    if (!_shiki) {\n      _shiki = createHighlighter({\n        ...options,\n        themes: options.themes || [],\n        langs: options.langs || []\n      });\n      return _shiki;\n    } else {\n      const s = await _shiki;\n      await Promise.all([\n        s.loadTheme(...options.themes || []),\n        s.loadLanguage(...options.langs || [])\n      ]);\n      return s;\n    }\n  }\n  return getSingletonHighlighterCore2;\n}\nconst getSingletonHighlighterCore = /* @__PURE__ */ makeSingletonHighlighterCore(createHighlighterCore);\n\nfunction createdBundledHighlighter(options) {\n  const bundledLanguages = options.langs;\n  const bundledThemes = options.themes;\n  const engine = options.engine;\n  async function createHighlighter(options2) {\n    function resolveLang(lang) {\n      if (typeof lang === \"string\") {\n        if (isSpecialLang(lang))\n          return [];\n        lang = options2.langAlias?.[lang] || lang;\n        const bundle = bundledLanguages[lang];\n        if (!bundle)\n          throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Language \\`${lang}\\` is not included in this bundle. You may want to load it from external source.`);\n        return bundle;\n      }\n      return lang;\n    }\n    function resolveTheme(theme) {\n      if (isSpecialTheme(theme))\n        return \"none\";\n      if (typeof theme === \"string\") {\n        const bundle = bundledThemes[theme];\n        if (!bundle)\n          throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Theme \\`${theme}\\` is not included in this bundle. You may want to load it from external source.`);\n        return bundle;\n      }\n      return theme;\n    }\n    const _themes = (options2.themes ?? []).map((i) => resolveTheme(i));\n    const langs = (options2.langs ?? []).map((i) => resolveLang(i));\n    const core = await createHighlighterCore({\n      engine: options2.engine ?? engine(),\n      ...options2,\n      themes: _themes,\n      langs\n    });\n    return {\n      ...core,\n      loadLanguage(...langs2) {\n        return core.loadLanguage(...langs2.map(resolveLang));\n      },\n      loadTheme(...themes) {\n        return core.loadTheme(...themes.map(resolveTheme));\n      },\n      getBundledLanguages() {\n        return bundledLanguages;\n      },\n      getBundledThemes() {\n        return bundledThemes;\n      }\n    };\n  }\n  return createHighlighter;\n}\nfunction makeSingletonHighlighter(createHighlighter) {\n  let _shiki;\n  async function getSingletonHighlighter(options = {}) {\n    if (!_shiki) {\n      _shiki = createHighlighter({\n        ...options,\n        themes: options.themes || [],\n        langs: options.langs || []\n      });\n      return _shiki;\n    } else {\n      const s = await _shiki;\n      await Promise.all([\n        s.loadTheme(...options.themes || []),\n        s.loadLanguage(...options.langs || [])\n      ]);\n      return s;\n    }\n  }\n  return getSingletonHighlighter;\n}\nfunction createSingletonShorthands(createHighlighter, config) {\n  const getSingletonHighlighter = makeSingletonHighlighter(createHighlighter);\n  async function get(code, options) {\n    const shiki = await getSingletonHighlighter({\n      langs: [options.lang],\n      themes: \"theme\" in options ? [options.theme] : Object.values(options.themes)\n    });\n    const langs = await config?.guessEmbeddedLanguages?.(code, options.lang, shiki);\n    if (langs) {\n      await shiki.loadLanguage(...langs);\n    }\n    return shiki;\n  }\n  return {\n    getSingletonHighlighter(options) {\n      return getSingletonHighlighter(options);\n    },\n    async codeToHtml(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToHtml(code, options);\n    },\n    async codeToHast(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToHast(code, options);\n    },\n    async codeToTokens(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToTokens(code, options);\n    },\n    async codeToTokensBase(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToTokensBase(code, options);\n    },\n    async codeToTokensWithThemes(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToTokensWithThemes(code, options);\n    },\n    async getLastGrammarState(code, options) {\n      const shiki = await getSingletonHighlighter({\n        langs: [options.lang],\n        themes: [options.theme]\n      });\n      return shiki.getLastGrammarState(code, options);\n    }\n  };\n}\n\nfunction createCssVariablesTheme(options = {}) {\n  const {\n    name = \"css-variables\",\n    variablePrefix = \"--shiki-\",\n    fontStyle = true\n  } = options;\n  const variable = (name2) => {\n    if (options.variableDefaults?.[name2])\n      return `var(${variablePrefix}${name2}, ${options.variableDefaults[name2]})`;\n    return `var(${variablePrefix}${name2})`;\n  };\n  const theme = {\n    name,\n    type: \"dark\",\n    colors: {\n      \"editor.foreground\": variable(\"foreground\"),\n      \"editor.background\": variable(\"background\"),\n      \"terminal.ansiBlack\": variable(\"ansi-black\"),\n      \"terminal.ansiRed\": variable(\"ansi-red\"),\n      \"terminal.ansiGreen\": variable(\"ansi-green\"),\n      \"terminal.ansiYellow\": variable(\"ansi-yellow\"),\n      \"terminal.ansiBlue\": variable(\"ansi-blue\"),\n      \"terminal.ansiMagenta\": variable(\"ansi-magenta\"),\n      \"terminal.ansiCyan\": variable(\"ansi-cyan\"),\n      \"terminal.ansiWhite\": variable(\"ansi-white\"),\n      \"terminal.ansiBrightBlack\": variable(\"ansi-bright-black\"),\n      \"terminal.ansiBrightRed\": variable(\"ansi-bright-red\"),\n      \"terminal.ansiBrightGreen\": variable(\"ansi-bright-green\"),\n      \"terminal.ansiBrightYellow\": variable(\"ansi-bright-yellow\"),\n      \"terminal.ansiBrightBlue\": variable(\"ansi-bright-blue\"),\n      \"terminal.ansiBrightMagenta\": variable(\"ansi-bright-magenta\"),\n      \"terminal.ansiBrightCyan\": variable(\"ansi-bright-cyan\"),\n      \"terminal.ansiBrightWhite\": variable(\"ansi-bright-white\")\n    },\n    tokenColors: [\n      {\n        scope: [\n          \"keyword.operator.accessor\",\n          \"meta.group.braces.round.function.arguments\",\n          \"meta.template.expression\",\n          \"markup.fenced_code meta.embedded.block\"\n        ],\n        settings: {\n          foreground: variable(\"foreground\")\n        }\n      },\n      {\n        scope: \"emphasis\",\n        settings: {\n          fontStyle: \"italic\"\n        }\n      },\n      {\n        scope: [\"strong\", \"markup.heading.markdown\", \"markup.bold.markdown\"],\n        settings: {\n          fontStyle: \"bold\"\n        }\n      },\n      {\n        scope: [\"markup.italic.markdown\"],\n        settings: {\n          fontStyle: \"italic\"\n        }\n      },\n      {\n        scope: \"meta.link.inline.markdown\",\n        settings: {\n          fontStyle: \"underline\",\n          foreground: variable(\"token-link\")\n        }\n      },\n      {\n        scope: [\"string\", \"markup.fenced_code\", \"markup.inline\"],\n        settings: {\n          foreground: variable(\"token-string\")\n        }\n      },\n      {\n        scope: [\"comment\", \"string.quoted.docstring.multi\"],\n        settings: {\n          foreground: variable(\"token-comment\")\n        }\n      },\n      {\n        scope: [\n          \"constant.numeric\",\n          \"constant.language\",\n          \"constant.other.placeholder\",\n          \"constant.character.format.placeholder\",\n          \"variable.language.this\",\n          \"variable.other.object\",\n          \"variable.other.class\",\n          \"variable.other.constant\",\n          \"meta.property-name\",\n          \"meta.property-value\",\n          \"support\"\n        ],\n        settings: {\n          foreground: variable(\"token-constant\")\n        }\n      },\n      {\n        scope: [\n          \"keyword\",\n          \"storage.modifier\",\n          \"storage.type\",\n          \"storage.control.clojure\",\n          \"entity.name.function.clojure\",\n          \"entity.name.tag.yaml\",\n          \"support.function.node\",\n          \"support.type.property-name.json\",\n          \"punctuation.separator.key-value\",\n          \"punctuation.definition.template-expression\"\n        ],\n        settings: {\n          foreground: variable(\"token-keyword\")\n        }\n      },\n      {\n        scope: \"variable.parameter.function\",\n        settings: {\n          foreground: variable(\"token-parameter\")\n        }\n      },\n      {\n        scope: [\n          \"support.function\",\n          \"entity.name.type\",\n          \"entity.other.inherited-class\",\n          \"meta.function-call\",\n          \"meta.instance.constructor\",\n          \"entity.other.attribute-name\",\n          \"entity.name.function\",\n          \"constant.keyword.clojure\"\n        ],\n        settings: {\n          foreground: variable(\"token-function\")\n        }\n      },\n      {\n        scope: [\n          \"entity.name.tag\",\n          \"string.quoted\",\n          \"string.regexp\",\n          \"string.interpolated\",\n          \"string.template\",\n          \"string.unquoted.plain.out.yaml\",\n          \"keyword.other.template\"\n        ],\n        settings: {\n          foreground: variable(\"token-string-expression\")\n        }\n      },\n      {\n        scope: [\n          \"punctuation.definition.arguments\",\n          \"punctuation.definition.dict\",\n          \"punctuation.separator\",\n          \"meta.function-call.arguments\"\n        ],\n        settings: {\n          foreground: variable(\"token-punctuation\")\n        }\n      },\n      {\n        // [Custom] Markdown links\n        scope: [\n          \"markup.underline.link\",\n          \"punctuation.definition.metadata.markdown\"\n        ],\n        settings: {\n          foreground: variable(\"token-link\")\n        }\n      },\n      {\n        // [Custom] Markdown list\n        scope: [\"beginning.punctuation.definition.list.markdown\"],\n        settings: {\n          foreground: variable(\"token-string\")\n        }\n      },\n      {\n        // [Custom] Markdown punctuation definition brackets\n        scope: [\n          \"punctuation.definition.string.begin.markdown\",\n          \"punctuation.definition.string.end.markdown\",\n          \"string.other.link.title.markdown\",\n          \"string.other.link.description.markdown\"\n        ],\n        settings: {\n          foreground: variable(\"token-keyword\")\n        }\n      },\n      {\n        // [Custom] Diff\n        scope: [\n          \"markup.inserted\",\n          \"meta.diff.header.to-file\",\n          \"punctuation.definition.inserted\"\n        ],\n        settings: {\n          foreground: variable(\"token-inserted\")\n        }\n      },\n      {\n        scope: [\n          \"markup.deleted\",\n          \"meta.diff.header.from-file\",\n          \"punctuation.definition.deleted\"\n        ],\n        settings: {\n          foreground: variable(\"token-deleted\")\n        }\n      },\n      {\n        scope: [\n          \"markup.changed\",\n          \"punctuation.definition.changed\"\n        ],\n        settings: {\n          foreground: variable(\"token-changed\")\n        }\n      }\n    ]\n  };\n  if (!fontStyle) {\n    theme.tokenColors = theme.tokenColors?.map((tokenColor) => {\n      if (tokenColor.settings?.fontStyle)\n        delete tokenColor.settings.fontStyle;\n      return tokenColor;\n    });\n  }\n  return theme;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaGlraWpzK2NvcmVAMy4xMy4wL25vZGVfbW9kdWxlcy9Ac2hpa2lqcy9jb3JlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTREO0FBQzdCO0FBQ29GO0FBQ3hFOztBQUUzQztBQUNBLHNEQUFzRCxJQUFJO0FBQzFEO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRTZ4QiIsInNvdXJjZXMiOlsiL1VzZXJzL3VhbmVsYV9jb21vL0RvY3VtZW50cy9kZXZlbG9wbWVudC9ub2RlanMvYXJrb3Mvbm9kZV9tb2R1bGVzLy5wbnBtL0BzaGlraWpzK2NvcmVAMy4xMy4wL25vZGVfbW9kdWxlcy9Ac2hpa2lqcy9jb3JlL2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNoaWtpRXJyb3IgYXMgU2hpa2lFcnJvciQxIH0gZnJvbSAnQHNoaWtpanMvdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnQHNoaWtpanMvdHlwZXMnO1xuaW1wb3J0IHsgRm9udFN0eWxlLCBJTklUSUFMLCBFbmNvZGVkVG9rZW5NZXRhZGF0YSwgUmVnaXN0cnkgYXMgUmVnaXN0cnkkMSwgVGhlbWUgfSBmcm9tICdAc2hpa2lqcy92c2NvZGUtdGV4dG1hdGUnO1xuaW1wb3J0IHsgdG9IdG1sIH0gZnJvbSAnaGFzdC11dGlsLXRvLWh0bWwnO1xuXG5mdW5jdGlvbiByZXNvbHZlQ29sb3JSZXBsYWNlbWVudHModGhlbWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVwbGFjZW1lbnRzID0gdHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiID8ge30gOiB7IC4uLnRoZW1lLmNvbG9yUmVwbGFjZW1lbnRzIH07XG4gIGNvbnN0IHRoZW1lTmFtZSA9IHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIiA/IHRoZW1lIDogdGhlbWUubmFtZTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucz8uY29sb3JSZXBsYWNlbWVudHMgfHwge30pKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJlcGxhY2VtZW50c1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBpZiAoa2V5ID09PSB0aGVtZU5hbWUpXG4gICAgICBPYmplY3QuYXNzaWduKHJlcGxhY2VtZW50cywgdmFsdWUpO1xuICB9XG4gIHJldHVybiByZXBsYWNlbWVudHM7XG59XG5mdW5jdGlvbiBhcHBseUNvbG9yUmVwbGFjZW1lbnRzKGNvbG9yLCByZXBsYWNlbWVudHMpIHtcbiAgaWYgKCFjb2xvcilcbiAgICByZXR1cm4gY29sb3I7XG4gIHJldHVybiByZXBsYWNlbWVudHM/Lltjb2xvcj8udG9Mb3dlckNhc2UoKV0gfHwgY29sb3I7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkoeCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh4KSA/IHggOiBbeF07XG59XG5hc3luYyBmdW5jdGlvbiBub3JtYWxpemVHZXR0ZXIocCkge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIgPyBwKCkgOiBwKS50aGVuKChyKSA9PiByLmRlZmF1bHQgfHwgcik7XG59XG5mdW5jdGlvbiBpc1BsYWluTGFuZyhsYW5nKSB7XG4gIHJldHVybiAhbGFuZyB8fCBbXCJwbGFpbnRleHRcIiwgXCJ0eHRcIiwgXCJ0ZXh0XCIsIFwicGxhaW5cIl0uaW5jbHVkZXMobGFuZyk7XG59XG5mdW5jdGlvbiBpc1NwZWNpYWxMYW5nKGxhbmcpIHtcbiAgcmV0dXJuIGxhbmcgPT09IFwiYW5zaVwiIHx8IGlzUGxhaW5MYW5nKGxhbmcpO1xufVxuZnVuY3Rpb24gaXNOb25lVGhlbWUodGhlbWUpIHtcbiAgcmV0dXJuIHRoZW1lID09PSBcIm5vbmVcIjtcbn1cbmZ1bmN0aW9uIGlzU3BlY2lhbFRoZW1lKHRoZW1lKSB7XG4gIHJldHVybiBpc05vbmVUaGVtZSh0aGVtZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENsYXNzVG9IYXN0KG5vZGUsIGNsYXNzTmFtZSkge1xuICBpZiAoIWNsYXNzTmFtZSlcbiAgICByZXR1cm4gbm9kZTtcbiAgbm9kZS5wcm9wZXJ0aWVzIHx8PSB7fTtcbiAgbm9kZS5wcm9wZXJ0aWVzLmNsYXNzIHx8PSBbXTtcbiAgaWYgKHR5cGVvZiBub2RlLnByb3BlcnRpZXMuY2xhc3MgPT09IFwic3RyaW5nXCIpXG4gICAgbm9kZS5wcm9wZXJ0aWVzLmNsYXNzID0gbm9kZS5wcm9wZXJ0aWVzLmNsYXNzLnNwbGl0KC9cXHMrL2cpO1xuICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZS5wcm9wZXJ0aWVzLmNsYXNzKSlcbiAgICBub2RlLnByb3BlcnRpZXMuY2xhc3MgPSBbXTtcbiAgY29uc3QgdGFyZ2V0cyA9IEFycmF5LmlzQXJyYXkoY2xhc3NOYW1lKSA/IGNsYXNzTmFtZSA6IGNsYXNzTmFtZS5zcGxpdCgvXFxzKy9nKTtcbiAgZm9yIChjb25zdCBjIG9mIHRhcmdldHMpIHtcbiAgICBpZiAoYyAmJiAhbm9kZS5wcm9wZXJ0aWVzLmNsYXNzLmluY2x1ZGVzKGMpKVxuICAgICAgbm9kZS5wcm9wZXJ0aWVzLmNsYXNzLnB1c2goYyk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIHNwbGl0TGluZXMoY29kZSwgcHJlc2VydmVFbmRpbmcgPSBmYWxzZSkge1xuICBjb25zdCBwYXJ0cyA9IGNvZGUuc3BsaXQoLyhcXHI/XFxuKS9nKTtcbiAgbGV0IGluZGV4ID0gMDtcbiAgY29uc3QgbGluZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGNvbnN0IGxpbmUgPSBwcmVzZXJ2ZUVuZGluZyA/IHBhcnRzW2ldICsgKHBhcnRzW2kgKyAxXSB8fCBcIlwiKSA6IHBhcnRzW2ldO1xuICAgIGxpbmVzLnB1c2goW2xpbmUsIGluZGV4XSk7XG4gICAgaW5kZXggKz0gcGFydHNbaV0ubGVuZ3RoO1xuICAgIGluZGV4ICs9IHBhcnRzW2kgKyAxXT8ubGVuZ3RoIHx8IDA7XG4gIH1cbiAgcmV0dXJuIGxpbmVzO1xufVxuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25Db252ZXJ0ZXIoY29kZSkge1xuICBjb25zdCBsaW5lcyA9IHNwbGl0TGluZXMoY29kZSwgdHJ1ZSkubWFwKChbbGluZV0pID0+IGxpbmUpO1xuICBmdW5jdGlvbiBpbmRleFRvUG9zKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSBjb2RlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbGluZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgY2hhcmFjdGVyOiBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGhcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBjaGFyYWN0ZXIgPSBpbmRleDtcbiAgICBsZXQgbGluZSA9IDA7XG4gICAgZm9yIChjb25zdCBsaW5lVGV4dCBvZiBsaW5lcykge1xuICAgICAgaWYgKGNoYXJhY3RlciA8IGxpbmVUZXh0Lmxlbmd0aClcbiAgICAgICAgYnJlYWs7XG4gICAgICBjaGFyYWN0ZXIgLT0gbGluZVRleHQubGVuZ3RoO1xuICAgICAgbGluZSsrO1xuICAgIH1cbiAgICByZXR1cm4geyBsaW5lLCBjaGFyYWN0ZXIgfTtcbiAgfVxuICBmdW5jdGlvbiBwb3NUb0luZGV4KGxpbmUsIGNoYXJhY3Rlcikge1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspXG4gICAgICBpbmRleCArPSBsaW5lc1tpXS5sZW5ndGg7XG4gICAgaW5kZXggKz0gY2hhcmFjdGVyO1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGxpbmVzLFxuICAgIGluZGV4VG9Qb3MsXG4gICAgcG9zVG9JbmRleFxuICB9O1xufVxuZnVuY3Rpb24gZ3Vlc3NFbWJlZGRlZExhbmd1YWdlcyhjb2RlLCBfbGFuZywgaGlnaGxpZ2h0ZXIpIHtcbiAgY29uc3QgbGFuZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IG1hdGNoIG9mIGNvZGUubWF0Y2hBbGwoL2xhbmc9W1wiJ10oW1xcdy1dKylbXCInXS9nKSkge1xuICAgIGxhbmdzLmFkZChtYXRjaFsxXSk7XG4gIH1cbiAgZm9yIChjb25zdCBtYXRjaCBvZiBjb2RlLm1hdGNoQWxsKC8oPzpgYGB8fn5+KShbXFx3LV0rKS9nKSkge1xuICAgIGxhbmdzLmFkZChtYXRjaFsxXSk7XG4gIH1cbiAgZm9yIChjb25zdCBtYXRjaCBvZiBjb2RlLm1hdGNoQWxsKC9cXFxcYmVnaW5cXHsoW1xcdy1dKylcXH0vZykpIHtcbiAgICBsYW5ncy5hZGQobWF0Y2hbMV0pO1xuICB9XG4gIGlmICghaGlnaGxpZ2h0ZXIpXG4gICAgcmV0dXJuIEFycmF5LmZyb20obGFuZ3MpO1xuICBjb25zdCBidW5kbGUgPSBoaWdobGlnaHRlci5nZXRCdW5kbGVkTGFuZ3VhZ2VzKCk7XG4gIHJldHVybiBBcnJheS5mcm9tKGxhbmdzKS5maWx0ZXIoKGwpID0+IGwgJiYgYnVuZGxlW2xdKTtcbn1cblxuY29uc3QgREVGQVVMVF9DT0xPUl9MSUdIVF9EQVJLID0gXCJsaWdodC1kYXJrKClcIjtcbmNvbnN0IENPTE9SX0tFWVMgPSBbXCJjb2xvclwiLCBcImJhY2tncm91bmQtY29sb3JcIl07XG5cbmZ1bmN0aW9uIHNwbGl0VG9rZW4odG9rZW4sIG9mZnNldHMpIHtcbiAgbGV0IGxhc3RPZmZzZXQgPSAwO1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgZm9yIChjb25zdCBvZmZzZXQgb2Ygb2Zmc2V0cykge1xuICAgIGlmIChvZmZzZXQgPiBsYXN0T2Zmc2V0KSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIC4uLnRva2VuLFxuICAgICAgICBjb250ZW50OiB0b2tlbi5jb250ZW50LnNsaWNlKGxhc3RPZmZzZXQsIG9mZnNldCksXG4gICAgICAgIG9mZnNldDogdG9rZW4ub2Zmc2V0ICsgbGFzdE9mZnNldFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gIH1cbiAgaWYgKGxhc3RPZmZzZXQgPCB0b2tlbi5jb250ZW50Lmxlbmd0aCkge1xuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIC4uLnRva2VuLFxuICAgICAgY29udGVudDogdG9rZW4uY29udGVudC5zbGljZShsYXN0T2Zmc2V0KSxcbiAgICAgIG9mZnNldDogdG9rZW4ub2Zmc2V0ICsgbGFzdE9mZnNldFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0b2tlbnM7XG59XG5mdW5jdGlvbiBzcGxpdFRva2Vucyh0b2tlbnMsIGJyZWFrcG9pbnRzKSB7XG4gIGNvbnN0IHNvcnRlZCA9IEFycmF5LmZyb20oYnJlYWtwb2ludHMgaW5zdGFuY2VvZiBTZXQgPyBicmVha3BvaW50cyA6IG5ldyBTZXQoYnJlYWtwb2ludHMpKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIGlmICghc29ydGVkLmxlbmd0aClcbiAgICByZXR1cm4gdG9rZW5zO1xuICByZXR1cm4gdG9rZW5zLm1hcCgobGluZSkgPT4ge1xuICAgIHJldHVybiBsaW5lLmZsYXRNYXAoKHRva2VuKSA9PiB7XG4gICAgICBjb25zdCBicmVha3BvaW50c0luVG9rZW4gPSBzb3J0ZWQuZmlsdGVyKChpKSA9PiB0b2tlbi5vZmZzZXQgPCBpICYmIGkgPCB0b2tlbi5vZmZzZXQgKyB0b2tlbi5jb250ZW50Lmxlbmd0aCkubWFwKChpKSA9PiBpIC0gdG9rZW4ub2Zmc2V0KS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICBpZiAoIWJyZWFrcG9pbnRzSW5Ub2tlbi5sZW5ndGgpXG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIHJldHVybiBzcGxpdFRva2VuKHRva2VuLCBicmVha3BvaW50c0luVG9rZW4pO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGZsYXRUb2tlblZhcmlhbnRzKG1lcmdlZCwgdmFyaWFudHNPcmRlciwgY3NzVmFyaWFibGVQcmVmaXgsIGRlZmF1bHRDb2xvciwgY29sb3JzUmVuZGVyaW5nID0gXCJjc3MtdmFyc1wiKSB7XG4gIGNvbnN0IHRva2VuID0ge1xuICAgIGNvbnRlbnQ6IG1lcmdlZC5jb250ZW50LFxuICAgIGV4cGxhbmF0aW9uOiBtZXJnZWQuZXhwbGFuYXRpb24sXG4gICAgb2Zmc2V0OiBtZXJnZWQub2Zmc2V0XG4gIH07XG4gIGNvbnN0IHN0eWxlcyA9IHZhcmlhbnRzT3JkZXIubWFwKCh0KSA9PiBnZXRUb2tlblN0eWxlT2JqZWN0KG1lcmdlZC52YXJpYW50c1t0XSkpO1xuICBjb25zdCBzdHlsZUtleXMgPSBuZXcgU2V0KHN0eWxlcy5mbGF0TWFwKCh0KSA9PiBPYmplY3Qua2V5cyh0KSkpO1xuICBjb25zdCBtZXJnZWRTdHlsZXMgPSB7fTtcbiAgY29uc3QgdmFyS2V5ID0gKGlkeCwga2V5KSA9PiB7XG4gICAgY29uc3Qga2V5TmFtZSA9IGtleSA9PT0gXCJjb2xvclwiID8gXCJcIiA6IGtleSA9PT0gXCJiYWNrZ3JvdW5kLWNvbG9yXCIgPyBcIi1iZ1wiIDogYC0ke2tleX1gO1xuICAgIHJldHVybiBjc3NWYXJpYWJsZVByZWZpeCArIHZhcmlhbnRzT3JkZXJbaWR4XSArIChrZXkgPT09IFwiY29sb3JcIiA/IFwiXCIgOiBrZXlOYW1lKTtcbiAgfTtcbiAgc3R5bGVzLmZvckVhY2goKGN1ciwgaWR4KSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygc3R5bGVLZXlzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGN1cltrZXldIHx8IFwiaW5oZXJpdFwiO1xuICAgICAgaWYgKGlkeCA9PT0gMCAmJiBkZWZhdWx0Q29sb3IgJiYgQ09MT1JfS0VZUy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q29sb3IgPT09IERFRkFVTFRfQ09MT1JfTElHSFRfREFSSyAmJiBzdHlsZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGNvbnN0IGxpZ2h0SW5kZXggPSB2YXJpYW50c09yZGVyLmZpbmRJbmRleCgodCkgPT4gdCA9PT0gXCJsaWdodFwiKTtcbiAgICAgICAgICBjb25zdCBkYXJrSW5kZXggPSB2YXJpYW50c09yZGVyLmZpbmRJbmRleCgodCkgPT4gdCA9PT0gXCJkYXJrXCIpO1xuICAgICAgICAgIGlmIChsaWdodEluZGV4ID09PSAtMSB8fCBkYXJrSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMSgnV2hlbiB1c2luZyBgZGVmYXVsdENvbG9yOiBcImxpZ2h0LWRhcmsoKVwiYCwgeW91IG11c3QgcHJvdmlkZSBib3RoIGBsaWdodGAgYW5kIGBkYXJrYCB0aGVtZXMnKTtcbiAgICAgICAgICBjb25zdCBsaWdodFZhbHVlID0gc3R5bGVzW2xpZ2h0SW5kZXhdW2tleV0gfHwgXCJpbmhlcml0XCI7XG4gICAgICAgICAgY29uc3QgZGFya1ZhbHVlID0gc3R5bGVzW2RhcmtJbmRleF1ba2V5XSB8fCBcImluaGVyaXRcIjtcbiAgICAgICAgICBtZXJnZWRTdHlsZXNba2V5XSA9IGBsaWdodC1kYXJrKCR7bGlnaHRWYWx1ZX0sICR7ZGFya1ZhbHVlfSlgO1xuICAgICAgICAgIGlmIChjb2xvcnNSZW5kZXJpbmcgPT09IFwiY3NzLXZhcnNcIilcbiAgICAgICAgICAgIG1lcmdlZFN0eWxlc1t2YXJLZXkoaWR4LCBrZXkpXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lcmdlZFN0eWxlc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjb2xvcnNSZW5kZXJpbmcgPT09IFwiY3NzLXZhcnNcIilcbiAgICAgICAgICBtZXJnZWRTdHlsZXNbdmFyS2V5KGlkeCwga2V5KV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB0b2tlbi5odG1sU3R5bGUgPSBtZXJnZWRTdHlsZXM7XG4gIHJldHVybiB0b2tlbjtcbn1cbmZ1bmN0aW9uIGdldFRva2VuU3R5bGVPYmplY3QodG9rZW4pIHtcbiAgY29uc3Qgc3R5bGVzID0ge307XG4gIGlmICh0b2tlbi5jb2xvcilcbiAgICBzdHlsZXMuY29sb3IgPSB0b2tlbi5jb2xvcjtcbiAgaWYgKHRva2VuLmJnQ29sb3IpXG4gICAgc3R5bGVzW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9IHRva2VuLmJnQ29sb3I7XG4gIGlmICh0b2tlbi5mb250U3R5bGUpIHtcbiAgICBpZiAodG9rZW4uZm9udFN0eWxlICYgRm9udFN0eWxlLkl0YWxpYylcbiAgICAgIHN0eWxlc1tcImZvbnQtc3R5bGVcIl0gPSBcIml0YWxpY1wiO1xuICAgIGlmICh0b2tlbi5mb250U3R5bGUgJiBGb250U3R5bGUuQm9sZClcbiAgICAgIHN0eWxlc1tcImZvbnQtd2VpZ2h0XCJdID0gXCJib2xkXCI7XG4gICAgY29uc3QgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICBpZiAodG9rZW4uZm9udFN0eWxlICYgRm9udFN0eWxlLlVuZGVybGluZSlcbiAgICAgIGRlY29yYXRpb25zLnB1c2goXCJ1bmRlcmxpbmVcIik7XG4gICAgaWYgKHRva2VuLmZvbnRTdHlsZSAmIEZvbnRTdHlsZS5TdHJpa2V0aHJvdWdoKVxuICAgICAgZGVjb3JhdGlvbnMucHVzaChcImxpbmUtdGhyb3VnaFwiKTtcbiAgICBpZiAoZGVjb3JhdGlvbnMubGVuZ3RoKVxuICAgICAgc3R5bGVzW1widGV4dC1kZWNvcmF0aW9uXCJdID0gZGVjb3JhdGlvbnMuam9pbihcIiBcIik7XG4gIH1cbiAgcmV0dXJuIHN0eWxlcztcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVRva2VuU3R5bGUodG9rZW4pIHtcbiAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gdG9rZW47XG4gIHJldHVybiBPYmplY3QuZW50cmllcyh0b2tlbikubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke2tleX06JHt2YWx1ZX1gKS5qb2luKFwiO1wiKTtcbn1cblxuY29uc3QgX2dyYW1tYXJTdGF0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc2V0TGFzdEdyYW1tYXJTdGF0ZVRvTWFwKGtleXMsIHN0YXRlKSB7XG4gIF9ncmFtbWFyU3RhdGVNYXAuc2V0KGtleXMsIHN0YXRlKTtcbn1cbmZ1bmN0aW9uIGdldExhc3RHcmFtbWFyU3RhdGVGcm9tTWFwKGtleXMpIHtcbiAgcmV0dXJuIF9ncmFtbWFyU3RhdGVNYXAuZ2V0KGtleXMpO1xufVxuY2xhc3MgR3JhbW1hclN0YXRlIHtcbiAgLyoqXG4gICAqIFRoZW1lIHRvIFN0YWNrIG1hcHBpbmdcbiAgICovXG4gIF9zdGFja3MgPSB7fTtcbiAgbGFuZztcbiAgZ2V0IHRoZW1lcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc3RhY2tzKTtcbiAgfVxuICBnZXQgdGhlbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbWVzWzBdO1xuICB9XG4gIGdldCBfc3RhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrc1t0aGlzLnRoZW1lXTtcbiAgfVxuICAvKipcbiAgICogU3RhdGljIG1ldGhvZCB0byBjcmVhdGUgYSBpbml0aWFsIGdyYW1tYXIgc3RhdGUuXG4gICAqL1xuICBzdGF0aWMgaW5pdGlhbChsYW5nLCB0aGVtZXMpIHtcbiAgICByZXR1cm4gbmV3IEdyYW1tYXJTdGF0ZShcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyh0b0FycmF5KHRoZW1lcykubWFwKCh0aGVtZSkgPT4gW3RoZW1lLCBJTklUSUFMXSkpLFxuICAgICAgbGFuZ1xuICAgICk7XG4gIH1cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgW3N0YWNrc01hcCwgbGFuZ10gPSBhcmdzO1xuICAgICAgdGhpcy5sYW5nID0gbGFuZztcbiAgICAgIHRoaXMuX3N0YWNrcyA9IHN0YWNrc01hcDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW3N0YWNrLCBsYW5nLCB0aGVtZV0gPSBhcmdzO1xuICAgICAgdGhpcy5sYW5nID0gbGFuZztcbiAgICAgIHRoaXMuX3N0YWNrcyA9IHsgW3RoZW1lXTogc3RhY2sgfTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgaW50ZXJuYWwgc3RhY2sgb2JqZWN0LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldEludGVybmFsU3RhY2sodGhlbWUgPSB0aGlzLnRoZW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrc1t0aGVtZV07XG4gIH1cbiAgZ2V0U2NvcGVzKHRoZW1lID0gdGhpcy50aGVtZSkge1xuICAgIHJldHVybiBnZXRTY29wZXModGhpcy5fc3RhY2tzW3RoZW1lXSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsYW5nOiB0aGlzLmxhbmcsXG4gICAgICB0aGVtZTogdGhpcy50aGVtZSxcbiAgICAgIHRoZW1lczogdGhpcy50aGVtZXMsXG4gICAgICBzY29wZXM6IHRoaXMuZ2V0U2NvcGVzKClcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRTY29wZXMoc3RhY2spIHtcbiAgY29uc3Qgc2NvcGVzID0gW107XG4gIGNvbnN0IHZpc2l0ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmdW5jdGlvbiBwdXNoU2NvcGUoc3RhY2syKSB7XG4gICAgaWYgKHZpc2l0ZWQuaGFzKHN0YWNrMikpXG4gICAgICByZXR1cm47XG4gICAgdmlzaXRlZC5hZGQoc3RhY2syKTtcbiAgICBjb25zdCBuYW1lID0gc3RhY2syPy5uYW1lU2NvcGVzTGlzdD8uc2NvcGVOYW1lO1xuICAgIGlmIChuYW1lKVxuICAgICAgc2NvcGVzLnB1c2gobmFtZSk7XG4gICAgaWYgKHN0YWNrMi5wYXJlbnQpXG4gICAgICBwdXNoU2NvcGUoc3RhY2syLnBhcmVudCk7XG4gIH1cbiAgcHVzaFNjb3BlKHN0YWNrKTtcbiAgcmV0dXJuIHNjb3Blcztcbn1cbmZ1bmN0aW9uIGdldEdyYW1tYXJTdGFjayhzdGF0ZSwgdGhlbWUpIHtcbiAgaWYgKCEoc3RhdGUgaW5zdGFuY2VvZiBHcmFtbWFyU3RhdGUpKVxuICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoXCJJbnZhbGlkIGdyYW1tYXIgc3RhdGVcIik7XG4gIHJldHVybiBzdGF0ZS5nZXRJbnRlcm5hbFN0YWNrKHRoZW1lKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtZXJEZWNvcmF0aW9ucygpIHtcbiAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGZ1bmN0aW9uIGdldENvbnRleHQoc2hpa2kpIHtcbiAgICBpZiAoIW1hcC5oYXMoc2hpa2kubWV0YSkpIHtcbiAgICAgIGxldCBub3JtYWxpemVQb3NpdGlvbiA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgaWYgKHAgPCAwIHx8IHAgPiBzaGlraS5zb3VyY2UubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgSW52YWxpZCBkZWNvcmF0aW9uIG9mZnNldDogJHtwfS4gQ29kZSBsZW5ndGg6ICR7c2hpa2kuc291cmNlLmxlbmd0aH1gKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29udmVydGVyLmluZGV4VG9Qb3MocCksXG4gICAgICAgICAgICBvZmZzZXQ6IHBcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGxpbmUgPSBjb252ZXJ0ZXIubGluZXNbcC5saW5lXTtcbiAgICAgICAgICBpZiAobGluZSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgSW52YWxpZCBkZWNvcmF0aW9uIHBvc2l0aW9uICR7SlNPTi5zdHJpbmdpZnkocCl9LiBMaW5lcyBsZW5ndGg6ICR7Y29udmVydGVyLmxpbmVzLmxlbmd0aH1gKTtcbiAgICAgICAgICBsZXQgY2hhcmFjdGVyID0gcC5jaGFyYWN0ZXI7XG4gICAgICAgICAgaWYgKGNoYXJhY3RlciA8IDApXG4gICAgICAgICAgICBjaGFyYWN0ZXIgPSBsaW5lLmxlbmd0aCArIGNoYXJhY3RlcjtcbiAgICAgICAgICBpZiAoY2hhcmFjdGVyIDwgMCB8fCBjaGFyYWN0ZXIgPiBsaW5lLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoYEludmFsaWQgZGVjb3JhdGlvbiBwb3NpdGlvbiAke0pTT04uc3RyaW5naWZ5KHApfS4gTGluZSAke3AubGluZX0gbGVuZ3RoOiAke2xpbmUubGVuZ3RofWApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgY2hhcmFjdGVyLFxuICAgICAgICAgICAgb2Zmc2V0OiBjb252ZXJ0ZXIucG9zVG9JbmRleChwLmxpbmUsIGNoYXJhY3RlcilcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29udmVydGVyID0gY3JlYXRlUG9zaXRpb25Db252ZXJ0ZXIoc2hpa2kuc291cmNlKTtcbiAgICAgIGNvbnN0IGRlY29yYXRpb25zID0gKHNoaWtpLm9wdGlvbnMuZGVjb3JhdGlvbnMgfHwgW10pLm1hcCgoZCkgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgc3RhcnQ6IG5vcm1hbGl6ZVBvc2l0aW9uKGQuc3RhcnQpLFxuICAgICAgICBlbmQ6IG5vcm1hbGl6ZVBvc2l0aW9uKGQuZW5kKVxuICAgICAgfSkpO1xuICAgICAgdmVyaWZ5SW50ZXJzZWN0aW9ucyhkZWNvcmF0aW9ucyk7XG4gICAgICBtYXAuc2V0KHNoaWtpLm1ldGEsIHtcbiAgICAgICAgZGVjb3JhdGlvbnMsXG4gICAgICAgIGNvbnZlcnRlcixcbiAgICAgICAgc291cmNlOiBzaGlraS5zb3VyY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFwLmdldChzaGlraS5tZXRhKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6IFwic2hpa2k6ZGVjb3JhdGlvbnNcIixcbiAgICB0b2tlbnModG9rZW5zKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5kZWNvcmF0aW9ucz8ubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBjdHggPSBnZXRDb250ZXh0KHRoaXMpO1xuICAgICAgY29uc3QgYnJlYWtwb2ludHMgPSBjdHguZGVjb3JhdGlvbnMuZmxhdE1hcCgoZCkgPT4gW2Quc3RhcnQub2Zmc2V0LCBkLmVuZC5vZmZzZXRdKTtcbiAgICAgIGNvbnN0IHNwbGl0dGVkID0gc3BsaXRUb2tlbnModG9rZW5zLCBicmVha3BvaW50cyk7XG4gICAgICByZXR1cm4gc3BsaXR0ZWQ7XG4gICAgfSxcbiAgICBjb2RlKGNvZGVFbCkge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGVjb3JhdGlvbnM/Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgY3R4ID0gZ2V0Q29udGV4dCh0aGlzKTtcbiAgICAgIGNvbnN0IGxpbmVzID0gQXJyYXkuZnJvbShjb2RlRWwuY2hpbGRyZW4pLmZpbHRlcigoaSkgPT4gaS50eXBlID09PSBcImVsZW1lbnRcIiAmJiBpLnRhZ05hbWUgPT09IFwic3BhblwiKTtcbiAgICAgIGlmIChsaW5lcy5sZW5ndGggIT09IGN0eC5jb252ZXJ0ZXIubGluZXMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBOdW1iZXIgb2YgbGluZXMgaW4gY29kZSBlbGVtZW50ICgke2xpbmVzLmxlbmd0aH0pIGRvZXMgbm90IG1hdGNoIHRoZSBudW1iZXIgb2YgbGluZXMgaW4gdGhlIHNvdXJjZSAoJHtjdHguY29udmVydGVyLmxpbmVzLmxlbmd0aH0pLiBGYWlsZWQgdG8gYXBwbHkgZGVjb3JhdGlvbnMuYCk7XG4gICAgICBmdW5jdGlvbiBhcHBseUxpbmVTZWN0aW9uKGxpbmUsIHN0YXJ0LCBlbmQsIGRlY29yYXRpb24pIHtcbiAgICAgICAgY29uc3QgbGluZUVsID0gbGluZXNbbGluZV07XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSAtMTtcbiAgICAgICAgbGV0IGVuZEluZGV4ID0gLTE7XG4gICAgICAgIGlmIChzdGFydCA9PT0gMClcbiAgICAgICAgICBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgaWYgKGVuZCA9PT0gMClcbiAgICAgICAgICBlbmRJbmRleCA9IDA7XG4gICAgICAgIGlmIChlbmQgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICAgICAgICBlbmRJbmRleCA9IGxpbmVFbC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09PSAtMSB8fCBlbmRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVFbC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGV4dCArPSBzdHJpbmdpZnkobGluZUVsLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID09PSAtMSAmJiB0ZXh0Lmxlbmd0aCA9PT0gc3RhcnQpXG4gICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIGlmIChlbmRJbmRleCA9PT0gLTEgJiYgdGV4dC5sZW5ndGggPT09IGVuZClcbiAgICAgICAgICAgICAgZW5kSW5kZXggPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IC0xKVxuICAgICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoYEZhaWxlZCB0byBmaW5kIHN0YXJ0IGluZGV4IGZvciBkZWNvcmF0aW9uICR7SlNPTi5zdHJpbmdpZnkoZGVjb3JhdGlvbi5zdGFydCl9YCk7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PT0gLTEpXG4gICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgRmFpbGVkIHRvIGZpbmQgZW5kIGluZGV4IGZvciBkZWNvcmF0aW9uICR7SlNPTi5zdHJpbmdpZnkoZGVjb3JhdGlvbi5lbmQpfWApO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGxpbmVFbC5jaGlsZHJlbi5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgICAgIGlmICghZGVjb3JhdGlvbi5hbHdheXNXcmFwICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gbGluZUVsLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIGFwcGx5RGVjb3JhdGlvbihsaW5lRWwsIGRlY29yYXRpb24sIFwibGluZVwiKTtcbiAgICAgICAgfSBlbHNlIGlmICghZGVjb3JhdGlvbi5hbHdheXNXcmFwICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXS50eXBlID09PSBcImVsZW1lbnRcIikge1xuICAgICAgICAgIGFwcGx5RGVjb3JhdGlvbihjaGlsZHJlblswXSwgZGVjb3JhdGlvbiwgXCJ0b2tlblwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB3cmFwcGVyID0ge1xuICAgICAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgICAgICB0YWdOYW1lOiBcInNwYW5cIixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICB9O1xuICAgICAgICAgIGFwcGx5RGVjb3JhdGlvbih3cmFwcGVyLCBkZWNvcmF0aW9uLCBcIndyYXBwZXJcIik7XG4gICAgICAgICAgbGluZUVsLmNoaWxkcmVuLnNwbGljZShzdGFydEluZGV4LCBjaGlsZHJlbi5sZW5ndGgsIHdyYXBwZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcHBseUxpbmUobGluZSwgZGVjb3JhdGlvbikge1xuICAgICAgICBsaW5lc1tsaW5lXSA9IGFwcGx5RGVjb3JhdGlvbihsaW5lc1tsaW5lXSwgZGVjb3JhdGlvbiwgXCJsaW5lXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXBwbHlEZWNvcmF0aW9uKGVsLCBkZWNvcmF0aW9uLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkZWNvcmF0aW9uLnByb3BlcnRpZXMgfHwge307XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGRlY29yYXRpb24udHJhbnNmb3JtIHx8ICgoaSkgPT4gaSk7XG4gICAgICAgIGVsLnRhZ05hbWUgPSBkZWNvcmF0aW9uLnRhZ05hbWUgfHwgXCJzcGFuXCI7XG4gICAgICAgIGVsLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgLi4uZWwucHJvcGVydGllcyxcbiAgICAgICAgICAuLi5wcm9wZXJ0aWVzLFxuICAgICAgICAgIGNsYXNzOiBlbC5wcm9wZXJ0aWVzLmNsYXNzXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWNvcmF0aW9uLnByb3BlcnRpZXM/LmNsYXNzKVxuICAgICAgICAgIGFkZENsYXNzVG9IYXN0KGVsLCBkZWNvcmF0aW9uLnByb3BlcnRpZXMuY2xhc3MpO1xuICAgICAgICBlbCA9IHRyYW5zZm9ybShlbCwgdHlwZSkgfHwgZWw7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbmVBcHBsaWVzID0gW107XG4gICAgICBjb25zdCBzb3J0ZWQgPSBjdHguZGVjb3JhdGlvbnMuc29ydCgoYSwgYikgPT4gYi5zdGFydC5vZmZzZXQgLSBhLnN0YXJ0Lm9mZnNldCB8fCBhLmVuZC5vZmZzZXQgLSBiLmVuZC5vZmZzZXQpO1xuICAgICAgZm9yIChjb25zdCBkZWNvcmF0aW9uIG9mIHNvcnRlZCkge1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IGRlY29yYXRpb247XG4gICAgICAgIGlmIChzdGFydC5saW5lID09PSBlbmQubGluZSkge1xuICAgICAgICAgIGFwcGx5TGluZVNlY3Rpb24oc3RhcnQubGluZSwgc3RhcnQuY2hhcmFjdGVyLCBlbmQuY2hhcmFjdGVyLCBkZWNvcmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydC5saW5lIDwgZW5kLmxpbmUpIHtcbiAgICAgICAgICBhcHBseUxpbmVTZWN0aW9uKHN0YXJ0LmxpbmUsIHN0YXJ0LmNoYXJhY3RlciwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBkZWNvcmF0aW9uKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQubGluZSArIDE7IGkgPCBlbmQubGluZTsgaSsrKVxuICAgICAgICAgICAgbGluZUFwcGxpZXMudW5zaGlmdCgoKSA9PiBhcHBseUxpbmUoaSwgZGVjb3JhdGlvbikpO1xuICAgICAgICAgIGFwcGx5TGluZVNlY3Rpb24oZW5kLmxpbmUsIDAsIGVuZC5jaGFyYWN0ZXIsIGRlY29yYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaW5lQXBwbGllcy5mb3JFYWNoKChpKSA9PiBpKCkpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHZlcmlmeUludGVyc2VjdGlvbnMoaXRlbXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZvbyA9IGl0ZW1zW2ldO1xuICAgIGlmIChmb28uc3RhcnQub2Zmc2V0ID4gZm9vLmVuZC5vZmZzZXQpXG4gICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBJbnZhbGlkIGRlY29yYXRpb24gcmFuZ2U6ICR7SlNPTi5zdHJpbmdpZnkoZm9vLnN0YXJ0KX0gLSAke0pTT04uc3RyaW5naWZ5KGZvby5lbmQpfWApO1xuICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBiYXIgPSBpdGVtc1tqXTtcbiAgICAgIGNvbnN0IGlzRm9vSGFzQmFyU3RhcnQgPSBmb28uc3RhcnQub2Zmc2V0IDw9IGJhci5zdGFydC5vZmZzZXQgJiYgYmFyLnN0YXJ0Lm9mZnNldCA8IGZvby5lbmQub2Zmc2V0O1xuICAgICAgY29uc3QgaXNGb29IYXNCYXJFbmQgPSBmb28uc3RhcnQub2Zmc2V0IDwgYmFyLmVuZC5vZmZzZXQgJiYgYmFyLmVuZC5vZmZzZXQgPD0gZm9vLmVuZC5vZmZzZXQ7XG4gICAgICBjb25zdCBpc0Jhckhhc0Zvb1N0YXJ0ID0gYmFyLnN0YXJ0Lm9mZnNldCA8PSBmb28uc3RhcnQub2Zmc2V0ICYmIGZvby5zdGFydC5vZmZzZXQgPCBiYXIuZW5kLm9mZnNldDtcbiAgICAgIGNvbnN0IGlzQmFySGFzRm9vRW5kID0gYmFyLnN0YXJ0Lm9mZnNldCA8IGZvby5lbmQub2Zmc2V0ICYmIGZvby5lbmQub2Zmc2V0IDw9IGJhci5lbmQub2Zmc2V0O1xuICAgICAgaWYgKGlzRm9vSGFzQmFyU3RhcnQgfHwgaXNGb29IYXNCYXJFbmQgfHwgaXNCYXJIYXNGb29TdGFydCB8fCBpc0Jhckhhc0Zvb0VuZCkge1xuICAgICAgICBpZiAoaXNGb29IYXNCYXJTdGFydCAmJiBpc0Zvb0hhc0JhckVuZClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGlzQmFySGFzRm9vU3RhcnQgJiYgaXNCYXJIYXNGb29FbmQpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChpc0Jhckhhc0Zvb1N0YXJ0ICYmIGZvby5zdGFydC5vZmZzZXQgPT09IGZvby5lbmQub2Zmc2V0KVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoaXNGb29IYXNCYXJFbmQgJiYgYmFyLnN0YXJ0Lm9mZnNldCA9PT0gYmFyLmVuZC5vZmZzZXQpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoYERlY29yYXRpb25zICR7SlNPTi5zdHJpbmdpZnkoZm9vLnN0YXJ0KX0gYW5kICR7SlNPTi5zdHJpbmdpZnkoYmFyLnN0YXJ0KX0gaW50ZXJzZWN0LmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3RyaW5naWZ5KGVsKSB7XG4gIGlmIChlbC50eXBlID09PSBcInRleHRcIilcbiAgICByZXR1cm4gZWwudmFsdWU7XG4gIGlmIChlbC50eXBlID09PSBcImVsZW1lbnRcIilcbiAgICByZXR1cm4gZWwuY2hpbGRyZW4ubWFwKHN0cmluZ2lmeSkuam9pbihcIlwiKTtcbiAgcmV0dXJuIFwiXCI7XG59XG5cbmNvbnN0IGJ1aWx0SW5UcmFuc2Zvcm1lcnMgPSBbXG4gIC8qIEBfX1BVUkVfXyAqLyB0cmFuc2Zvcm1lckRlY29yYXRpb25zKClcbl07XG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1lcnMob3B0aW9ucykge1xuICBjb25zdCB0cmFuc2Zvcm1lcnMgPSBzb3J0VHJhbnNmb3JtZXJzQnlFbmZvcmNlbWVudChvcHRpb25zLnRyYW5zZm9ybWVycyB8fCBbXSk7XG4gIHJldHVybiBbXG4gICAgLi4udHJhbnNmb3JtZXJzLnByZSxcbiAgICAuLi50cmFuc2Zvcm1lcnMubm9ybWFsLFxuICAgIC4uLnRyYW5zZm9ybWVycy5wb3N0LFxuICAgIC4uLmJ1aWx0SW5UcmFuc2Zvcm1lcnNcbiAgXTtcbn1cbmZ1bmN0aW9uIHNvcnRUcmFuc2Zvcm1lcnNCeUVuZm9yY2VtZW50KHRyYW5zZm9ybWVycykge1xuICBjb25zdCBwcmUgPSBbXTtcbiAgY29uc3QgcG9zdCA9IFtdO1xuICBjb25zdCBub3JtYWwgPSBbXTtcbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiB0cmFuc2Zvcm1lcnMpIHtcbiAgICBzd2l0Y2ggKHRyYW5zZm9ybWVyLmVuZm9yY2UpIHtcbiAgICAgIGNhc2UgXCJwcmVcIjpcbiAgICAgICAgcHJlLnB1c2godHJhbnNmb3JtZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb3N0XCI6XG4gICAgICAgIHBvc3QucHVzaCh0cmFuc2Zvcm1lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbm9ybWFsLnB1c2godHJhbnNmb3JtZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBwcmUsIHBvc3QsIG5vcm1hbCB9O1xufVxuXG4vLyBzcmMvY29sb3JzLnRzXG52YXIgbmFtZWRDb2xvcnMgPSBbXG4gIFwiYmxhY2tcIixcbiAgXCJyZWRcIixcbiAgXCJncmVlblwiLFxuICBcInllbGxvd1wiLFxuICBcImJsdWVcIixcbiAgXCJtYWdlbnRhXCIsXG4gIFwiY3lhblwiLFxuICBcIndoaXRlXCIsXG4gIFwiYnJpZ2h0QmxhY2tcIixcbiAgXCJicmlnaHRSZWRcIixcbiAgXCJicmlnaHRHcmVlblwiLFxuICBcImJyaWdodFllbGxvd1wiLFxuICBcImJyaWdodEJsdWVcIixcbiAgXCJicmlnaHRNYWdlbnRhXCIsXG4gIFwiYnJpZ2h0Q3lhblwiLFxuICBcImJyaWdodFdoaXRlXCJcbl07XG5cbi8vIHNyYy9kZWNvcmF0aW9ucy50c1xudmFyIGRlY29yYXRpb25zID0ge1xuICAxOiBcImJvbGRcIixcbiAgMjogXCJkaW1cIixcbiAgMzogXCJpdGFsaWNcIixcbiAgNDogXCJ1bmRlcmxpbmVcIixcbiAgNzogXCJyZXZlcnNlXCIsXG4gIDg6IFwiaGlkZGVuXCIsXG4gIDk6IFwic3RyaWtldGhyb3VnaFwiXG59O1xuXG4vLyBzcmMvcGFyc2VyLnRzXG5mdW5jdGlvbiBmaW5kU2VxdWVuY2UodmFsdWUsIHBvc2l0aW9uKSB7XG4gIGNvbnN0IG5leHRFc2NhcGUgPSB2YWx1ZS5pbmRleE9mKFwiXFx4MUJcIiwgcG9zaXRpb24pO1xuICBpZiAobmV4dEVzY2FwZSAhPT0gLTEpIHtcbiAgICBpZiAodmFsdWVbbmV4dEVzY2FwZSArIDFdID09PSBcIltcIikge1xuICAgICAgY29uc3QgbmV4dENsb3NlID0gdmFsdWUuaW5kZXhPZihcIm1cIiwgbmV4dEVzY2FwZSk7XG4gICAgICBpZiAobmV4dENsb3NlICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNlcXVlbmNlOiB2YWx1ZS5zdWJzdHJpbmcobmV4dEVzY2FwZSArIDIsIG5leHRDbG9zZSkuc3BsaXQoXCI7XCIpLFxuICAgICAgICAgIHN0YXJ0UG9zaXRpb246IG5leHRFc2NhcGUsXG4gICAgICAgICAgcG9zaXRpb246IG5leHRDbG9zZSArIDFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogdmFsdWUubGVuZ3RoXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUNvbG9yKHNlcXVlbmNlKSB7XG4gIGNvbnN0IGNvbG9yTW9kZSA9IHNlcXVlbmNlLnNoaWZ0KCk7XG4gIGlmIChjb2xvck1vZGUgPT09IFwiMlwiKSB7XG4gICAgY29uc3QgcmdiID0gc2VxdWVuY2Uuc3BsaWNlKDAsIDMpLm1hcCgoeCkgPT4gTnVtYmVyLnBhcnNlSW50KHgpKTtcbiAgICBpZiAocmdiLmxlbmd0aCAhPT0gMyB8fCByZ2Iuc29tZSgoeCkgPT4gTnVtYmVyLmlzTmFOKHgpKSlcbiAgICAgIHJldHVybjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJyZ2JcIixcbiAgICAgIHJnYlxuICAgIH07XG4gIH0gZWxzZSBpZiAoY29sb3JNb2RlID09PSBcIjVcIikge1xuICAgIGNvbnN0IGluZGV4ID0gc2VxdWVuY2Uuc2hpZnQoKTtcbiAgICBpZiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGFibGVcIiwgaW5kZXg6IE51bWJlcihpbmRleCkgfTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlU2VxdWVuY2Uoc2VxdWVuY2UpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXTtcbiAgd2hpbGUgKHNlcXVlbmNlLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBjb2RlID0gc2VxdWVuY2Uuc2hpZnQoKTtcbiAgICBpZiAoIWNvZGUpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBjb2RlSW50ID0gTnVtYmVyLnBhcnNlSW50KGNvZGUpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oY29kZUludCkpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoY29kZUludCA9PT0gMCkge1xuICAgICAgY29tbWFuZHMucHVzaCh7IHR5cGU6IFwicmVzZXRBbGxcIiB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGVJbnQgPD0gOSkge1xuICAgICAgY29uc3QgZGVjb3JhdGlvbiA9IGRlY29yYXRpb25zW2NvZGVJbnRdO1xuICAgICAgaWYgKGRlY29yYXRpb24pIHtcbiAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJzZXREZWNvcmF0aW9uXCIsXG4gICAgICAgICAgdmFsdWU6IGRlY29yYXRpb25zW2NvZGVJbnRdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29kZUludCA8PSAyOSkge1xuICAgICAgY29uc3QgZGVjb3JhdGlvbiA9IGRlY29yYXRpb25zW2NvZGVJbnQgLSAyMF07XG4gICAgICBpZiAoZGVjb3JhdGlvbikge1xuICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInJlc2V0RGVjb3JhdGlvblwiLFxuICAgICAgICAgIHZhbHVlOiBkZWNvcmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGVjb3JhdGlvbiA9PT0gXCJkaW1cIikge1xuICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJyZXNldERlY29yYXRpb25cIixcbiAgICAgICAgICAgIHZhbHVlOiBcImJvbGRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlSW50IDw9IDM3KSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJzZXRGb3JlZ3JvdW5kQ29sb3JcIixcbiAgICAgICAgdmFsdWU6IHsgdHlwZTogXCJuYW1lZFwiLCBuYW1lOiBuYW1lZENvbG9yc1tjb2RlSW50IC0gMzBdIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZUludCA9PT0gMzgpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gcGFyc2VDb2xvcihzZXF1ZW5jZSk7XG4gICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJzZXRGb3JlZ3JvdW5kQ29sb3JcIixcbiAgICAgICAgICB2YWx1ZTogY29sb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlSW50ID09PSAzOSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwicmVzZXRGb3JlZ3JvdW5kQ29sb3JcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlSW50IDw9IDQ3KSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJzZXRCYWNrZ3JvdW5kQ29sb3JcIixcbiAgICAgICAgdmFsdWU6IHsgdHlwZTogXCJuYW1lZFwiLCBuYW1lOiBuYW1lZENvbG9yc1tjb2RlSW50IC0gNDBdIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZUludCA9PT0gNDgpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gcGFyc2VDb2xvcihzZXF1ZW5jZSk7XG4gICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJzZXRCYWNrZ3JvdW5kQ29sb3JcIixcbiAgICAgICAgICB2YWx1ZTogY29sb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlSW50ID09PSA0OSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwicmVzZXRCYWNrZ3JvdW5kQ29sb3JcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlSW50ID09PSA1Mykge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwic2V0RGVjb3JhdGlvblwiLFxuICAgICAgICB2YWx1ZTogXCJvdmVybGluZVwiXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGVJbnQgPT09IDU1KSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJyZXNldERlY29yYXRpb25cIixcbiAgICAgICAgdmFsdWU6IFwib3ZlcmxpbmVcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlSW50ID49IDkwICYmIGNvZGVJbnQgPD0gOTcpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInNldEZvcmVncm91bmRDb2xvclwiLFxuICAgICAgICB2YWx1ZTogeyB0eXBlOiBcIm5hbWVkXCIsIG5hbWU6IG5hbWVkQ29sb3JzW2NvZGVJbnQgLSA5MCArIDhdIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZUludCA+PSAxMDAgJiYgY29kZUludCA8PSAxMDcpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInNldEJhY2tncm91bmRDb2xvclwiLFxuICAgICAgICB2YWx1ZTogeyB0eXBlOiBcIm5hbWVkXCIsIG5hbWU6IG5hbWVkQ29sb3JzW2NvZGVJbnQgLSAxMDAgKyA4XSB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbW1hbmRzO1xufVxuZnVuY3Rpb24gY3JlYXRlQW5zaVNlcXVlbmNlUGFyc2VyKCkge1xuICBsZXQgZm9yZWdyb3VuZCA9IG51bGw7XG4gIGxldCBiYWNrZ3JvdW5kID0gbnVsbDtcbiAgbGV0IGRlY29yYXRpb25zMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHJldHVybiB7XG4gICAgcGFyc2UodmFsdWUpIHtcbiAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgICAgbGV0IHBvc2l0aW9uID0gMDtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgZmluZFJlc3VsdCA9IGZpbmRTZXF1ZW5jZSh2YWx1ZSwgcG9zaXRpb24pO1xuICAgICAgICBjb25zdCB0ZXh0ID0gZmluZFJlc3VsdC5zZXF1ZW5jZSA/IHZhbHVlLnN1YnN0cmluZyhwb3NpdGlvbiwgZmluZFJlc3VsdC5zdGFydFBvc2l0aW9uKSA6IHZhbHVlLnN1YnN0cmluZyhwb3NpdGlvbik7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB2YWx1ZTogdGV4dCxcbiAgICAgICAgICAgIGZvcmVncm91bmQsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLFxuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IG5ldyBTZXQoZGVjb3JhdGlvbnMyKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5kUmVzdWx0LnNlcXVlbmNlKSB7XG4gICAgICAgICAgY29uc3QgY29tbWFuZHMgPSBwYXJzZVNlcXVlbmNlKGZpbmRSZXN1bHQuc2VxdWVuY2UpO1xuICAgICAgICAgIGZvciAoY29uc3Qgc3R5bGVUb2tlbiBvZiBjb21tYW5kcykge1xuICAgICAgICAgICAgaWYgKHN0eWxlVG9rZW4udHlwZSA9PT0gXCJyZXNldEFsbFwiKSB7XG4gICAgICAgICAgICAgIGZvcmVncm91bmQgPSBudWxsO1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgZGVjb3JhdGlvbnMyLmNsZWFyKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlVG9rZW4udHlwZSA9PT0gXCJyZXNldEZvcmVncm91bmRDb2xvclwiKSB7XG4gICAgICAgICAgICAgIGZvcmVncm91bmQgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVRva2VuLnR5cGUgPT09IFwicmVzZXRCYWNrZ3JvdW5kQ29sb3JcIikge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGVUb2tlbi50eXBlID09PSBcInJlc2V0RGVjb3JhdGlvblwiKSB7XG4gICAgICAgICAgICAgIGRlY29yYXRpb25zMi5kZWxldGUoc3R5bGVUb2tlbi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3Qgc3R5bGVUb2tlbiBvZiBjb21tYW5kcykge1xuICAgICAgICAgICAgaWYgKHN0eWxlVG9rZW4udHlwZSA9PT0gXCJzZXRGb3JlZ3JvdW5kQ29sb3JcIikge1xuICAgICAgICAgICAgICBmb3JlZ3JvdW5kID0gc3R5bGVUb2tlbi52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGVUb2tlbi50eXBlID09PSBcInNldEJhY2tncm91bmRDb2xvclwiKSB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQgPSBzdHlsZVRva2VuLnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVRva2VuLnR5cGUgPT09IFwic2V0RGVjb3JhdGlvblwiKSB7XG4gICAgICAgICAgICAgIGRlY29yYXRpb25zMi5hZGQoc3R5bGVUb2tlbi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9uID0gZmluZFJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIH0gd2hpbGUgKHBvc2l0aW9uIDwgdmFsdWUubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvcGFsZXR0ZS50c1xudmFyIGRlZmF1bHROYW1lZENvbG9yc01hcCA9IHtcbiAgYmxhY2s6IFwiIzAwMDAwMFwiLFxuICByZWQ6IFwiI2JiMDAwMFwiLFxuICBncmVlbjogXCIjMDBiYjAwXCIsXG4gIHllbGxvdzogXCIjYmJiYjAwXCIsXG4gIGJsdWU6IFwiIzAwMDBiYlwiLFxuICBtYWdlbnRhOiBcIiNmZjAwZmZcIixcbiAgY3lhbjogXCIjMDBiYmJiXCIsXG4gIHdoaXRlOiBcIiNlZWVlZWVcIixcbiAgYnJpZ2h0QmxhY2s6IFwiIzU1NTU1NVwiLFxuICBicmlnaHRSZWQ6IFwiI2ZmNTU1NVwiLFxuICBicmlnaHRHcmVlbjogXCIjMDBmZjAwXCIsXG4gIGJyaWdodFllbGxvdzogXCIjZmZmZjU1XCIsXG4gIGJyaWdodEJsdWU6IFwiIzU1NTVmZlwiLFxuICBicmlnaHRNYWdlbnRhOiBcIiNmZjU1ZmZcIixcbiAgYnJpZ2h0Q3lhbjogXCIjNTVmZmZmXCIsXG4gIGJyaWdodFdoaXRlOiBcIiNmZmZmZmZcIlxufTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbG9yUGFsZXR0ZShuYW1lZENvbG9yc01hcCA9IGRlZmF1bHROYW1lZENvbG9yc01hcCkge1xuICBmdW5jdGlvbiBuYW1lZENvbG9yKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZWRDb2xvcnNNYXBbbmFtZV07XG4gIH1cbiAgZnVuY3Rpb24gcmdiQ29sb3IocmdiKSB7XG4gICAgcmV0dXJuIGAjJHtyZ2IubWFwKCh4KSA9PiBNYXRoLm1heCgwLCBNYXRoLm1pbih4LCAyNTUpKS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKS5qb2luKFwiXCIpfWA7XG4gIH1cbiAgbGV0IGNvbG9yVGFibGU7XG4gIGZ1bmN0aW9uIGdldENvbG9yVGFibGUoKSB7XG4gICAgaWYgKGNvbG9yVGFibGUpIHtcbiAgICAgIHJldHVybiBjb2xvclRhYmxlO1xuICAgIH1cbiAgICBjb2xvclRhYmxlID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lZENvbG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29sb3JUYWJsZS5wdXNoKG5hbWVkQ29sb3IobmFtZWRDb2xvcnNbaV0pKTtcbiAgICB9XG4gICAgbGV0IGxldmVscyA9IFswLCA5NSwgMTM1LCAxNzUsIDIxNSwgMjU1XTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IDY7IHIrKykge1xuICAgICAgZm9yIChsZXQgZyA9IDA7IGcgPCA2OyBnKyspIHtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCA2OyBiKyspIHtcbiAgICAgICAgICBjb2xvclRhYmxlLnB1c2gocmdiQ29sb3IoW2xldmVsc1tyXSwgbGV2ZWxzW2ddLCBsZXZlbHNbYl1dKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGxldmVsID0gODtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI0OyBpKyssIGxldmVsICs9IDEwKSB7XG4gICAgICBjb2xvclRhYmxlLnB1c2gocmdiQ29sb3IoW2xldmVsLCBsZXZlbCwgbGV2ZWxdKSk7XG4gICAgfVxuICAgIHJldHVybiBjb2xvclRhYmxlO1xuICB9XG4gIGZ1bmN0aW9uIHRhYmxlQ29sb3IoaW5kZXgpIHtcbiAgICByZXR1cm4gZ2V0Q29sb3JUYWJsZSgpW2luZGV4XTtcbiAgfVxuICBmdW5jdGlvbiB2YWx1ZShjb2xvcikge1xuICAgIHN3aXRjaCAoY29sb3IudHlwZSkge1xuICAgICAgY2FzZSBcIm5hbWVkXCI6XG4gICAgICAgIHJldHVybiBuYW1lZENvbG9yKGNvbG9yLm5hbWUpO1xuICAgICAgY2FzZSBcInJnYlwiOlxuICAgICAgICByZXR1cm4gcmdiQ29sb3IoY29sb3IucmdiKTtcbiAgICAgIGNhc2UgXCJ0YWJsZVwiOlxuICAgICAgICByZXR1cm4gdGFibGVDb2xvcihjb2xvci5pbmRleCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9rZW5pemVBbnNpV2l0aFRoZW1lKHRoZW1lLCBmaWxlQ29udGVudHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgY29sb3JSZXBsYWNlbWVudHMgPSByZXNvbHZlQ29sb3JSZXBsYWNlbWVudHModGhlbWUsIG9wdGlvbnMpO1xuICBjb25zdCBsaW5lcyA9IHNwbGl0TGluZXMoZmlsZUNvbnRlbnRzKTtcbiAgY29uc3QgY29sb3JQYWxldHRlID0gY3JlYXRlQ29sb3JQYWxldHRlKFxuICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIG5hbWVkQ29sb3JzLm1hcCgobmFtZSkgPT4gW1xuICAgICAgICBuYW1lLFxuICAgICAgICB0aGVtZS5jb2xvcnM/LltgdGVybWluYWwuYW5zaSR7bmFtZVswXS50b1VwcGVyQ2FzZSgpfSR7bmFtZS5zdWJzdHJpbmcoMSl9YF1cbiAgICAgIF0pXG4gICAgKVxuICApO1xuICBjb25zdCBwYXJzZXIgPSBjcmVhdGVBbnNpU2VxdWVuY2VQYXJzZXIoKTtcbiAgcmV0dXJuIGxpbmVzLm1hcChcbiAgICAobGluZSkgPT4gcGFyc2VyLnBhcnNlKGxpbmVbMF0pLm1hcCgodG9rZW4pID0+IHtcbiAgICAgIGxldCBjb2xvcjtcbiAgICAgIGxldCBiZ0NvbG9yO1xuICAgICAgaWYgKHRva2VuLmRlY29yYXRpb25zLmhhcyhcInJldmVyc2VcIikpIHtcbiAgICAgICAgY29sb3IgPSB0b2tlbi5iYWNrZ3JvdW5kID8gY29sb3JQYWxldHRlLnZhbHVlKHRva2VuLmJhY2tncm91bmQpIDogdGhlbWUuYmc7XG4gICAgICAgIGJnQ29sb3IgPSB0b2tlbi5mb3JlZ3JvdW5kID8gY29sb3JQYWxldHRlLnZhbHVlKHRva2VuLmZvcmVncm91bmQpIDogdGhlbWUuZmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xvciA9IHRva2VuLmZvcmVncm91bmQgPyBjb2xvclBhbGV0dGUudmFsdWUodG9rZW4uZm9yZWdyb3VuZCkgOiB0aGVtZS5mZztcbiAgICAgICAgYmdDb2xvciA9IHRva2VuLmJhY2tncm91bmQgPyBjb2xvclBhbGV0dGUudmFsdWUodG9rZW4uYmFja2dyb3VuZCkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBjb2xvciA9IGFwcGx5Q29sb3JSZXBsYWNlbWVudHMoY29sb3IsIGNvbG9yUmVwbGFjZW1lbnRzKTtcbiAgICAgIGJnQ29sb3IgPSBhcHBseUNvbG9yUmVwbGFjZW1lbnRzKGJnQ29sb3IsIGNvbG9yUmVwbGFjZW1lbnRzKTtcbiAgICAgIGlmICh0b2tlbi5kZWNvcmF0aW9ucy5oYXMoXCJkaW1cIikpXG4gICAgICAgIGNvbG9yID0gZGltQ29sb3IoY29sb3IpO1xuICAgICAgbGV0IGZvbnRTdHlsZSA9IEZvbnRTdHlsZS5Ob25lO1xuICAgICAgaWYgKHRva2VuLmRlY29yYXRpb25zLmhhcyhcImJvbGRcIikpXG4gICAgICAgIGZvbnRTdHlsZSB8PSBGb250U3R5bGUuQm9sZDtcbiAgICAgIGlmICh0b2tlbi5kZWNvcmF0aW9ucy5oYXMoXCJpdGFsaWNcIikpXG4gICAgICAgIGZvbnRTdHlsZSB8PSBGb250U3R5bGUuSXRhbGljO1xuICAgICAgaWYgKHRva2VuLmRlY29yYXRpb25zLmhhcyhcInVuZGVybGluZVwiKSlcbiAgICAgICAgZm9udFN0eWxlIHw9IEZvbnRTdHlsZS5VbmRlcmxpbmU7XG4gICAgICBpZiAodG9rZW4uZGVjb3JhdGlvbnMuaGFzKFwic3RyaWtldGhyb3VnaFwiKSlcbiAgICAgICAgZm9udFN0eWxlIHw9IEZvbnRTdHlsZS5TdHJpa2V0aHJvdWdoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDogdG9rZW4udmFsdWUsXG4gICAgICAgIG9mZnNldDogbGluZVsxXSxcbiAgICAgICAgLy8gVE9ETzogbW9yZSBhY2N1cmF0ZSBvZmZzZXQ/IG1pZ2h0IG5lZWQgdG8gZm9yayBhbnNpLXNlcXVlbmNlLXBhcnNlclxuICAgICAgICBjb2xvcixcbiAgICAgICAgYmdDb2xvcixcbiAgICAgICAgZm9udFN0eWxlXG4gICAgICB9O1xuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiBkaW1Db2xvcihjb2xvcikge1xuICBjb25zdCBoZXhNYXRjaCA9IGNvbG9yLm1hdGNoKC8jKFswLTlhLWZdezN9KShbMC05YS1mXXszfSk/KFswLTlhLWZdezJ9KT8vKTtcbiAgaWYgKGhleE1hdGNoKSB7XG4gICAgaWYgKGhleE1hdGNoWzNdKSB7XG4gICAgICBjb25zdCBhbHBoYSA9IE1hdGgucm91bmQoTnVtYmVyLnBhcnNlSW50KGhleE1hdGNoWzNdLCAxNikgLyAyKS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xuICAgICAgcmV0dXJuIGAjJHtoZXhNYXRjaFsxXX0ke2hleE1hdGNoWzJdfSR7YWxwaGF9YDtcbiAgICB9IGVsc2UgaWYgKGhleE1hdGNoWzJdKSB7XG4gICAgICByZXR1cm4gYCMke2hleE1hdGNoWzFdfSR7aGV4TWF0Y2hbMl19ODBgO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYCMke0FycmF5LmZyb20oaGV4TWF0Y2hbMV0pLm1hcCgoeCkgPT4gYCR7eH0ke3h9YCkuam9pbihcIlwiKX04MGA7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNzc1Zhck1hdGNoID0gY29sb3IubWF0Y2goL3ZhclxcKCgtLVtcXHctXSstYW5zaS1bXFx3LV0rKVxcKS8pO1xuICBpZiAoY3NzVmFyTWF0Y2gpXG4gICAgcmV0dXJuIGB2YXIoJHtjc3NWYXJNYXRjaFsxXX0tZGltKWA7XG4gIHJldHVybiBjb2xvcjtcbn1cblxuZnVuY3Rpb24gY29kZVRvVG9rZW5zQmFzZShpbnRlcm5hbCwgY29kZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBsYW5nID0gXCJ0ZXh0XCIsXG4gICAgdGhlbWU6IHRoZW1lTmFtZSA9IGludGVybmFsLmdldExvYWRlZFRoZW1lcygpWzBdXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoaXNQbGFpbkxhbmcobGFuZykgfHwgaXNOb25lVGhlbWUodGhlbWVOYW1lKSlcbiAgICByZXR1cm4gc3BsaXRMaW5lcyhjb2RlKS5tYXAoKGxpbmUpID0+IFt7IGNvbnRlbnQ6IGxpbmVbMF0sIG9mZnNldDogbGluZVsxXSB9XSk7XG4gIGNvbnN0IHsgdGhlbWUsIGNvbG9yTWFwIH0gPSBpbnRlcm5hbC5zZXRUaGVtZSh0aGVtZU5hbWUpO1xuICBpZiAobGFuZyA9PT0gXCJhbnNpXCIpXG4gICAgcmV0dXJuIHRva2VuaXplQW5zaVdpdGhUaGVtZSh0aGVtZSwgY29kZSwgb3B0aW9ucyk7XG4gIGNvbnN0IF9ncmFtbWFyID0gaW50ZXJuYWwuZ2V0TGFuZ3VhZ2UobGFuZyk7XG4gIGlmIChvcHRpb25zLmdyYW1tYXJTdGF0ZSkge1xuICAgIGlmIChvcHRpb25zLmdyYW1tYXJTdGF0ZS5sYW5nICE9PSBfZ3JhbW1hci5uYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBHcmFtbWFyIHN0YXRlIGxhbmd1YWdlIFwiJHtvcHRpb25zLmdyYW1tYXJTdGF0ZS5sYW5nfVwiIGRvZXMgbm90IG1hdGNoIGhpZ2hsaWdodCBsYW5ndWFnZSBcIiR7X2dyYW1tYXIubmFtZX1cImApO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuZ3JhbW1hclN0YXRlLnRoZW1lcy5pbmNsdWRlcyh0aGVtZS5uYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgR3JhbW1hciBzdGF0ZSB0aGVtZXMgXCIke29wdGlvbnMuZ3JhbW1hclN0YXRlLnRoZW1lc31cIiBkbyBub3QgY29udGFpbiBoaWdobGlnaHQgdGhlbWUgXCIke3RoZW1lLm5hbWV9XCJgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRva2VuaXplV2l0aFRoZW1lKGNvZGUsIF9ncmFtbWFyLCB0aGVtZSwgY29sb3JNYXAsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZ2V0TGFzdEdyYW1tYXJTdGF0ZSguLi5hcmdzKSB7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIHJldHVybiBnZXRMYXN0R3JhbW1hclN0YXRlRnJvbU1hcChhcmdzWzFdKTtcbiAgfVxuICBjb25zdCBbaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMgPSB7fV0gPSBhcmdzO1xuICBjb25zdCB7XG4gICAgbGFuZyA9IFwidGV4dFwiLFxuICAgIHRoZW1lOiB0aGVtZU5hbWUgPSBpbnRlcm5hbC5nZXRMb2FkZWRUaGVtZXMoKVswXVxuICB9ID0gb3B0aW9ucztcbiAgaWYgKGlzUGxhaW5MYW5nKGxhbmcpIHx8IGlzTm9uZVRoZW1lKHRoZW1lTmFtZSkpXG4gICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShcIlBsYWluIGxhbmd1YWdlIGRvZXMgbm90IGhhdmUgZ3JhbW1hciBzdGF0ZVwiKTtcbiAgaWYgKGxhbmcgPT09IFwiYW5zaVwiKVxuICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoXCJBTlNJIGxhbmd1YWdlIGRvZXMgbm90IGhhdmUgZ3JhbW1hciBzdGF0ZVwiKTtcbiAgY29uc3QgeyB0aGVtZSwgY29sb3JNYXAgfSA9IGludGVybmFsLnNldFRoZW1lKHRoZW1lTmFtZSk7XG4gIGNvbnN0IF9ncmFtbWFyID0gaW50ZXJuYWwuZ2V0TGFuZ3VhZ2UobGFuZyk7XG4gIHJldHVybiBuZXcgR3JhbW1hclN0YXRlKFxuICAgIF90b2tlbml6ZVdpdGhUaGVtZShjb2RlLCBfZ3JhbW1hciwgdGhlbWUsIGNvbG9yTWFwLCBvcHRpb25zKS5zdGF0ZVN0YWNrLFxuICAgIF9ncmFtbWFyLm5hbWUsXG4gICAgdGhlbWUubmFtZVxuICApO1xufVxuZnVuY3Rpb24gdG9rZW5pemVXaXRoVGhlbWUoY29kZSwgZ3JhbW1hciwgdGhlbWUsIGNvbG9yTWFwLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IF90b2tlbml6ZVdpdGhUaGVtZShjb2RlLCBncmFtbWFyLCB0aGVtZSwgY29sb3JNYXAsIG9wdGlvbnMpO1xuICBjb25zdCBncmFtbWFyU3RhdGUgPSBuZXcgR3JhbW1hclN0YXRlKFxuICAgIF90b2tlbml6ZVdpdGhUaGVtZShjb2RlLCBncmFtbWFyLCB0aGVtZSwgY29sb3JNYXAsIG9wdGlvbnMpLnN0YXRlU3RhY2ssXG4gICAgZ3JhbW1hci5uYW1lLFxuICAgIHRoZW1lLm5hbWVcbiAgKTtcbiAgc2V0TGFzdEdyYW1tYXJTdGF0ZVRvTWFwKHJlc3VsdC50b2tlbnMsIGdyYW1tYXJTdGF0ZSk7XG4gIHJldHVybiByZXN1bHQudG9rZW5zO1xufVxuZnVuY3Rpb24gX3Rva2VuaXplV2l0aFRoZW1lKGNvZGUsIGdyYW1tYXIsIHRoZW1lLCBjb2xvck1hcCwgb3B0aW9ucykge1xuICBjb25zdCBjb2xvclJlcGxhY2VtZW50cyA9IHJlc29sdmVDb2xvclJlcGxhY2VtZW50cyh0aGVtZSwgb3B0aW9ucyk7XG4gIGNvbnN0IHtcbiAgICB0b2tlbml6ZU1heExpbmVMZW5ndGggPSAwLFxuICAgIHRva2VuaXplVGltZUxpbWl0ID0gNTAwXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBsaW5lcyA9IHNwbGl0TGluZXMoY29kZSk7XG4gIGxldCBzdGF0ZVN0YWNrID0gb3B0aW9ucy5ncmFtbWFyU3RhdGUgPyBnZXRHcmFtbWFyU3RhY2sob3B0aW9ucy5ncmFtbWFyU3RhdGUsIHRoZW1lLm5hbWUpID8/IElOSVRJQUwgOiBvcHRpb25zLmdyYW1tYXJDb250ZXh0Q29kZSAhPSBudWxsID8gX3Rva2VuaXplV2l0aFRoZW1lKFxuICAgIG9wdGlvbnMuZ3JhbW1hckNvbnRleHRDb2RlLFxuICAgIGdyYW1tYXIsXG4gICAgdGhlbWUsXG4gICAgY29sb3JNYXAsXG4gICAge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGdyYW1tYXJTdGF0ZTogdm9pZCAwLFxuICAgICAgZ3JhbW1hckNvbnRleHRDb2RlOiB2b2lkIDBcbiAgICB9XG4gICkuc3RhdGVTdGFjayA6IElOSVRJQUw7XG4gIGxldCBhY3R1YWwgPSBbXTtcbiAgY29uc3QgZmluYWwgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgW2xpbmUsIGxpbmVPZmZzZXRdID0gbGluZXNbaV07XG4gICAgaWYgKGxpbmUgPT09IFwiXCIpIHtcbiAgICAgIGFjdHVhbCA9IFtdO1xuICAgICAgZmluYWwucHVzaChbXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHRva2VuaXplTWF4TGluZUxlbmd0aCA+IDAgJiYgbGluZS5sZW5ndGggPj0gdG9rZW5pemVNYXhMaW5lTGVuZ3RoKSB7XG4gICAgICBhY3R1YWwgPSBbXTtcbiAgICAgIGZpbmFsLnB1c2goW3tcbiAgICAgICAgY29udGVudDogbGluZSxcbiAgICAgICAgb2Zmc2V0OiBsaW5lT2Zmc2V0LFxuICAgICAgICBjb2xvcjogXCJcIixcbiAgICAgICAgZm9udFN0eWxlOiAwXG4gICAgICB9XSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdFdpdGhTY29wZXM7XG4gICAgbGV0IHRva2Vuc1dpdGhTY29wZXM7XG4gICAgbGV0IHRva2Vuc1dpdGhTY29wZXNJbmRleDtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlRXhwbGFuYXRpb24pIHtcbiAgICAgIHJlc3VsdFdpdGhTY29wZXMgPSBncmFtbWFyLnRva2VuaXplTGluZShsaW5lLCBzdGF0ZVN0YWNrLCB0b2tlbml6ZVRpbWVMaW1pdCk7XG4gICAgICB0b2tlbnNXaXRoU2NvcGVzID0gcmVzdWx0V2l0aFNjb3Blcy50b2tlbnM7XG4gICAgICB0b2tlbnNXaXRoU2NvcGVzSW5kZXggPSAwO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBncmFtbWFyLnRva2VuaXplTGluZTIobGluZSwgc3RhdGVTdGFjaywgdG9rZW5pemVUaW1lTGltaXQpO1xuICAgIGNvbnN0IHRva2Vuc0xlbmd0aCA9IHJlc3VsdC50b2tlbnMubGVuZ3RoIC8gMjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRva2Vuc0xlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBzdGFydEluZGV4ID0gcmVzdWx0LnRva2Vuc1syICogal07XG4gICAgICBjb25zdCBuZXh0U3RhcnRJbmRleCA9IGogKyAxIDwgdG9rZW5zTGVuZ3RoID8gcmVzdWx0LnRva2Vuc1syICogaiArIDJdIDogbGluZS5sZW5ndGg7XG4gICAgICBpZiAoc3RhcnRJbmRleCA9PT0gbmV4dFN0YXJ0SW5kZXgpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSByZXN1bHQudG9rZW5zWzIgKiBqICsgMV07XG4gICAgICBjb25zdCBjb2xvciA9IGFwcGx5Q29sb3JSZXBsYWNlbWVudHMoXG4gICAgICAgIGNvbG9yTWFwW0VuY29kZWRUb2tlbk1ldGFkYXRhLmdldEZvcmVncm91bmQobWV0YWRhdGEpXSxcbiAgICAgICAgY29sb3JSZXBsYWNlbWVudHNcbiAgICAgICk7XG4gICAgICBjb25zdCBmb250U3R5bGUgPSBFbmNvZGVkVG9rZW5NZXRhZGF0YS5nZXRGb250U3R5bGUobWV0YWRhdGEpO1xuICAgICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgIGNvbnRlbnQ6IGxpbmUuc3Vic3RyaW5nKHN0YXJ0SW5kZXgsIG5leHRTdGFydEluZGV4KSxcbiAgICAgICAgb2Zmc2V0OiBsaW5lT2Zmc2V0ICsgc3RhcnRJbmRleCxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIGZvbnRTdHlsZVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVFeHBsYW5hdGlvbikge1xuICAgICAgICBjb25zdCB0aGVtZVNldHRpbmdzU2VsZWN0b3JzID0gW107XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVFeHBsYW5hdGlvbiAhPT0gXCJzY29wZU5hbWVcIikge1xuICAgICAgICAgIGZvciAoY29uc3Qgc2V0dGluZyBvZiB0aGVtZS5zZXR0aW5ncykge1xuICAgICAgICAgICAgbGV0IHNlbGVjdG9ycztcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHNldHRpbmcuc2NvcGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IHNldHRpbmcuc2NvcGUuc3BsaXQoLywvKS5tYXAoKHNjb3BlKSA9PiBzY29wZS50cmltKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzID0gc2V0dGluZy5zY29wZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoZW1lU2V0dGluZ3NTZWxlY3RvcnMucHVzaCh7XG4gICAgICAgICAgICAgIHNldHRpbmdzOiBzZXR0aW5nLFxuICAgICAgICAgICAgICBzZWxlY3RvcnM6IHNlbGVjdG9ycy5tYXAoKHNlbGVjdG9yKSA9PiBzZWxlY3Rvci5zcGxpdCgvIC8pKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRva2VuLmV4cGxhbmF0aW9uID0gW107XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCArIG9mZnNldCA8IG5leHRTdGFydEluZGV4KSB7XG4gICAgICAgICAgY29uc3QgdG9rZW5XaXRoU2NvcGVzID0gdG9rZW5zV2l0aFNjb3Blc1t0b2tlbnNXaXRoU2NvcGVzSW5kZXhdO1xuICAgICAgICAgIGNvbnN0IHRva2VuV2l0aFNjb3Blc1RleHQgPSBsaW5lLnN1YnN0cmluZyhcbiAgICAgICAgICAgIHRva2VuV2l0aFNjb3Blcy5zdGFydEluZGV4LFxuICAgICAgICAgICAgdG9rZW5XaXRoU2NvcGVzLmVuZEluZGV4XG4gICAgICAgICAgKTtcbiAgICAgICAgICBvZmZzZXQgKz0gdG9rZW5XaXRoU2NvcGVzVGV4dC5sZW5ndGg7XG4gICAgICAgICAgdG9rZW4uZXhwbGFuYXRpb24ucHVzaCh7XG4gICAgICAgICAgICBjb250ZW50OiB0b2tlbldpdGhTY29wZXNUZXh0LFxuICAgICAgICAgICAgc2NvcGVzOiBvcHRpb25zLmluY2x1ZGVFeHBsYW5hdGlvbiA9PT0gXCJzY29wZU5hbWVcIiA/IGV4cGxhaW5UaGVtZVNjb3Blc05hbWVPbmx5KFxuICAgICAgICAgICAgICB0b2tlbldpdGhTY29wZXMuc2NvcGVzXG4gICAgICAgICAgICApIDogZXhwbGFpblRoZW1lU2NvcGVzRnVsbChcbiAgICAgICAgICAgICAgdGhlbWVTZXR0aW5nc1NlbGVjdG9ycyxcbiAgICAgICAgICAgICAgdG9rZW5XaXRoU2NvcGVzLnNjb3Blc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRva2Vuc1dpdGhTY29wZXNJbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhY3R1YWwucHVzaCh0b2tlbik7XG4gICAgfVxuICAgIGZpbmFsLnB1c2goYWN0dWFsKTtcbiAgICBhY3R1YWwgPSBbXTtcbiAgICBzdGF0ZVN0YWNrID0gcmVzdWx0LnJ1bGVTdGFjaztcbiAgfVxuICByZXR1cm4ge1xuICAgIHRva2VuczogZmluYWwsXG4gICAgc3RhdGVTdGFja1xuICB9O1xufVxuZnVuY3Rpb24gZXhwbGFpblRoZW1lU2NvcGVzTmFtZU9ubHkoc2NvcGVzKSB7XG4gIHJldHVybiBzY29wZXMubWFwKChzY29wZSkgPT4gKHsgc2NvcGVOYW1lOiBzY29wZSB9KSk7XG59XG5mdW5jdGlvbiBleHBsYWluVGhlbWVTY29wZXNGdWxsKHRoZW1lU2VsZWN0b3JzLCBzY29wZXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzY29wZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBzY29wZSA9IHNjb3Blc1tpXTtcbiAgICByZXN1bHRbaV0gPSB7XG4gICAgICBzY29wZU5hbWU6IHNjb3BlLFxuICAgICAgdGhlbWVNYXRjaGVzOiBleHBsYWluVGhlbWVTY29wZSh0aGVtZVNlbGVjdG9ycywgc2NvcGUsIHNjb3Blcy5zbGljZSgwLCBpKSlcbiAgICB9O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtYXRjaGVzT25lKHNlbGVjdG9yLCBzY29wZSkge1xuICByZXR1cm4gc2VsZWN0b3IgPT09IHNjb3BlIHx8IHNjb3BlLnN1YnN0cmluZygwLCBzZWxlY3Rvci5sZW5ndGgpID09PSBzZWxlY3RvciAmJiBzY29wZVtzZWxlY3Rvci5sZW5ndGhdID09PSBcIi5cIjtcbn1cbmZ1bmN0aW9uIG1hdGNoZXMoc2VsZWN0b3JzLCBzY29wZSwgcGFyZW50U2NvcGVzKSB7XG4gIGlmICghbWF0Y2hlc09uZShzZWxlY3RvcnNbc2VsZWN0b3JzLmxlbmd0aCAtIDFdLCBzY29wZSkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBsZXQgc2VsZWN0b3JQYXJlbnRJbmRleCA9IHNlbGVjdG9ycy5sZW5ndGggLSAyO1xuICBsZXQgcGFyZW50SW5kZXggPSBwYXJlbnRTY29wZXMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKHNlbGVjdG9yUGFyZW50SW5kZXggPj0gMCAmJiBwYXJlbnRJbmRleCA+PSAwKSB7XG4gICAgaWYgKG1hdGNoZXNPbmUoc2VsZWN0b3JzW3NlbGVjdG9yUGFyZW50SW5kZXhdLCBwYXJlbnRTY29wZXNbcGFyZW50SW5kZXhdKSlcbiAgICAgIHNlbGVjdG9yUGFyZW50SW5kZXggLT0gMTtcbiAgICBwYXJlbnRJbmRleCAtPSAxO1xuICB9XG4gIGlmIChzZWxlY3RvclBhcmVudEluZGV4ID09PSAtMSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZXhwbGFpblRoZW1lU2NvcGUodGhlbWVTZXR0aW5nc1NlbGVjdG9ycywgc2NvcGUsIHBhcmVudFNjb3Blcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChjb25zdCB7IHNlbGVjdG9ycywgc2V0dGluZ3MgfSBvZiB0aGVtZVNldHRpbmdzU2VsZWN0b3JzKSB7XG4gICAgZm9yIChjb25zdCBzZWxlY3RvclBpZWNlcyBvZiBzZWxlY3RvcnMpIHtcbiAgICAgIGlmIChtYXRjaGVzKHNlbGVjdG9yUGllY2VzLCBzY29wZSwgcGFyZW50U2NvcGVzKSkge1xuICAgICAgICByZXN1bHQucHVzaChzZXR0aW5ncyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjb2RlVG9Ub2tlbnNXaXRoVGhlbWVzKGludGVybmFsLCBjb2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHRoZW1lcyA9IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMudGhlbWVzKS5maWx0ZXIoKGkpID0+IGlbMV0pLm1hcCgoaSkgPT4gKHsgY29sb3I6IGlbMF0sIHRoZW1lOiBpWzFdIH0pKTtcbiAgY29uc3QgdGhlbWVkVG9rZW5zID0gdGhlbWVzLm1hcCgodCkgPT4ge1xuICAgIGNvbnN0IHRva2VuczIgPSBjb2RlVG9Ub2tlbnNCYXNlKGludGVybmFsLCBjb2RlLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdGhlbWU6IHQudGhlbWVcbiAgICB9KTtcbiAgICBjb25zdCBzdGF0ZSA9IGdldExhc3RHcmFtbWFyU3RhdGVGcm9tTWFwKHRva2VuczIpO1xuICAgIGNvbnN0IHRoZW1lID0gdHlwZW9mIHQudGhlbWUgPT09IFwic3RyaW5nXCIgPyB0LnRoZW1lIDogdC50aGVtZS5uYW1lO1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbnM6IHRva2VuczIsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRoZW1lXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IHRva2VucyA9IHN5bmNUaGVtZXNUb2tlbml6YXRpb24oXG4gICAgLi4udGhlbWVkVG9rZW5zLm1hcCgoaSkgPT4gaS50b2tlbnMpXG4gICk7XG4gIGNvbnN0IG1lcmdlZFRva2VucyA9IHRva2Vuc1swXS5tYXAoXG4gICAgKGxpbmUsIGxpbmVJZHgpID0+IGxpbmUubWFwKChfdG9rZW4sIHRva2VuSWR4KSA9PiB7XG4gICAgICBjb25zdCBtZXJnZWRUb2tlbiA9IHtcbiAgICAgICAgY29udGVudDogX3Rva2VuLmNvbnRlbnQsXG4gICAgICAgIHZhcmlhbnRzOiB7fSxcbiAgICAgICAgb2Zmc2V0OiBfdG9rZW4ub2Zmc2V0XG4gICAgICB9O1xuICAgICAgaWYgKFwiaW5jbHVkZUV4cGxhbmF0aW9uXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmluY2x1ZGVFeHBsYW5hdGlvbikge1xuICAgICAgICBtZXJnZWRUb2tlbi5leHBsYW5hdGlvbiA9IF90b2tlbi5leHBsYW5hdGlvbjtcbiAgICAgIH1cbiAgICAgIHRva2Vucy5mb3JFYWNoKCh0LCB0aGVtZUlkeCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY29udGVudDogXyxcbiAgICAgICAgICBleHBsYW5hdGlvbjogX18sXG4gICAgICAgICAgb2Zmc2V0OiBfX18sXG4gICAgICAgICAgLi4uc3R5bGVzXG4gICAgICAgIH0gPSB0W2xpbmVJZHhdW3Rva2VuSWR4XTtcbiAgICAgICAgbWVyZ2VkVG9rZW4udmFyaWFudHNbdGhlbWVzW3RoZW1lSWR4XS5jb2xvcl0gPSBzdHlsZXM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtZXJnZWRUb2tlbjtcbiAgICB9KVxuICApO1xuICBjb25zdCBtZXJnZWRHcmFtbWFyU3RhdGUgPSB0aGVtZWRUb2tlbnNbMF0uc3RhdGUgPyBuZXcgR3JhbW1hclN0YXRlKFxuICAgIE9iamVjdC5mcm9tRW50cmllcyh0aGVtZWRUb2tlbnMubWFwKChzKSA9PiBbcy50aGVtZSwgcy5zdGF0ZT8uZ2V0SW50ZXJuYWxTdGFjayhzLnRoZW1lKV0pKSxcbiAgICB0aGVtZWRUb2tlbnNbMF0uc3RhdGUubGFuZ1xuICApIDogdm9pZCAwO1xuICBpZiAobWVyZ2VkR3JhbW1hclN0YXRlKVxuICAgIHNldExhc3RHcmFtbWFyU3RhdGVUb01hcChtZXJnZWRUb2tlbnMsIG1lcmdlZEdyYW1tYXJTdGF0ZSk7XG4gIHJldHVybiBtZXJnZWRUb2tlbnM7XG59XG5mdW5jdGlvbiBzeW5jVGhlbWVzVG9rZW5pemF0aW9uKC4uLnRoZW1lcykge1xuICBjb25zdCBvdXRUaGVtZXMgPSB0aGVtZXMubWFwKCgpID0+IFtdKTtcbiAgY29uc3QgY291bnQgPSB0aGVtZXMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoZW1lc1swXS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmVzID0gdGhlbWVzLm1hcCgodCkgPT4gdFtpXSk7XG4gICAgY29uc3Qgb3V0TGluZXMgPSBvdXRUaGVtZXMubWFwKCgpID0+IFtdKTtcbiAgICBvdXRUaGVtZXMuZm9yRWFjaCgodCwgaTIpID0+IHQucHVzaChvdXRMaW5lc1tpMl0pKTtcbiAgICBjb25zdCBpbmRleGVzID0gbGluZXMubWFwKCgpID0+IDApO1xuICAgIGNvbnN0IGN1cnJlbnQgPSBsaW5lcy5tYXAoKGwpID0+IGxbMF0pO1xuICAgIHdoaWxlIChjdXJyZW50LmV2ZXJ5KCh0KSA9PiB0KSkge1xuICAgICAgY29uc3QgbWluTGVuZ3RoID0gTWF0aC5taW4oLi4uY3VycmVudC5tYXAoKHQpID0+IHQuY29udGVudC5sZW5ndGgpKTtcbiAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgY291bnQ7IG4rKykge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGN1cnJlbnRbbl07XG4gICAgICAgIGlmICh0b2tlbi5jb250ZW50Lmxlbmd0aCA9PT0gbWluTGVuZ3RoKSB7XG4gICAgICAgICAgb3V0TGluZXNbbl0ucHVzaCh0b2tlbik7XG4gICAgICAgICAgaW5kZXhlc1tuXSArPSAxO1xuICAgICAgICAgIGN1cnJlbnRbbl0gPSBsaW5lc1tuXVtpbmRleGVzW25dXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRMaW5lc1tuXS5wdXNoKHtcbiAgICAgICAgICAgIC4uLnRva2VuLFxuICAgICAgICAgICAgY29udGVudDogdG9rZW4uY29udGVudC5zbGljZSgwLCBtaW5MZW5ndGgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY3VycmVudFtuXSA9IHtcbiAgICAgICAgICAgIC4uLnRva2VuLFxuICAgICAgICAgICAgY29udGVudDogdG9rZW4uY29udGVudC5zbGljZShtaW5MZW5ndGgpLFxuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlbi5vZmZzZXQgKyBtaW5MZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRUaGVtZXM7XG59XG5cbmZ1bmN0aW9uIGNvZGVUb1Rva2VucyhpbnRlcm5hbCwgY29kZSwgb3B0aW9ucykge1xuICBsZXQgYmc7XG4gIGxldCBmZztcbiAgbGV0IHRva2VucztcbiAgbGV0IHRoZW1lTmFtZTtcbiAgbGV0IHJvb3RTdHlsZTtcbiAgbGV0IGdyYW1tYXJTdGF0ZTtcbiAgaWYgKFwidGhlbWVzXCIgaW4gb3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRlZmF1bHRDb2xvciA9IFwibGlnaHRcIixcbiAgICAgIGNzc1ZhcmlhYmxlUHJlZml4ID0gXCItLXNoaWtpLVwiLFxuICAgICAgY29sb3JzUmVuZGVyaW5nID0gXCJjc3MtdmFyc1wiXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdGhlbWVzID0gT2JqZWN0LmVudHJpZXMob3B0aW9ucy50aGVtZXMpLmZpbHRlcigoaSkgPT4gaVsxXSkubWFwKChpKSA9PiAoeyBjb2xvcjogaVswXSwgdGhlbWU6IGlbMV0gfSkpLnNvcnQoKGEsIGIpID0+IGEuY29sb3IgPT09IGRlZmF1bHRDb2xvciA/IC0xIDogYi5jb2xvciA9PT0gZGVmYXVsdENvbG9yID8gMSA6IDApO1xuICAgIGlmICh0aGVtZXMubGVuZ3RoID09PSAwKVxuICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShcImB0aGVtZXNgIG9wdGlvbiBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcbiAgICBjb25zdCB0aGVtZVRva2VucyA9IGNvZGVUb1Rva2Vuc1dpdGhUaGVtZXMoXG4gICAgICBpbnRlcm5hbCxcbiAgICAgIGNvZGUsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBncmFtbWFyU3RhdGUgPSBnZXRMYXN0R3JhbW1hclN0YXRlRnJvbU1hcCh0aGVtZVRva2Vucyk7XG4gICAgaWYgKGRlZmF1bHRDb2xvciAmJiBERUZBVUxUX0NPTE9SX0xJR0hUX0RBUksgIT09IGRlZmF1bHRDb2xvciAmJiAhdGhlbWVzLmZpbmQoKHQpID0+IHQuY29sb3IgPT09IGRlZmF1bHRDb2xvcikpXG4gICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBcXGB0aGVtZXNcXGAgb3B0aW9uIG11c3QgY29udGFpbiB0aGUgZGVmYXVsdENvbG9yIGtleSBcXGAke2RlZmF1bHRDb2xvcn1cXGBgKTtcbiAgICBjb25zdCB0aGVtZVJlZ3MgPSB0aGVtZXMubWFwKCh0KSA9PiBpbnRlcm5hbC5nZXRUaGVtZSh0LnRoZW1lKSk7XG4gICAgY29uc3QgdGhlbWVzT3JkZXIgPSB0aGVtZXMubWFwKCh0KSA9PiB0LmNvbG9yKTtcbiAgICB0b2tlbnMgPSB0aGVtZVRva2Vucy5tYXAoKGxpbmUpID0+IGxpbmUubWFwKCh0b2tlbikgPT4gZmxhdFRva2VuVmFyaWFudHModG9rZW4sIHRoZW1lc09yZGVyLCBjc3NWYXJpYWJsZVByZWZpeCwgZGVmYXVsdENvbG9yLCBjb2xvcnNSZW5kZXJpbmcpKSk7XG4gICAgaWYgKGdyYW1tYXJTdGF0ZSlcbiAgICAgIHNldExhc3RHcmFtbWFyU3RhdGVUb01hcCh0b2tlbnMsIGdyYW1tYXJTdGF0ZSk7XG4gICAgY29uc3QgdGhlbWVDb2xvclJlcGxhY2VtZW50cyA9IHRoZW1lcy5tYXAoKHQpID0+IHJlc29sdmVDb2xvclJlcGxhY2VtZW50cyh0LnRoZW1lLCBvcHRpb25zKSk7XG4gICAgZmcgPSBtYXBUaGVtZUNvbG9ycyh0aGVtZXMsIHRoZW1lUmVncywgdGhlbWVDb2xvclJlcGxhY2VtZW50cywgY3NzVmFyaWFibGVQcmVmaXgsIGRlZmF1bHRDb2xvciwgXCJmZ1wiLCBjb2xvcnNSZW5kZXJpbmcpO1xuICAgIGJnID0gbWFwVGhlbWVDb2xvcnModGhlbWVzLCB0aGVtZVJlZ3MsIHRoZW1lQ29sb3JSZXBsYWNlbWVudHMsIGNzc1ZhcmlhYmxlUHJlZml4LCBkZWZhdWx0Q29sb3IsIFwiYmdcIiwgY29sb3JzUmVuZGVyaW5nKTtcbiAgICB0aGVtZU5hbWUgPSBgc2hpa2ktdGhlbWVzICR7dGhlbWVSZWdzLm1hcCgodCkgPT4gdC5uYW1lKS5qb2luKFwiIFwiKX1gO1xuICAgIHJvb3RTdHlsZSA9IGRlZmF1bHRDb2xvciA/IHZvaWQgMCA6IFtmZywgYmddLmpvaW4oXCI7XCIpO1xuICB9IGVsc2UgaWYgKFwidGhlbWVcIiBpbiBvcHRpb25zKSB7XG4gICAgY29uc3QgY29sb3JSZXBsYWNlbWVudHMgPSByZXNvbHZlQ29sb3JSZXBsYWNlbWVudHMob3B0aW9ucy50aGVtZSwgb3B0aW9ucyk7XG4gICAgdG9rZW5zID0gY29kZVRvVG9rZW5zQmFzZShcbiAgICAgIGludGVybmFsLFxuICAgICAgY29kZSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGNvbnN0IF90aGVtZSA9IGludGVybmFsLmdldFRoZW1lKG9wdGlvbnMudGhlbWUpO1xuICAgIGJnID0gYXBwbHlDb2xvclJlcGxhY2VtZW50cyhfdGhlbWUuYmcsIGNvbG9yUmVwbGFjZW1lbnRzKTtcbiAgICBmZyA9IGFwcGx5Q29sb3JSZXBsYWNlbWVudHMoX3RoZW1lLmZnLCBjb2xvclJlcGxhY2VtZW50cyk7XG4gICAgdGhlbWVOYW1lID0gX3RoZW1lLm5hbWU7XG4gICAgZ3JhbW1hclN0YXRlID0gZ2V0TGFzdEdyYW1tYXJTdGF0ZUZyb21NYXAodG9rZW5zKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKFwiSW52YWxpZCBvcHRpb25zLCBlaXRoZXIgYHRoZW1lYCBvciBgdGhlbWVzYCBtdXN0IGJlIHByb3ZpZGVkXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgdG9rZW5zLFxuICAgIGZnLFxuICAgIGJnLFxuICAgIHRoZW1lTmFtZSxcbiAgICByb290U3R5bGUsXG4gICAgZ3JhbW1hclN0YXRlXG4gIH07XG59XG5mdW5jdGlvbiBtYXBUaGVtZUNvbG9ycyh0aGVtZXMsIHRoZW1lUmVncywgdGhlbWVDb2xvclJlcGxhY2VtZW50cywgY3NzVmFyaWFibGVQcmVmaXgsIGRlZmF1bHRDb2xvciwgcHJvcGVydHksIGNvbG9yc1JlbmRlcmluZykge1xuICByZXR1cm4gdGhlbWVzLm1hcCgodCwgaWR4KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBhcHBseUNvbG9yUmVwbGFjZW1lbnRzKHRoZW1lUmVnc1tpZHhdW3Byb3BlcnR5XSwgdGhlbWVDb2xvclJlcGxhY2VtZW50c1tpZHhdKSB8fCBcImluaGVyaXRcIjtcbiAgICBjb25zdCBjc3NWYXIgPSBgJHtjc3NWYXJpYWJsZVByZWZpeCArIHQuY29sb3J9JHtwcm9wZXJ0eSA9PT0gXCJiZ1wiID8gXCItYmdcIiA6IFwiXCJ9OiR7dmFsdWV9YDtcbiAgICBpZiAoaWR4ID09PSAwICYmIGRlZmF1bHRDb2xvcikge1xuICAgICAgaWYgKGRlZmF1bHRDb2xvciA9PT0gREVGQVVMVF9DT0xPUl9MSUdIVF9EQVJLICYmIHRoZW1lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IGxpZ2h0SW5kZXggPSB0aGVtZXMuZmluZEluZGV4KCh0MikgPT4gdDIuY29sb3IgPT09IFwibGlnaHRcIik7XG4gICAgICAgIGNvbnN0IGRhcmtJbmRleCA9IHRoZW1lcy5maW5kSW5kZXgoKHQyKSA9PiB0Mi5jb2xvciA9PT0gXCJkYXJrXCIpO1xuICAgICAgICBpZiAobGlnaHRJbmRleCA9PT0gLTEgfHwgZGFya0luZGV4ID09PSAtMSlcbiAgICAgICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKCdXaGVuIHVzaW5nIGBkZWZhdWx0Q29sb3I6IFwibGlnaHQtZGFyaygpXCJgLCB5b3UgbXVzdCBwcm92aWRlIGJvdGggYGxpZ2h0YCBhbmQgYGRhcmtgIHRoZW1lcycpO1xuICAgICAgICBjb25zdCBsaWdodFZhbHVlID0gYXBwbHlDb2xvclJlcGxhY2VtZW50cyh0aGVtZVJlZ3NbbGlnaHRJbmRleF1bcHJvcGVydHldLCB0aGVtZUNvbG9yUmVwbGFjZW1lbnRzW2xpZ2h0SW5kZXhdKSB8fCBcImluaGVyaXRcIjtcbiAgICAgICAgY29uc3QgZGFya1ZhbHVlID0gYXBwbHlDb2xvclJlcGxhY2VtZW50cyh0aGVtZVJlZ3NbZGFya0luZGV4XVtwcm9wZXJ0eV0sIHRoZW1lQ29sb3JSZXBsYWNlbWVudHNbZGFya0luZGV4XSkgfHwgXCJpbmhlcml0XCI7XG4gICAgICAgIHJldHVybiBgbGlnaHQtZGFyaygke2xpZ2h0VmFsdWV9LCAke2RhcmtWYWx1ZX0pOyR7Y3NzVmFyfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChjb2xvcnNSZW5kZXJpbmcgPT09IFwiY3NzLXZhcnNcIikge1xuICAgICAgcmV0dXJuIGNzc1ZhcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pLmZpbHRlcigoaSkgPT4gISFpKS5qb2luKFwiO1wiKTtcbn1cblxuZnVuY3Rpb24gY29kZVRvSGFzdChpbnRlcm5hbCwgY29kZSwgb3B0aW9ucywgdHJhbnNmb3JtZXJDb250ZXh0ID0ge1xuICBtZXRhOiB7fSxcbiAgb3B0aW9ucyxcbiAgY29kZVRvSGFzdDogKF9jb2RlLCBfb3B0aW9ucykgPT4gY29kZVRvSGFzdChpbnRlcm5hbCwgX2NvZGUsIF9vcHRpb25zKSxcbiAgY29kZVRvVG9rZW5zOiAoX2NvZGUsIF9vcHRpb25zKSA9PiBjb2RlVG9Ub2tlbnMoaW50ZXJuYWwsIF9jb2RlLCBfb3B0aW9ucylcbn0pIHtcbiAgbGV0IGlucHV0ID0gY29kZTtcbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiBnZXRUcmFuc2Zvcm1lcnMob3B0aW9ucykpXG4gICAgaW5wdXQgPSB0cmFuc2Zvcm1lci5wcmVwcm9jZXNzPy5jYWxsKHRyYW5zZm9ybWVyQ29udGV4dCwgaW5wdXQsIG9wdGlvbnMpIHx8IGlucHV0O1xuICBsZXQge1xuICAgIHRva2VucyxcbiAgICBmZyxcbiAgICBiZyxcbiAgICB0aGVtZU5hbWUsXG4gICAgcm9vdFN0eWxlLFxuICAgIGdyYW1tYXJTdGF0ZVxuICB9ID0gY29kZVRvVG9rZW5zKGludGVybmFsLCBpbnB1dCwgb3B0aW9ucyk7XG4gIGNvbnN0IHtcbiAgICBtZXJnZVdoaXRlc3BhY2VzID0gdHJ1ZSxcbiAgICBtZXJnZVNhbWVTdHlsZVRva2VucyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBpZiAobWVyZ2VXaGl0ZXNwYWNlcyA9PT0gdHJ1ZSlcbiAgICB0b2tlbnMgPSBtZXJnZVdoaXRlc3BhY2VUb2tlbnModG9rZW5zKTtcbiAgZWxzZSBpZiAobWVyZ2VXaGl0ZXNwYWNlcyA9PT0gXCJuZXZlclwiKVxuICAgIHRva2VucyA9IHNwbGl0V2hpdGVzcGFjZVRva2Vucyh0b2tlbnMpO1xuICBpZiAobWVyZ2VTYW1lU3R5bGVUb2tlbnMpIHtcbiAgICB0b2tlbnMgPSBtZXJnZUFkamFjZW50U3R5bGVkVG9rZW5zKHRva2Vucyk7XG4gIH1cbiAgY29uc3QgY29udGV4dFNvdXJjZSA9IHtcbiAgICAuLi50cmFuc2Zvcm1lckNvbnRleHQsXG4gICAgZ2V0IHNvdXJjZSgpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gIH07XG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgZ2V0VHJhbnNmb3JtZXJzKG9wdGlvbnMpKVxuICAgIHRva2VucyA9IHRyYW5zZm9ybWVyLnRva2Vucz8uY2FsbChjb250ZXh0U291cmNlLCB0b2tlbnMpIHx8IHRva2VucztcbiAgcmV0dXJuIHRva2Vuc1RvSGFzdChcbiAgICB0b2tlbnMsXG4gICAge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGZnLFxuICAgICAgYmcsXG4gICAgICB0aGVtZU5hbWUsXG4gICAgICByb290U3R5bGVcbiAgICB9LFxuICAgIGNvbnRleHRTb3VyY2UsXG4gICAgZ3JhbW1hclN0YXRlXG4gICk7XG59XG5mdW5jdGlvbiB0b2tlbnNUb0hhc3QodG9rZW5zLCBvcHRpb25zLCB0cmFuc2Zvcm1lckNvbnRleHQsIGdyYW1tYXJTdGF0ZSA9IGdldExhc3RHcmFtbWFyU3RhdGVGcm9tTWFwKHRva2VucykpIHtcbiAgY29uc3QgdHJhbnNmb3JtZXJzID0gZ2V0VHJhbnNmb3JtZXJzKG9wdGlvbnMpO1xuICBjb25zdCBsaW5lcyA9IFtdO1xuICBjb25zdCByb290ID0ge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIGNoaWxkcmVuOiBbXVxuICB9O1xuICBjb25zdCB7XG4gICAgc3RydWN0dXJlID0gXCJjbGFzc2ljXCIsXG4gICAgdGFiaW5kZXggPSBcIjBcIlxuICB9ID0gb3B0aW9ucztcbiAgbGV0IHByZU5vZGUgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJwcmVcIixcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBjbGFzczogYHNoaWtpICR7b3B0aW9ucy50aGVtZU5hbWUgfHwgXCJcIn1gLFxuICAgICAgc3R5bGU6IG9wdGlvbnMucm9vdFN0eWxlIHx8IGBiYWNrZ3JvdW5kLWNvbG9yOiR7b3B0aW9ucy5iZ307Y29sb3I6JHtvcHRpb25zLmZnfWAsXG4gICAgICAuLi50YWJpbmRleCAhPT0gZmFsc2UgJiYgdGFiaW5kZXggIT0gbnVsbCA/IHtcbiAgICAgICAgdGFiaW5kZXg6IHRhYmluZGV4LnRvU3RyaW5nKClcbiAgICAgIH0gOiB7fSxcbiAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgQXJyYXkuZnJvbShcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhvcHRpb25zLm1ldGEgfHwge30pXG4gICAgICAgICkuZmlsdGVyKChba2V5XSkgPT4gIWtleS5zdGFydHNXaXRoKFwiX1wiKSlcbiAgICAgIClcbiAgICB9LFxuICAgIGNoaWxkcmVuOiBbXVxuICB9O1xuICBsZXQgY29kZU5vZGUgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJjb2RlXCIsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgY2hpbGRyZW46IGxpbmVzXG4gIH07XG4gIGNvbnN0IGxpbmVOb2RlcyA9IFtdO1xuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIC4uLnRyYW5zZm9ybWVyQ29udGV4dCxcbiAgICBzdHJ1Y3R1cmUsXG4gICAgYWRkQ2xhc3NUb0hhc3QsXG4gICAgZ2V0IHNvdXJjZSgpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lckNvbnRleHQuc291cmNlO1xuICAgIH0sXG4gICAgZ2V0IHRva2VucygpIHtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfSxcbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH0sXG4gICAgZ2V0IHJvb3QoKSB7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9LFxuICAgIGdldCBwcmUoKSB7XG4gICAgICByZXR1cm4gcHJlTm9kZTtcbiAgICB9LFxuICAgIGdldCBjb2RlKCkge1xuICAgICAgcmV0dXJuIGNvZGVOb2RlO1xuICAgIH0sXG4gICAgZ2V0IGxpbmVzKCkge1xuICAgICAgcmV0dXJuIGxpbmVOb2RlcztcbiAgICB9XG4gIH07XG4gIHRva2Vucy5mb3JFYWNoKChsaW5lLCBpZHgpID0+IHtcbiAgICBpZiAoaWR4KSB7XG4gICAgICBpZiAoc3RydWN0dXJlID09PSBcImlubGluZVwiKVxuICAgICAgICByb290LmNoaWxkcmVuLnB1c2goeyB0eXBlOiBcImVsZW1lbnRcIiwgdGFnTmFtZTogXCJiclwiLCBwcm9wZXJ0aWVzOiB7fSwgY2hpbGRyZW46IFtdIH0pO1xuICAgICAgZWxzZSBpZiAoc3RydWN0dXJlID09PSBcImNsYXNzaWNcIilcbiAgICAgICAgbGluZXMucHVzaCh7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogXCJcXG5cIiB9KTtcbiAgICB9XG4gICAgbGV0IGxpbmVOb2RlID0ge1xuICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICB0YWdOYW1lOiBcInNwYW5cIixcbiAgICAgIHByb3BlcnRpZXM6IHsgY2xhc3M6IFwibGluZVwiIH0sXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuICAgIGxldCBjb2wgPSAwO1xuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgbGluZSkge1xuICAgICAgbGV0IHRva2VuTm9kZSA9IHtcbiAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgIHRhZ05hbWU6IFwic3BhblwiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgLi4udG9rZW4uaHRtbEF0dHJzXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IHRva2VuLmNvbnRlbnQgfV1cbiAgICAgIH07XG4gICAgICBjb25zdCBzdHlsZSA9IHN0cmluZ2lmeVRva2VuU3R5bGUodG9rZW4uaHRtbFN0eWxlIHx8IGdldFRva2VuU3R5bGVPYmplY3QodG9rZW4pKTtcbiAgICAgIGlmIChzdHlsZSlcbiAgICAgICAgdG9rZW5Ob2RlLnByb3BlcnRpZXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKVxuICAgICAgICB0b2tlbk5vZGUgPSB0cmFuc2Zvcm1lcj8uc3Bhbj8uY2FsbChjb250ZXh0LCB0b2tlbk5vZGUsIGlkeCArIDEsIGNvbCwgbGluZU5vZGUsIHRva2VuKSB8fCB0b2tlbk5vZGU7XG4gICAgICBpZiAoc3RydWN0dXJlID09PSBcImlubGluZVwiKVxuICAgICAgICByb290LmNoaWxkcmVuLnB1c2godG9rZW5Ob2RlKTtcbiAgICAgIGVsc2UgaWYgKHN0cnVjdHVyZSA9PT0gXCJjbGFzc2ljXCIpXG4gICAgICAgIGxpbmVOb2RlLmNoaWxkcmVuLnB1c2godG9rZW5Ob2RlKTtcbiAgICAgIGNvbCArPSB0b2tlbi5jb250ZW50Lmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHN0cnVjdHVyZSA9PT0gXCJjbGFzc2ljXCIpIHtcbiAgICAgIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKVxuICAgICAgICBsaW5lTm9kZSA9IHRyYW5zZm9ybWVyPy5saW5lPy5jYWxsKGNvbnRleHQsIGxpbmVOb2RlLCBpZHggKyAxKSB8fCBsaW5lTm9kZTtcbiAgICAgIGxpbmVOb2Rlcy5wdXNoKGxpbmVOb2RlKTtcbiAgICAgIGxpbmVzLnB1c2gobGluZU5vZGUpO1xuICAgIH1cbiAgfSk7XG4gIGlmIChzdHJ1Y3R1cmUgPT09IFwiY2xhc3NpY1wiKSB7XG4gICAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiB0cmFuc2Zvcm1lcnMpXG4gICAgICBjb2RlTm9kZSA9IHRyYW5zZm9ybWVyPy5jb2RlPy5jYWxsKGNvbnRleHQsIGNvZGVOb2RlKSB8fCBjb2RlTm9kZTtcbiAgICBwcmVOb2RlLmNoaWxkcmVuLnB1c2goY29kZU5vZGUpO1xuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKVxuICAgICAgcHJlTm9kZSA9IHRyYW5zZm9ybWVyPy5wcmU/LmNhbGwoY29udGV4dCwgcHJlTm9kZSkgfHwgcHJlTm9kZTtcbiAgICByb290LmNoaWxkcmVuLnB1c2gocHJlTm9kZSk7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IHJvb3Q7XG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKVxuICAgIHJlc3VsdCA9IHRyYW5zZm9ybWVyPy5yb290Py5jYWxsKGNvbnRleHQsIHJlc3VsdCkgfHwgcmVzdWx0O1xuICBpZiAoZ3JhbW1hclN0YXRlKVxuICAgIHNldExhc3RHcmFtbWFyU3RhdGVUb01hcChyZXN1bHQsIGdyYW1tYXJTdGF0ZSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtZXJnZVdoaXRlc3BhY2VUb2tlbnModG9rZW5zKSB7XG4gIHJldHVybiB0b2tlbnMubWFwKChsaW5lKSA9PiB7XG4gICAgY29uc3QgbmV3TGluZSA9IFtdO1xuICAgIGxldCBjYXJyeU9uQ29udGVudCA9IFwiXCI7XG4gICAgbGV0IGZpcnN0T2Zmc2V0ID0gMDtcbiAgICBsaW5lLmZvckVhY2goKHRva2VuLCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IGlzRGVjb3JhdGVkID0gdG9rZW4uZm9udFN0eWxlICYmICh0b2tlbi5mb250U3R5bGUgJiBGb250U3R5bGUuVW5kZXJsaW5lIHx8IHRva2VuLmZvbnRTdHlsZSAmIEZvbnRTdHlsZS5TdHJpa2V0aHJvdWdoKTtcbiAgICAgIGNvbnN0IGNvdWxkTWVyZ2UgPSAhaXNEZWNvcmF0ZWQ7XG4gICAgICBpZiAoY291bGRNZXJnZSAmJiB0b2tlbi5jb250ZW50Lm1hdGNoKC9eXFxzKyQvKSAmJiBsaW5lW2lkeCArIDFdKSB7XG4gICAgICAgIGlmICghZmlyc3RPZmZzZXQpXG4gICAgICAgICAgZmlyc3RPZmZzZXQgPSB0b2tlbi5vZmZzZXQ7XG4gICAgICAgIGNhcnJ5T25Db250ZW50ICs9IHRva2VuLmNvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2FycnlPbkNvbnRlbnQpIHtcbiAgICAgICAgICBpZiAoY291bGRNZXJnZSkge1xuICAgICAgICAgICAgbmV3TGluZS5wdXNoKHtcbiAgICAgICAgICAgICAgLi4udG9rZW4sXG4gICAgICAgICAgICAgIG9mZnNldDogZmlyc3RPZmZzZXQsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IGNhcnJ5T25Db250ZW50ICsgdG9rZW4uY29udGVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xpbmUucHVzaChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNhcnJ5T25Db250ZW50LFxuICAgICAgICAgICAgICAgIG9mZnNldDogZmlyc3RPZmZzZXRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdG9rZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpcnN0T2Zmc2V0ID0gMDtcbiAgICAgICAgICBjYXJyeU9uQ29udGVudCA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3TGluZS5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXdMaW5lO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNwbGl0V2hpdGVzcGFjZVRva2Vucyh0b2tlbnMpIHtcbiAgcmV0dXJuIHRva2Vucy5tYXAoKGxpbmUpID0+IHtcbiAgICByZXR1cm4gbGluZS5mbGF0TWFwKCh0b2tlbikgPT4ge1xuICAgICAgaWYgKHRva2VuLmNvbnRlbnQubWF0Y2goL15cXHMrJC8pKVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICBjb25zdCBtYXRjaCA9IHRva2VuLmNvbnRlbnQubWF0Y2goL14oXFxzKikoLio/KShcXHMqKSQvKTtcbiAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIGNvbnN0IFssIGxlYWRpbmcsIGNvbnRlbnQsIHRyYWlsaW5nXSA9IG1hdGNoO1xuICAgICAgaWYgKCFsZWFkaW5nICYmICF0cmFpbGluZylcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgY29uc3QgZXhwYW5kZWQgPSBbe1xuICAgICAgICAuLi50b2tlbixcbiAgICAgICAgb2Zmc2V0OiB0b2tlbi5vZmZzZXQgKyBsZWFkaW5nLmxlbmd0aCxcbiAgICAgICAgY29udGVudFxuICAgICAgfV07XG4gICAgICBpZiAobGVhZGluZykge1xuICAgICAgICBleHBhbmRlZC51bnNoaWZ0KHtcbiAgICAgICAgICBjb250ZW50OiBsZWFkaW5nLFxuICAgICAgICAgIG9mZnNldDogdG9rZW4ub2Zmc2V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRyYWlsaW5nKSB7XG4gICAgICAgIGV4cGFuZGVkLnB1c2goe1xuICAgICAgICAgIGNvbnRlbnQ6IHRyYWlsaW5nLFxuICAgICAgICAgIG9mZnNldDogdG9rZW4ub2Zmc2V0ICsgbGVhZGluZy5sZW5ndGggKyBjb250ZW50Lmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHBhbmRlZDtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBtZXJnZUFkamFjZW50U3R5bGVkVG9rZW5zKHRva2Vucykge1xuICByZXR1cm4gdG9rZW5zLm1hcCgobGluZSkgPT4ge1xuICAgIGNvbnN0IG5ld0xpbmUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRva2VuIG9mIGxpbmUpIHtcbiAgICAgIGlmIChuZXdMaW5lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBuZXdMaW5lLnB1c2goeyAuLi50b2tlbiB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2VG9rZW4gPSBuZXdMaW5lW25ld0xpbmUubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBwcmV2U3R5bGUgPSBzdHJpbmdpZnlUb2tlblN0eWxlKHByZXZUb2tlbi5odG1sU3R5bGUgfHwgZ2V0VG9rZW5TdHlsZU9iamVjdChwcmV2VG9rZW4pKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdHlsZSA9IHN0cmluZ2lmeVRva2VuU3R5bGUodG9rZW4uaHRtbFN0eWxlIHx8IGdldFRva2VuU3R5bGVPYmplY3QodG9rZW4pKTtcbiAgICAgIGNvbnN0IGlzUHJldkRlY29yYXRlZCA9IHByZXZUb2tlbi5mb250U3R5bGUgJiYgKHByZXZUb2tlbi5mb250U3R5bGUgJiBGb250U3R5bGUuVW5kZXJsaW5lIHx8IHByZXZUb2tlbi5mb250U3R5bGUgJiBGb250U3R5bGUuU3RyaWtldGhyb3VnaCk7XG4gICAgICBjb25zdCBpc0RlY29yYXRlZCA9IHRva2VuLmZvbnRTdHlsZSAmJiAodG9rZW4uZm9udFN0eWxlICYgRm9udFN0eWxlLlVuZGVybGluZSB8fCB0b2tlbi5mb250U3R5bGUgJiBGb250U3R5bGUuU3RyaWtldGhyb3VnaCk7XG4gICAgICBpZiAoIWlzUHJldkRlY29yYXRlZCAmJiAhaXNEZWNvcmF0ZWQgJiYgcHJldlN0eWxlID09PSBjdXJyZW50U3R5bGUpIHtcbiAgICAgICAgcHJldlRva2VuLmNvbnRlbnQgKz0gdG9rZW4uY29udGVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0xpbmUucHVzaCh7IC4uLnRva2VuIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3TGluZTtcbiAgfSk7XG59XG5cbmNvbnN0IGhhc3RUb0h0bWwgPSB0b0h0bWw7XG5mdW5jdGlvbiBjb2RlVG9IdG1sKGludGVybmFsLCBjb2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgbWV0YToge30sXG4gICAgb3B0aW9ucyxcbiAgICBjb2RlVG9IYXN0OiAoX2NvZGUsIF9vcHRpb25zKSA9PiBjb2RlVG9IYXN0KGludGVybmFsLCBfY29kZSwgX29wdGlvbnMpLFxuICAgIGNvZGVUb1Rva2VuczogKF9jb2RlLCBfb3B0aW9ucykgPT4gY29kZVRvVG9rZW5zKGludGVybmFsLCBfY29kZSwgX29wdGlvbnMpXG4gIH07XG4gIGxldCByZXN1bHQgPSBoYXN0VG9IdG1sKGNvZGVUb0hhc3QoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMsIGNvbnRleHQpKTtcbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiBnZXRUcmFuc2Zvcm1lcnMob3B0aW9ucykpXG4gICAgcmVzdWx0ID0gdHJhbnNmb3JtZXIucG9zdHByb2Nlc3M/LmNhbGwoY29udGV4dCwgcmVzdWx0LCBvcHRpb25zKSB8fCByZXN1bHQ7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IFZTQ09ERV9GQUxMQkFDS19FRElUT1JfRkcgPSB7IGxpZ2h0OiBcIiMzMzMzMzNcIiwgZGFyazogXCIjYmJiYmJiXCIgfTtcbmNvbnN0IFZTQ09ERV9GQUxMQkFDS19FRElUT1JfQkcgPSB7IGxpZ2h0OiBcIiNmZmZmZmVcIiwgZGFyazogXCIjMWUxZTFlXCIgfTtcbmNvbnN0IFJFU09MVkVEX0tFWSA9IFwiX19zaGlraV9yZXNvbHZlZFwiO1xuZnVuY3Rpb24gbm9ybWFsaXplVGhlbWUocmF3VGhlbWUpIHtcbiAgaWYgKHJhd1RoZW1lPy5bUkVTT0xWRURfS0VZXSlcbiAgICByZXR1cm4gcmF3VGhlbWU7XG4gIGNvbnN0IHRoZW1lID0ge1xuICAgIC4uLnJhd1RoZW1lXG4gIH07XG4gIGlmICh0aGVtZS50b2tlbkNvbG9ycyAmJiAhdGhlbWUuc2V0dGluZ3MpIHtcbiAgICB0aGVtZS5zZXR0aW5ncyA9IHRoZW1lLnRva2VuQ29sb3JzO1xuICAgIGRlbGV0ZSB0aGVtZS50b2tlbkNvbG9ycztcbiAgfVxuICB0aGVtZS50eXBlIHx8PSBcImRhcmtcIjtcbiAgdGhlbWUuY29sb3JSZXBsYWNlbWVudHMgPSB7IC4uLnRoZW1lLmNvbG9yUmVwbGFjZW1lbnRzIH07XG4gIHRoZW1lLnNldHRpbmdzIHx8PSBbXTtcbiAgbGV0IHsgYmcsIGZnIH0gPSB0aGVtZTtcbiAgaWYgKCFiZyB8fCAhZmcpIHtcbiAgICBjb25zdCBnbG9iYWxTZXR0aW5nID0gdGhlbWUuc2V0dGluZ3MgPyB0aGVtZS5zZXR0aW5ncy5maW5kKChzKSA9PiAhcy5uYW1lICYmICFzLnNjb3BlKSA6IHZvaWQgMDtcbiAgICBpZiAoZ2xvYmFsU2V0dGluZz8uc2V0dGluZ3M/LmZvcmVncm91bmQpXG4gICAgICBmZyA9IGdsb2JhbFNldHRpbmcuc2V0dGluZ3MuZm9yZWdyb3VuZDtcbiAgICBpZiAoZ2xvYmFsU2V0dGluZz8uc2V0dGluZ3M/LmJhY2tncm91bmQpXG4gICAgICBiZyA9IGdsb2JhbFNldHRpbmcuc2V0dGluZ3MuYmFja2dyb3VuZDtcbiAgICBpZiAoIWZnICYmIHRoZW1lPy5jb2xvcnM/LltcImVkaXRvci5mb3JlZ3JvdW5kXCJdKVxuICAgICAgZmcgPSB0aGVtZS5jb2xvcnNbXCJlZGl0b3IuZm9yZWdyb3VuZFwiXTtcbiAgICBpZiAoIWJnICYmIHRoZW1lPy5jb2xvcnM/LltcImVkaXRvci5iYWNrZ3JvdW5kXCJdKVxuICAgICAgYmcgPSB0aGVtZS5jb2xvcnNbXCJlZGl0b3IuYmFja2dyb3VuZFwiXTtcbiAgICBpZiAoIWZnKVxuICAgICAgZmcgPSB0aGVtZS50eXBlID09PSBcImxpZ2h0XCIgPyBWU0NPREVfRkFMTEJBQ0tfRURJVE9SX0ZHLmxpZ2h0IDogVlNDT0RFX0ZBTExCQUNLX0VESVRPUl9GRy5kYXJrO1xuICAgIGlmICghYmcpXG4gICAgICBiZyA9IHRoZW1lLnR5cGUgPT09IFwibGlnaHRcIiA/IFZTQ09ERV9GQUxMQkFDS19FRElUT1JfQkcubGlnaHQgOiBWU0NPREVfRkFMTEJBQ0tfRURJVE9SX0JHLmRhcms7XG4gICAgdGhlbWUuZmcgPSBmZztcbiAgICB0aGVtZS5iZyA9IGJnO1xuICB9XG4gIGlmICghKHRoZW1lLnNldHRpbmdzWzBdICYmIHRoZW1lLnNldHRpbmdzWzBdLnNldHRpbmdzICYmICF0aGVtZS5zZXR0aW5nc1swXS5zY29wZSkpIHtcbiAgICB0aGVtZS5zZXR0aW5ncy51bnNoaWZ0KHtcbiAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgIGZvcmVncm91bmQ6IHRoZW1lLmZnLFxuICAgICAgICBiYWNrZ3JvdW5kOiB0aGVtZS5iZ1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGxldCByZXBsYWNlbWVudENvdW50ID0gMDtcbiAgY29uc3QgcmVwbGFjZW1lbnRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiBnZXRSZXBsYWNlbWVudENvbG9yKHZhbHVlKSB7XG4gICAgaWYgKHJlcGxhY2VtZW50TWFwLmhhcyh2YWx1ZSkpXG4gICAgICByZXR1cm4gcmVwbGFjZW1lbnRNYXAuZ2V0KHZhbHVlKTtcbiAgICByZXBsYWNlbWVudENvdW50ICs9IDE7XG4gICAgY29uc3QgaGV4ID0gYCMke3JlcGxhY2VtZW50Q291bnQudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKS50b0xvd2VyQ2FzZSgpfWA7XG4gICAgaWYgKHRoZW1lLmNvbG9yUmVwbGFjZW1lbnRzPy5bYCMke2hleH1gXSlcbiAgICAgIHJldHVybiBnZXRSZXBsYWNlbWVudENvbG9yKHZhbHVlKTtcbiAgICByZXBsYWNlbWVudE1hcC5zZXQodmFsdWUsIGhleCk7XG4gICAgcmV0dXJuIGhleDtcbiAgfVxuICB0aGVtZS5zZXR0aW5ncyA9IHRoZW1lLnNldHRpbmdzLm1hcCgoc2V0dGluZykgPT4ge1xuICAgIGNvbnN0IHJlcGxhY2VGZyA9IHNldHRpbmcuc2V0dGluZ3M/LmZvcmVncm91bmQgJiYgIXNldHRpbmcuc2V0dGluZ3MuZm9yZWdyb3VuZC5zdGFydHNXaXRoKFwiI1wiKTtcbiAgICBjb25zdCByZXBsYWNlQmcgPSBzZXR0aW5nLnNldHRpbmdzPy5iYWNrZ3JvdW5kICYmICFzZXR0aW5nLnNldHRpbmdzLmJhY2tncm91bmQuc3RhcnRzV2l0aChcIiNcIik7XG4gICAgaWYgKCFyZXBsYWNlRmcgJiYgIXJlcGxhY2VCZylcbiAgICAgIHJldHVybiBzZXR0aW5nO1xuICAgIGNvbnN0IGNsb25lID0ge1xuICAgICAgLi4uc2V0dGluZyxcbiAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgIC4uLnNldHRpbmcuc2V0dGluZ3NcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChyZXBsYWNlRmcpIHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gZ2V0UmVwbGFjZW1lbnRDb2xvcihzZXR0aW5nLnNldHRpbmdzLmZvcmVncm91bmQpO1xuICAgICAgdGhlbWUuY29sb3JSZXBsYWNlbWVudHNbcmVwbGFjZW1lbnRdID0gc2V0dGluZy5zZXR0aW5ncy5mb3JlZ3JvdW5kO1xuICAgICAgY2xvbmUuc2V0dGluZ3MuZm9yZWdyb3VuZCA9IHJlcGxhY2VtZW50O1xuICAgIH1cbiAgICBpZiAocmVwbGFjZUJnKSB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudCA9IGdldFJlcGxhY2VtZW50Q29sb3Ioc2V0dGluZy5zZXR0aW5ncy5iYWNrZ3JvdW5kKTtcbiAgICAgIHRoZW1lLmNvbG9yUmVwbGFjZW1lbnRzW3JlcGxhY2VtZW50XSA9IHNldHRpbmcuc2V0dGluZ3MuYmFja2dyb3VuZDtcbiAgICAgIGNsb25lLnNldHRpbmdzLmJhY2tncm91bmQgPSByZXBsYWNlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xuICB9KTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhlbWUuY29sb3JzIHx8IHt9KSkge1xuICAgIGlmIChrZXkgPT09IFwiZWRpdG9yLmZvcmVncm91bmRcIiB8fCBrZXkgPT09IFwiZWRpdG9yLmJhY2tncm91bmRcIiB8fCBrZXkuc3RhcnRzV2l0aChcInRlcm1pbmFsLmFuc2lcIikpIHtcbiAgICAgIGlmICghdGhlbWUuY29sb3JzW2tleV0/LnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gZ2V0UmVwbGFjZW1lbnRDb2xvcih0aGVtZS5jb2xvcnNba2V5XSk7XG4gICAgICAgIHRoZW1lLmNvbG9yUmVwbGFjZW1lbnRzW3JlcGxhY2VtZW50XSA9IHRoZW1lLmNvbG9yc1trZXldO1xuICAgICAgICB0aGVtZS5jb2xvcnNba2V5XSA9IHJlcGxhY2VtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhlbWUsIFJFU09MVkVEX0tFWSwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIHRoZW1lO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlTGFuZ3MobGFuZ3MpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldCgoYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgbGFuZ3MuZmlsdGVyKChsKSA9PiAhaXNTcGVjaWFsTGFuZyhsKSkubWFwKGFzeW5jIChsYW5nKSA9PiBhd2FpdCBub3JtYWxpemVHZXR0ZXIobGFuZykudGhlbigocikgPT4gQXJyYXkuaXNBcnJheShyKSA/IHIgOiBbcl0pKVxuICApKS5mbGF0KCkpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVUaGVtZXModGhlbWVzKSB7XG4gIGNvbnN0IHJlc29sdmVkID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdGhlbWVzLm1hcChcbiAgICAgIGFzeW5jICh0aGVtZSkgPT4gaXNTcGVjaWFsVGhlbWUodGhlbWUpID8gbnVsbCA6IG5vcm1hbGl6ZVRoZW1lKGF3YWl0IG5vcm1hbGl6ZUdldHRlcih0aGVtZSkpXG4gICAgKVxuICApO1xuICByZXR1cm4gcmVzb2x2ZWQuZmlsdGVyKChpKSA9PiAhIWkpO1xufVxuXG5sZXQgX2VtaXREZXByZWNhdGlvbiA9IDM7XG5sZXQgX2VtaXRFcnJvciA9IGZhbHNlO1xuZnVuY3Rpb24gZW5hYmxlRGVwcmVjYXRpb25XYXJuaW5ncyhlbWl0RGVwcmVjYXRpb24gPSB0cnVlLCBlbWl0RXJyb3IgPSBmYWxzZSkge1xuICBfZW1pdERlcHJlY2F0aW9uID0gZW1pdERlcHJlY2F0aW9uO1xuICBfZW1pdEVycm9yID0gZW1pdEVycm9yO1xufVxuZnVuY3Rpb24gd2FybkRlcHJlY2F0ZWQobWVzc2FnZSwgdmVyc2lvbiA9IDMpIHtcbiAgaWYgKCFfZW1pdERlcHJlY2F0aW9uKVxuICAgIHJldHVybjtcbiAgaWYgKHR5cGVvZiBfZW1pdERlcHJlY2F0aW9uID09PSBcIm51bWJlclwiICYmIHZlcnNpb24gPiBfZW1pdERlcHJlY2F0aW9uKVxuICAgIHJldHVybjtcbiAgaWYgKF9lbWl0RXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFtTSElLSSBERVBSRUNBVEVdOiAke21lc3NhZ2V9YCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS50cmFjZShgW1NISUtJIERFUFJFQ0FURV06ICR7bWVzc2FnZX1gKTtcbiAgfVxufVxuXG5jbGFzcyBTaGlraUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJTaGlraUVycm9yXCI7XG4gIH1cbn1cblxuY2xhc3MgUmVnaXN0cnkgZXh0ZW5kcyBSZWdpc3RyeSQxIHtcbiAgY29uc3RydWN0b3IoX3Jlc29sdmVyLCBfdGhlbWVzLCBfbGFuZ3MsIF9hbGlhcyA9IHt9KSB7XG4gICAgc3VwZXIoX3Jlc29sdmVyKTtcbiAgICB0aGlzLl9yZXNvbHZlciA9IF9yZXNvbHZlcjtcbiAgICB0aGlzLl90aGVtZXMgPSBfdGhlbWVzO1xuICAgIHRoaXMuX2xhbmdzID0gX2xhbmdzO1xuICAgIHRoaXMuX2FsaWFzID0gX2FsaWFzO1xuICAgIHRoaXMuX3RoZW1lcy5tYXAoKHQpID0+IHRoaXMubG9hZFRoZW1lKHQpKTtcbiAgICB0aGlzLmxvYWRMYW5ndWFnZXModGhpcy5fbGFuZ3MpO1xuICB9XG4gIF9yZXNvbHZlZFRoZW1lcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIF9yZXNvbHZlZEdyYW1tYXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX2xhbmdNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfbGFuZ0dyYXBoID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX3RleHRtYXRlVGhlbWVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBfbG9hZGVkVGhlbWVzQ2FjaGUgPSBudWxsO1xuICBfbG9hZGVkTGFuZ3VhZ2VzQ2FjaGUgPSBudWxsO1xuICBnZXRUaGVtZSh0aGVtZSkge1xuICAgIGlmICh0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZWRUaGVtZXMuZ2V0KHRoZW1lKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpcy5sb2FkVGhlbWUodGhlbWUpO1xuICB9XG4gIGxvYWRUaGVtZSh0aGVtZSkge1xuICAgIGNvbnN0IF90aGVtZSA9IG5vcm1hbGl6ZVRoZW1lKHRoZW1lKTtcbiAgICBpZiAoX3RoZW1lLm5hbWUpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVkVGhlbWVzLnNldChfdGhlbWUubmFtZSwgX3RoZW1lKTtcbiAgICAgIHRoaXMuX2xvYWRlZFRoZW1lc0NhY2hlID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIF90aGVtZTtcbiAgfVxuICBnZXRMb2FkZWRUaGVtZXMoKSB7XG4gICAgaWYgKCF0aGlzLl9sb2FkZWRUaGVtZXNDYWNoZSlcbiAgICAgIHRoaXMuX2xvYWRlZFRoZW1lc0NhY2hlID0gWy4uLnRoaXMuX3Jlc29sdmVkVGhlbWVzLmtleXMoKV07XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRlZFRoZW1lc0NhY2hlO1xuICB9XG4gIC8vIE92ZXJyaWRlIGFuZCByZS1pbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gY2FjaGUgdGhlIHRleHRtYXRlIHRoZW1lcyBhcyBgVGV4dE1hdGVUaGVtZS5jcmVhdGVGcm9tUmF3VGhlbWVgXG4gIC8vIGlzIGV4cGVuc2l2ZS4gVGhlbWVzIGNhbiBzd2l0Y2ggb2Z0ZW4gZXNwZWNpYWxseSBmb3IgZHVhbC10aGVtZSBzdXBwb3J0LlxuICAvL1xuICAvLyBUaGUgcGFyZW50IGNsYXNzIGFsc28gYWNjZXB0cyBgY29sb3JNYXBgIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLCBidXQgc2luY2Ugd2UgZG9uJ3QgdXNlIHRoYXQsXG4gIC8vIHdlIG9taXQgaGVyZSBzbyBpdCdzIGVhc2llciB0byBjYWNoZSB0aGUgdGhlbWVzLlxuICBzZXRUaGVtZSh0aGVtZSkge1xuICAgIGxldCB0ZXh0bWF0ZVRoZW1lID0gdGhpcy5fdGV4dG1hdGVUaGVtZUNhY2hlLmdldCh0aGVtZSk7XG4gICAgaWYgKCF0ZXh0bWF0ZVRoZW1lKSB7XG4gICAgICB0ZXh0bWF0ZVRoZW1lID0gVGhlbWUuY3JlYXRlRnJvbVJhd1RoZW1lKHRoZW1lKTtcbiAgICAgIHRoaXMuX3RleHRtYXRlVGhlbWVDYWNoZS5zZXQodGhlbWUsIHRleHRtYXRlVGhlbWUpO1xuICAgIH1cbiAgICB0aGlzLl9zeW5jUmVnaXN0cnkuc2V0VGhlbWUodGV4dG1hdGVUaGVtZSk7XG4gIH1cbiAgZ2V0R3JhbW1hcihuYW1lKSB7XG4gICAgaWYgKHRoaXMuX2FsaWFzW25hbWVdKSB7XG4gICAgICBjb25zdCByZXNvbHZlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtuYW1lXSk7XG4gICAgICB3aGlsZSAodGhpcy5fYWxpYXNbbmFtZV0pIHtcbiAgICAgICAgbmFtZSA9IHRoaXMuX2FsaWFzW25hbWVdO1xuICAgICAgICBpZiAocmVzb2x2ZWQuaGFzKG5hbWUpKVxuICAgICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yKGBDaXJjdWxhciBhbGlhcyBcXGAke0FycmF5LmZyb20ocmVzb2x2ZWQpLmpvaW4oXCIgLT4gXCIpfSAtPiAke25hbWV9XFxgYCk7XG4gICAgICAgIHJlc29sdmVkLmFkZChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkR3JhbW1hcnMuZ2V0KG5hbWUpO1xuICB9XG4gIGxvYWRMYW5ndWFnZShsYW5nKSB7XG4gICAgaWYgKHRoaXMuZ2V0R3JhbW1hcihsYW5nLm5hbWUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGVtYmVkZGVkTGF6aWx5QnkgPSBuZXcgU2V0KFxuICAgICAgWy4uLnRoaXMuX2xhbmdNYXAudmFsdWVzKCldLmZpbHRlcigoaSkgPT4gaS5lbWJlZGRlZExhbmdzTGF6eT8uaW5jbHVkZXMobGFuZy5uYW1lKSlcbiAgICApO1xuICAgIHRoaXMuX3Jlc29sdmVyLmFkZExhbmd1YWdlKGxhbmcpO1xuICAgIGNvbnN0IGdyYW1tYXJDb25maWcgPSB7XG4gICAgICBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnM6IGxhbmcuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzIHx8IFtcIipcIl0sXG4gICAgICB1bmJhbGFuY2VkQnJhY2tldFNlbGVjdG9yczogbGFuZy51bmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycyB8fCBbXVxuICAgIH07XG4gICAgdGhpcy5fc3luY1JlZ2lzdHJ5Ll9yYXdHcmFtbWFycy5zZXQobGFuZy5zY29wZU5hbWUsIGxhbmcpO1xuICAgIGNvbnN0IGcgPSB0aGlzLmxvYWRHcmFtbWFyV2l0aENvbmZpZ3VyYXRpb24obGFuZy5zY29wZU5hbWUsIDEsIGdyYW1tYXJDb25maWcpO1xuICAgIGcubmFtZSA9IGxhbmcubmFtZTtcbiAgICB0aGlzLl9yZXNvbHZlZEdyYW1tYXJzLnNldChsYW5nLm5hbWUsIGcpO1xuICAgIGlmIChsYW5nLmFsaWFzZXMpIHtcbiAgICAgIGxhbmcuYWxpYXNlcy5mb3JFYWNoKChhbGlhcykgPT4ge1xuICAgICAgICB0aGlzLl9hbGlhc1thbGlhc10gPSBsYW5nLm5hbWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkTGFuZ3VhZ2VzQ2FjaGUgPSBudWxsO1xuICAgIGlmIChlbWJlZGRlZExhemlseUJ5LnNpemUpIHtcbiAgICAgIGZvciAoY29uc3QgZSBvZiBlbWJlZGRlZExhemlseUJ5KSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVkR3JhbW1hcnMuZGVsZXRlKGUubmFtZSk7XG4gICAgICAgIHRoaXMuX2xvYWRlZExhbmd1YWdlc0NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3luY1JlZ2lzdHJ5Py5faW5qZWN0aW9uR3JhbW1hcnM/LmRlbGV0ZShlLnNjb3BlTmFtZSk7XG4gICAgICAgIHRoaXMuX3N5bmNSZWdpc3RyeT8uX2dyYW1tYXJzPy5kZWxldGUoZS5zY29wZU5hbWUpO1xuICAgICAgICB0aGlzLmxvYWRMYW5ndWFnZSh0aGlzLl9sYW5nTWFwLmdldChlLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgdGhpcy5fcmVzb2x2ZWRUaGVtZXMuY2xlYXIoKTtcbiAgICB0aGlzLl9yZXNvbHZlZEdyYW1tYXJzLmNsZWFyKCk7XG4gICAgdGhpcy5fbGFuZ01hcC5jbGVhcigpO1xuICAgIHRoaXMuX2xhbmdHcmFwaC5jbGVhcigpO1xuICAgIHRoaXMuX2xvYWRlZFRoZW1lc0NhY2hlID0gbnVsbDtcbiAgfVxuICBsb2FkTGFuZ3VhZ2VzKGxhbmdzKSB7XG4gICAgZm9yIChjb25zdCBsYW5nIG9mIGxhbmdzKVxuICAgICAgdGhpcy5yZXNvbHZlRW1iZWRkZWRMYW5ndWFnZXMobGFuZyk7XG4gICAgY29uc3QgbGFuZ3NHcmFwaEFycmF5ID0gQXJyYXkuZnJvbSh0aGlzLl9sYW5nR3JhcGguZW50cmllcygpKTtcbiAgICBjb25zdCBtaXNzaW5nTGFuZ3MgPSBsYW5nc0dyYXBoQXJyYXkuZmlsdGVyKChbXywgbGFuZ10pID0+ICFsYW5nKTtcbiAgICBpZiAobWlzc2luZ0xhbmdzLmxlbmd0aCkge1xuICAgICAgY29uc3QgZGVwZW5kZW50cyA9IGxhbmdzR3JhcGhBcnJheS5maWx0ZXIoKFtfLCBsYW5nXSkgPT4gbGFuZyAmJiBsYW5nLmVtYmVkZGVkTGFuZ3M/LnNvbWUoKGwpID0+IG1pc3NpbmdMYW5ncy5tYXAoKFtuYW1lXSkgPT4gbmFtZSkuaW5jbHVkZXMobCkpKS5maWx0ZXIoKGxhbmcpID0+ICFtaXNzaW5nTGFuZ3MuaW5jbHVkZXMobGFuZykpO1xuICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IoYE1pc3NpbmcgbGFuZ3VhZ2VzICR7bWlzc2luZ0xhbmdzLm1hcCgoW25hbWVdKSA9PiBgXFxgJHtuYW1lfVxcYGApLmpvaW4oXCIsIFwiKX0sIHJlcXVpcmVkIGJ5ICR7ZGVwZW5kZW50cy5tYXAoKFtuYW1lXSkgPT4gYFxcYCR7bmFtZX1cXGBgKS5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW18sIGxhbmddIG9mIGxhbmdzR3JhcGhBcnJheSlcbiAgICAgIHRoaXMuX3Jlc29sdmVyLmFkZExhbmd1YWdlKGxhbmcpO1xuICAgIGZvciAoY29uc3QgW18sIGxhbmddIG9mIGxhbmdzR3JhcGhBcnJheSlcbiAgICAgIHRoaXMubG9hZExhbmd1YWdlKGxhbmcpO1xuICB9XG4gIGdldExvYWRlZExhbmd1YWdlcygpIHtcbiAgICBpZiAoIXRoaXMuX2xvYWRlZExhbmd1YWdlc0NhY2hlKSB7XG4gICAgICB0aGlzLl9sb2FkZWRMYW5ndWFnZXNDYWNoZSA9IFtcbiAgICAgICAgLi4uLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLnRoaXMuX3Jlc29sdmVkR3JhbW1hcnMua2V5cygpLCAuLi5PYmplY3Qua2V5cyh0aGlzLl9hbGlhcyldKVxuICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRlZExhbmd1YWdlc0NhY2hlO1xuICB9XG4gIHJlc29sdmVFbWJlZGRlZExhbmd1YWdlcyhsYW5nKSB7XG4gICAgdGhpcy5fbGFuZ01hcC5zZXQobGFuZy5uYW1lLCBsYW5nKTtcbiAgICB0aGlzLl9sYW5nR3JhcGguc2V0KGxhbmcubmFtZSwgbGFuZyk7XG4gICAgaWYgKGxhbmcuZW1iZWRkZWRMYW5ncykge1xuICAgICAgZm9yIChjb25zdCBlbWJlZGRlZExhbmcgb2YgbGFuZy5lbWJlZGRlZExhbmdzKVxuICAgICAgICB0aGlzLl9sYW5nR3JhcGguc2V0KGVtYmVkZGVkTGFuZywgdGhpcy5fbGFuZ01hcC5nZXQoZW1iZWRkZWRMYW5nKSk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFJlc29sdmVyIHtcbiAgX2xhbmdzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX3Njb3BlVG9MYW5nID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX2luamVjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfb25pZ0xpYjtcbiAgY29uc3RydWN0b3IoZW5naW5lLCBsYW5ncykge1xuICAgIHRoaXMuX29uaWdMaWIgPSB7XG4gICAgICBjcmVhdGVPbmlnU2Nhbm5lcjogKHBhdHRlcm5zKSA9PiBlbmdpbmUuY3JlYXRlU2Nhbm5lcihwYXR0ZXJucyksXG4gICAgICBjcmVhdGVPbmlnU3RyaW5nOiAocykgPT4gZW5naW5lLmNyZWF0ZVN0cmluZyhzKVxuICAgIH07XG4gICAgbGFuZ3MuZm9yRWFjaCgoaSkgPT4gdGhpcy5hZGRMYW5ndWFnZShpKSk7XG4gIH1cbiAgZ2V0IG9uaWdMaWIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uaWdMaWI7XG4gIH1cbiAgZ2V0TGFuZ1JlZ2lzdHJhdGlvbihsYW5nSWRPckFsaWFzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhbmdzLmdldChsYW5nSWRPckFsaWFzKTtcbiAgfVxuICBsb2FkR3JhbW1hcihzY29wZU5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fc2NvcGVUb0xhbmcuZ2V0KHNjb3BlTmFtZSk7XG4gIH1cbiAgYWRkTGFuZ3VhZ2UobCkge1xuICAgIHRoaXMuX2xhbmdzLnNldChsLm5hbWUsIGwpO1xuICAgIGlmIChsLmFsaWFzZXMpIHtcbiAgICAgIGwuYWxpYXNlcy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIHRoaXMuX2xhbmdzLnNldChhLCBsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9zY29wZVRvTGFuZy5zZXQobC5zY29wZU5hbWUsIGwpO1xuICAgIGlmIChsLmluamVjdFRvKSB7XG4gICAgICBsLmluamVjdFRvLmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLl9pbmplY3Rpb25zLmdldChpKSlcbiAgICAgICAgICB0aGlzLl9pbmplY3Rpb25zLnNldChpLCBbXSk7XG4gICAgICAgIHRoaXMuX2luamVjdGlvbnMuZ2V0KGkpLnB1c2gobC5zY29wZU5hbWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldEluamVjdGlvbnMoc2NvcGVOYW1lKSB7XG4gICAgY29uc3Qgc2NvcGVQYXJ0cyA9IHNjb3BlTmFtZS5zcGxpdChcIi5cIik7XG4gICAgbGV0IGluamVjdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBzY29wZVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdWJTY29wZU5hbWUgPSBzY29wZVBhcnRzLnNsaWNlKDAsIGkpLmpvaW4oXCIuXCIpO1xuICAgICAgaW5qZWN0aW9ucyA9IFsuLi5pbmplY3Rpb25zLCAuLi50aGlzLl9pbmplY3Rpb25zLmdldChzdWJTY29wZU5hbWUpIHx8IFtdXTtcbiAgICB9XG4gICAgcmV0dXJuIGluamVjdGlvbnM7XG4gIH1cbn1cblxubGV0IGluc3RhbmNlc0NvdW50ID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZVNoaWtpSW50ZXJuYWxTeW5jKG9wdGlvbnMpIHtcbiAgaW5zdGFuY2VzQ291bnQgKz0gMTtcbiAgaWYgKG9wdGlvbnMud2FybmluZ3MgIT09IGZhbHNlICYmIGluc3RhbmNlc0NvdW50ID49IDEwICYmIGluc3RhbmNlc0NvdW50ICUgMTAgPT09IDApXG4gICAgY29uc29sZS53YXJuKGBbU2hpa2ldICR7aW5zdGFuY2VzQ291bnR9IGluc3RhbmNlcyBoYXZlIGJlZW4gY3JlYXRlZC4gU2hpa2kgaXMgc3VwcG9zZWQgdG8gYmUgdXNlZCBhcyBhIHNpbmdsZXRvbiwgY29uc2lkZXIgcmVmYWN0b3JpbmcgeW91ciBjb2RlIHRvIGNhY2hlIHlvdXIgaGlnaGxpZ2h0ZXIgaW5zdGFuY2U7IE9yIGNhbGwgXFxgaGlnaGxpZ2h0ZXIuZGlzcG9zZSgpXFxgIHRvIHJlbGVhc2UgdW51c2VkIGluc3RhbmNlcy5gKTtcbiAgbGV0IGlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgaWYgKCFvcHRpb25zLmVuZ2luZSlcbiAgICB0aHJvdyBuZXcgU2hpa2lFcnJvcihcImBlbmdpbmVgIG9wdGlvbiBpcyByZXF1aXJlZCBmb3Igc3luY2hyb25vdXMgbW9kZVwiKTtcbiAgY29uc3QgbGFuZ3MgPSAob3B0aW9ucy5sYW5ncyB8fCBbXSkuZmxhdCgxKTtcbiAgY29uc3QgdGhlbWVzID0gKG9wdGlvbnMudGhlbWVzIHx8IFtdKS5mbGF0KDEpLm1hcChub3JtYWxpemVUaGVtZSk7XG4gIGNvbnN0IHJlc29sdmVyID0gbmV3IFJlc29sdmVyKG9wdGlvbnMuZW5naW5lLCBsYW5ncyk7XG4gIGNvbnN0IF9yZWdpc3RyeSA9IG5ldyBSZWdpc3RyeShyZXNvbHZlciwgdGhlbWVzLCBsYW5ncywgb3B0aW9ucy5sYW5nQWxpYXMpO1xuICBsZXQgX2xhc3RUaGVtZTtcbiAgZnVuY3Rpb24gZ2V0TGFuZ3VhZ2UobmFtZSkge1xuICAgIGVuc3VyZU5vdERpc3Bvc2VkKCk7XG4gICAgY29uc3QgX2xhbmcgPSBfcmVnaXN0cnkuZ2V0R3JhbW1hcih0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiA/IG5hbWUgOiBuYW1lLm5hbWUpO1xuICAgIGlmICghX2xhbmcpXG4gICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvcihgTGFuZ3VhZ2UgXFxgJHtuYW1lfVxcYCBub3QgZm91bmQsIHlvdSBtYXkgbmVlZCB0byBsb2FkIGl0IGZpcnN0YCk7XG4gICAgcmV0dXJuIF9sYW5nO1xuICB9XG4gIGZ1bmN0aW9uIGdldFRoZW1lKG5hbWUpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJub25lXCIpXG4gICAgICByZXR1cm4geyBiZzogXCJcIiwgZmc6IFwiXCIsIG5hbWU6IFwibm9uZVwiLCBzZXR0aW5nczogW10sIHR5cGU6IFwiZGFya1wiIH07XG4gICAgZW5zdXJlTm90RGlzcG9zZWQoKTtcbiAgICBjb25zdCBfdGhlbWUgPSBfcmVnaXN0cnkuZ2V0VGhlbWUobmFtZSk7XG4gICAgaWYgKCFfdGhlbWUpXG4gICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvcihgVGhlbWUgXFxgJHtuYW1lfVxcYCBub3QgZm91bmQsIHlvdSBtYXkgbmVlZCB0byBsb2FkIGl0IGZpcnN0YCk7XG4gICAgcmV0dXJuIF90aGVtZTtcbiAgfVxuICBmdW5jdGlvbiBzZXRUaGVtZShuYW1lKSB7XG4gICAgZW5zdXJlTm90RGlzcG9zZWQoKTtcbiAgICBjb25zdCB0aGVtZSA9IGdldFRoZW1lKG5hbWUpO1xuICAgIGlmIChfbGFzdFRoZW1lICE9PSBuYW1lKSB7XG4gICAgICBfcmVnaXN0cnkuc2V0VGhlbWUodGhlbWUpO1xuICAgICAgX2xhc3RUaGVtZSA9IG5hbWU7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yTWFwID0gX3JlZ2lzdHJ5LmdldENvbG9yTWFwKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRoZW1lLFxuICAgICAgY29sb3JNYXBcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldExvYWRlZFRoZW1lcygpIHtcbiAgICBlbnN1cmVOb3REaXNwb3NlZCgpO1xuICAgIHJldHVybiBfcmVnaXN0cnkuZ2V0TG9hZGVkVGhlbWVzKCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TG9hZGVkTGFuZ3VhZ2VzKCkge1xuICAgIGVuc3VyZU5vdERpc3Bvc2VkKCk7XG4gICAgcmV0dXJuIF9yZWdpc3RyeS5nZXRMb2FkZWRMYW5ndWFnZXMoKTtcbiAgfVxuICBmdW5jdGlvbiBsb2FkTGFuZ3VhZ2VTeW5jKC4uLmxhbmdzMikge1xuICAgIGVuc3VyZU5vdERpc3Bvc2VkKCk7XG4gICAgX3JlZ2lzdHJ5LmxvYWRMYW5ndWFnZXMobGFuZ3MyLmZsYXQoMSkpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWRMYW5ndWFnZSguLi5sYW5nczIpIHtcbiAgICByZXR1cm4gbG9hZExhbmd1YWdlU3luYyhhd2FpdCByZXNvbHZlTGFuZ3MobGFuZ3MyKSk7XG4gIH1cbiAgZnVuY3Rpb24gbG9hZFRoZW1lU3luYyguLi50aGVtZXMyKSB7XG4gICAgZW5zdXJlTm90RGlzcG9zZWQoKTtcbiAgICBmb3IgKGNvbnN0IHRoZW1lIG9mIHRoZW1lczIuZmxhdCgxKSkge1xuICAgICAgX3JlZ2lzdHJ5LmxvYWRUaGVtZSh0aGVtZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWRUaGVtZSguLi50aGVtZXMyKSB7XG4gICAgZW5zdXJlTm90RGlzcG9zZWQoKTtcbiAgICByZXR1cm4gbG9hZFRoZW1lU3luYyhhd2FpdCByZXNvbHZlVGhlbWVzKHRoZW1lczIpKTtcbiAgfVxuICBmdW5jdGlvbiBlbnN1cmVOb3REaXNwb3NlZCgpIHtcbiAgICBpZiAoaXNEaXNwb3NlZClcbiAgICAgIHRocm93IG5ldyBTaGlraUVycm9yKFwiU2hpa2kgaW5zdGFuY2UgaGFzIGJlZW4gZGlzcG9zZWRcIik7XG4gIH1cbiAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBpZiAoaXNEaXNwb3NlZClcbiAgICAgIHJldHVybjtcbiAgICBpc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICBfcmVnaXN0cnkuZGlzcG9zZSgpO1xuICAgIGluc3RhbmNlc0NvdW50IC09IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzZXRUaGVtZSxcbiAgICBnZXRUaGVtZSxcbiAgICBnZXRMYW5ndWFnZSxcbiAgICBnZXRMb2FkZWRUaGVtZXMsXG4gICAgZ2V0TG9hZGVkTGFuZ3VhZ2VzLFxuICAgIGxvYWRMYW5ndWFnZSxcbiAgICBsb2FkTGFuZ3VhZ2VTeW5jLFxuICAgIGxvYWRUaGVtZSxcbiAgICBsb2FkVGhlbWVTeW5jLFxuICAgIGRpc3Bvc2UsXG4gICAgW1N5bWJvbC5kaXNwb3NlXTogZGlzcG9zZVxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVTaGlraUludGVybmFsKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zLmVuZ2luZSkge1xuICAgIHdhcm5EZXByZWNhdGVkKFwiYGVuZ2luZWAgb3B0aW9uIGlzIHJlcXVpcmVkLiBVc2UgYGNyZWF0ZU9uaWd1cnVtYUVuZ2luZWAgb3IgYGNyZWF0ZUphdmFTY3JpcHRSZWdleEVuZ2luZWAgdG8gY3JlYXRlIGFuIGVuZ2luZS5cIik7XG4gIH1cbiAgY29uc3QgW1xuICAgIHRoZW1lcyxcbiAgICBsYW5ncyxcbiAgICBlbmdpbmVcbiAgXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICByZXNvbHZlVGhlbWVzKG9wdGlvbnMudGhlbWVzIHx8IFtdKSxcbiAgICByZXNvbHZlTGFuZ3Mob3B0aW9ucy5sYW5ncyB8fCBbXSksXG4gICAgb3B0aW9ucy5lbmdpbmVcbiAgXSk7XG4gIHJldHVybiBjcmVhdGVTaGlraUludGVybmFsU3luYyh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0aGVtZXMsXG4gICAgbGFuZ3MsXG4gICAgZW5naW5lXG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVIaWdobGlnaHRlckNvcmUob3B0aW9ucykge1xuICBjb25zdCBpbnRlcm5hbCA9IGF3YWl0IGNyZWF0ZVNoaWtpSW50ZXJuYWwob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgZ2V0TGFzdEdyYW1tYXJTdGF0ZTogKC4uLmFyZ3MpID0+IGdldExhc3RHcmFtbWFyU3RhdGUoaW50ZXJuYWwsIC4uLmFyZ3MpLFxuICAgIGNvZGVUb1Rva2Vuc0Jhc2U6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvVG9rZW5zQmFzZShpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGNvZGVUb1Rva2Vuc1dpdGhUaGVtZXM6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvVG9rZW5zV2l0aFRoZW1lcyhpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGNvZGVUb1Rva2VuczogKGNvZGUsIG9wdGlvbnMyKSA9PiBjb2RlVG9Ub2tlbnMoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBjb2RlVG9IYXN0OiAoY29kZSwgb3B0aW9uczIpID0+IGNvZGVUb0hhc3QoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBjb2RlVG9IdG1sOiAoY29kZSwgb3B0aW9uczIpID0+IGNvZGVUb0h0bWwoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBnZXRCdW5kbGVkTGFuZ3VhZ2VzOiAoKSA9PiAoe30pLFxuICAgIGdldEJ1bmRsZWRUaGVtZXM6ICgpID0+ICh7fSksXG4gICAgLi4uaW50ZXJuYWwsXG4gICAgZ2V0SW50ZXJuYWxDb250ZXh0OiAoKSA9PiBpbnRlcm5hbFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSGlnaGxpZ2h0ZXJDb3JlU3luYyhvcHRpb25zKSB7XG4gIGNvbnN0IGludGVybmFsID0gY3JlYXRlU2hpa2lJbnRlcm5hbFN5bmMob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgZ2V0TGFzdEdyYW1tYXJTdGF0ZTogKC4uLmFyZ3MpID0+IGdldExhc3RHcmFtbWFyU3RhdGUoaW50ZXJuYWwsIC4uLmFyZ3MpLFxuICAgIGNvZGVUb1Rva2Vuc0Jhc2U6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvVG9rZW5zQmFzZShpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGNvZGVUb1Rva2Vuc1dpdGhUaGVtZXM6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvVG9rZW5zV2l0aFRoZW1lcyhpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGNvZGVUb1Rva2VuczogKGNvZGUsIG9wdGlvbnMyKSA9PiBjb2RlVG9Ub2tlbnMoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBjb2RlVG9IYXN0OiAoY29kZSwgb3B0aW9uczIpID0+IGNvZGVUb0hhc3QoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBjb2RlVG9IdG1sOiAoY29kZSwgb3B0aW9uczIpID0+IGNvZGVUb0h0bWwoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBnZXRCdW5kbGVkTGFuZ3VhZ2VzOiAoKSA9PiAoe30pLFxuICAgIGdldEJ1bmRsZWRUaGVtZXM6ICgpID0+ICh7fSksXG4gICAgLi4uaW50ZXJuYWwsXG4gICAgZ2V0SW50ZXJuYWxDb250ZXh0OiAoKSA9PiBpbnRlcm5hbFxuICB9O1xufVxuZnVuY3Rpb24gbWFrZVNpbmdsZXRvbkhpZ2hsaWdodGVyQ29yZShjcmVhdGVIaWdobGlnaHRlcikge1xuICBsZXQgX3NoaWtpO1xuICBhc3luYyBmdW5jdGlvbiBnZXRTaW5nbGV0b25IaWdobGlnaHRlckNvcmUyKG9wdGlvbnMpIHtcbiAgICBpZiAoIV9zaGlraSkge1xuICAgICAgX3NoaWtpID0gY3JlYXRlSGlnaGxpZ2h0ZXIoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB0aGVtZXM6IG9wdGlvbnMudGhlbWVzIHx8IFtdLFxuICAgICAgICBsYW5nczogb3B0aW9ucy5sYW5ncyB8fCBbXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gX3NoaWtpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzID0gYXdhaXQgX3NoaWtpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBzLmxvYWRUaGVtZSguLi5vcHRpb25zLnRoZW1lcyB8fCBbXSksXG4gICAgICAgIHMubG9hZExhbmd1YWdlKC4uLm9wdGlvbnMubGFuZ3MgfHwgW10pXG4gICAgICBdKTtcbiAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXJDb3JlMjtcbn1cbmNvbnN0IGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyQ29yZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlU2luZ2xldG9uSGlnaGxpZ2h0ZXJDb3JlKGNyZWF0ZUhpZ2hsaWdodGVyQ29yZSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZWRCdW5kbGVkSGlnaGxpZ2h0ZXIob3B0aW9ucykge1xuICBjb25zdCBidW5kbGVkTGFuZ3VhZ2VzID0gb3B0aW9ucy5sYW5ncztcbiAgY29uc3QgYnVuZGxlZFRoZW1lcyA9IG9wdGlvbnMudGhlbWVzO1xuICBjb25zdCBlbmdpbmUgPSBvcHRpb25zLmVuZ2luZTtcbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlSGlnaGxpZ2h0ZXIob3B0aW9uczIpIHtcbiAgICBmdW5jdGlvbiByZXNvbHZlTGFuZyhsYW5nKSB7XG4gICAgICBpZiAodHlwZW9mIGxhbmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGlzU3BlY2lhbExhbmcobGFuZykpXG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsYW5nID0gb3B0aW9uczIubGFuZ0FsaWFzPy5bbGFuZ10gfHwgbGFuZztcbiAgICAgICAgY29uc3QgYnVuZGxlID0gYnVuZGxlZExhbmd1YWdlc1tsYW5nXTtcbiAgICAgICAgaWYgKCFidW5kbGUpXG4gICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgTGFuZ3VhZ2UgXFxgJHtsYW5nfVxcYCBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBidW5kbGUuIFlvdSBtYXkgd2FudCB0byBsb2FkIGl0IGZyb20gZXh0ZXJuYWwgc291cmNlLmApO1xuICAgICAgICByZXR1cm4gYnVuZGxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhbmc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVUaGVtZSh0aGVtZSkge1xuICAgICAgaWYgKGlzU3BlY2lhbFRoZW1lKHRoZW1lKSlcbiAgICAgICAgcmV0dXJuIFwibm9uZVwiO1xuICAgICAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBidW5kbGUgPSBidW5kbGVkVGhlbWVzW3RoZW1lXTtcbiAgICAgICAgaWYgKCFidW5kbGUpXG4gICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgVGhlbWUgXFxgJHt0aGVtZX1cXGAgaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYnVuZGxlLiBZb3UgbWF5IHdhbnQgdG8gbG9hZCBpdCBmcm9tIGV4dGVybmFsIHNvdXJjZS5gKTtcbiAgICAgICAgcmV0dXJuIGJ1bmRsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGVtZTtcbiAgICB9XG4gICAgY29uc3QgX3RoZW1lcyA9IChvcHRpb25zMi50aGVtZXMgPz8gW10pLm1hcCgoaSkgPT4gcmVzb2x2ZVRoZW1lKGkpKTtcbiAgICBjb25zdCBsYW5ncyA9IChvcHRpb25zMi5sYW5ncyA/PyBbXSkubWFwKChpKSA9PiByZXNvbHZlTGFuZyhpKSk7XG4gICAgY29uc3QgY29yZSA9IGF3YWl0IGNyZWF0ZUhpZ2hsaWdodGVyQ29yZSh7XG4gICAgICBlbmdpbmU6IG9wdGlvbnMyLmVuZ2luZSA/PyBlbmdpbmUoKSxcbiAgICAgIC4uLm9wdGlvbnMyLFxuICAgICAgdGhlbWVzOiBfdGhlbWVzLFxuICAgICAgbGFuZ3NcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29yZSxcbiAgICAgIGxvYWRMYW5ndWFnZSguLi5sYW5nczIpIHtcbiAgICAgICAgcmV0dXJuIGNvcmUubG9hZExhbmd1YWdlKC4uLmxhbmdzMi5tYXAocmVzb2x2ZUxhbmcpKTtcbiAgICAgIH0sXG4gICAgICBsb2FkVGhlbWUoLi4udGhlbWVzKSB7XG4gICAgICAgIHJldHVybiBjb3JlLmxvYWRUaGVtZSguLi50aGVtZXMubWFwKHJlc29sdmVUaGVtZSkpO1xuICAgICAgfSxcbiAgICAgIGdldEJ1bmRsZWRMYW5ndWFnZXMoKSB7XG4gICAgICAgIHJldHVybiBidW5kbGVkTGFuZ3VhZ2VzO1xuICAgICAgfSxcbiAgICAgIGdldEJ1bmRsZWRUaGVtZXMoKSB7XG4gICAgICAgIHJldHVybiBidW5kbGVkVGhlbWVzO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUhpZ2hsaWdodGVyO1xufVxuZnVuY3Rpb24gbWFrZVNpbmdsZXRvbkhpZ2hsaWdodGVyKGNyZWF0ZUhpZ2hsaWdodGVyKSB7XG4gIGxldCBfc2hpa2k7XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghX3NoaWtpKSB7XG4gICAgICBfc2hpa2kgPSBjcmVhdGVIaWdobGlnaHRlcih7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHRoZW1lczogb3B0aW9ucy50aGVtZXMgfHwgW10sXG4gICAgICAgIGxhbmdzOiBvcHRpb25zLmxhbmdzIHx8IFtdXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfc2hpa2k7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHMgPSBhd2FpdCBfc2hpa2k7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIHMubG9hZFRoZW1lKC4uLm9wdGlvbnMudGhlbWVzIHx8IFtdKSxcbiAgICAgICAgcy5sb2FkTGFuZ3VhZ2UoLi4ub3B0aW9ucy5sYW5ncyB8fCBbXSlcbiAgICAgIF0pO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZXRTaW5nbGV0b25IaWdobGlnaHRlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNpbmdsZXRvblNob3J0aGFuZHMoY3JlYXRlSGlnaGxpZ2h0ZXIsIGNvbmZpZykge1xuICBjb25zdCBnZXRTaW5nbGV0b25IaWdobGlnaHRlciA9IG1ha2VTaW5nbGV0b25IaWdobGlnaHRlcihjcmVhdGVIaWdobGlnaHRlcik7XG4gIGFzeW5jIGZ1bmN0aW9uIGdldChjb2RlLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc2hpa2kgPSBhd2FpdCBnZXRTaW5nbGV0b25IaWdobGlnaHRlcih7XG4gICAgICBsYW5nczogW29wdGlvbnMubGFuZ10sXG4gICAgICB0aGVtZXM6IFwidGhlbWVcIiBpbiBvcHRpb25zID8gW29wdGlvbnMudGhlbWVdIDogT2JqZWN0LnZhbHVlcyhvcHRpb25zLnRoZW1lcylcbiAgICB9KTtcbiAgICBjb25zdCBsYW5ncyA9IGF3YWl0IGNvbmZpZz8uZ3Vlc3NFbWJlZGRlZExhbmd1YWdlcz8uKGNvZGUsIG9wdGlvbnMubGFuZywgc2hpa2kpO1xuICAgIGlmIChsYW5ncykge1xuICAgICAgYXdhaXQgc2hpa2kubG9hZExhbmd1YWdlKC4uLmxhbmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoaWtpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXIob3B0aW9ucykge1xuICAgICAgcmV0dXJuIGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyKG9wdGlvbnMpO1xuICAgIH0sXG4gICAgYXN5bmMgY29kZVRvSHRtbChjb2RlLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBzaGlraSA9IGF3YWl0IGdldChjb2RlLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBzaGlraS5jb2RlVG9IdG1sKGNvZGUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgYXN5bmMgY29kZVRvSGFzdChjb2RlLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBzaGlraSA9IGF3YWl0IGdldChjb2RlLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBzaGlraS5jb2RlVG9IYXN0KGNvZGUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgYXN5bmMgY29kZVRvVG9rZW5zKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHNoaWtpID0gYXdhaXQgZ2V0KGNvZGUsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHNoaWtpLmNvZGVUb1Rva2Vucyhjb2RlLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGFzeW5jIGNvZGVUb1Rva2Vuc0Jhc2UoY29kZSwgb3B0aW9ucykge1xuICAgICAgY29uc3Qgc2hpa2kgPSBhd2FpdCBnZXQoY29kZSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gc2hpa2kuY29kZVRvVG9rZW5zQmFzZShjb2RlLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGFzeW5jIGNvZGVUb1Rva2Vuc1dpdGhUaGVtZXMoY29kZSwgb3B0aW9ucykge1xuICAgICAgY29uc3Qgc2hpa2kgPSBhd2FpdCBnZXQoY29kZSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gc2hpa2kuY29kZVRvVG9rZW5zV2l0aFRoZW1lcyhjb2RlLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGFzeW5jIGdldExhc3RHcmFtbWFyU3RhdGUoY29kZSwgb3B0aW9ucykge1xuICAgICAgY29uc3Qgc2hpa2kgPSBhd2FpdCBnZXRTaW5nbGV0b25IaWdobGlnaHRlcih7XG4gICAgICAgIGxhbmdzOiBbb3B0aW9ucy5sYW5nXSxcbiAgICAgICAgdGhlbWVzOiBbb3B0aW9ucy50aGVtZV1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNoaWtpLmdldExhc3RHcmFtbWFyU3RhdGUoY29kZSwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDc3NWYXJpYWJsZXNUaGVtZShvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIG5hbWUgPSBcImNzcy12YXJpYWJsZXNcIixcbiAgICB2YXJpYWJsZVByZWZpeCA9IFwiLS1zaGlraS1cIixcbiAgICBmb250U3R5bGUgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB2YXJpYWJsZSA9IChuYW1lMikgPT4ge1xuICAgIGlmIChvcHRpb25zLnZhcmlhYmxlRGVmYXVsdHM/LltuYW1lMl0pXG4gICAgICByZXR1cm4gYHZhcigke3ZhcmlhYmxlUHJlZml4fSR7bmFtZTJ9LCAke29wdGlvbnMudmFyaWFibGVEZWZhdWx0c1tuYW1lMl19KWA7XG4gICAgcmV0dXJuIGB2YXIoJHt2YXJpYWJsZVByZWZpeH0ke25hbWUyfSlgO1xuICB9O1xuICBjb25zdCB0aGVtZSA9IHtcbiAgICBuYW1lLFxuICAgIHR5cGU6IFwiZGFya1wiLFxuICAgIGNvbG9yczoge1xuICAgICAgXCJlZGl0b3IuZm9yZWdyb3VuZFwiOiB2YXJpYWJsZShcImZvcmVncm91bmRcIiksXG4gICAgICBcImVkaXRvci5iYWNrZ3JvdW5kXCI6IHZhcmlhYmxlKFwiYmFja2dyb3VuZFwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJsYWNrXCI6IHZhcmlhYmxlKFwiYW5zaS1ibGFja1wiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaVJlZFwiOiB2YXJpYWJsZShcImFuc2ktcmVkXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpR3JlZW5cIjogdmFyaWFibGUoXCJhbnNpLWdyZWVuXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpWWVsbG93XCI6IHZhcmlhYmxlKFwiYW5zaS15ZWxsb3dcIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lCbHVlXCI6IHZhcmlhYmxlKFwiYW5zaS1ibHVlXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpTWFnZW50YVwiOiB2YXJpYWJsZShcImFuc2ktbWFnZW50YVwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUN5YW5cIjogdmFyaWFibGUoXCJhbnNpLWN5YW5cIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lXaGl0ZVwiOiB2YXJpYWJsZShcImFuc2ktd2hpdGVcIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lCcmlnaHRCbGFja1wiOiB2YXJpYWJsZShcImFuc2ktYnJpZ2h0LWJsYWNrXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpQnJpZ2h0UmVkXCI6IHZhcmlhYmxlKFwiYW5zaS1icmlnaHQtcmVkXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpQnJpZ2h0R3JlZW5cIjogdmFyaWFibGUoXCJhbnNpLWJyaWdodC1ncmVlblwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJyaWdodFllbGxvd1wiOiB2YXJpYWJsZShcImFuc2ktYnJpZ2h0LXllbGxvd1wiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJyaWdodEJsdWVcIjogdmFyaWFibGUoXCJhbnNpLWJyaWdodC1ibHVlXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpQnJpZ2h0TWFnZW50YVwiOiB2YXJpYWJsZShcImFuc2ktYnJpZ2h0LW1hZ2VudGFcIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lCcmlnaHRDeWFuXCI6IHZhcmlhYmxlKFwiYW5zaS1icmlnaHQtY3lhblwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJyaWdodFdoaXRlXCI6IHZhcmlhYmxlKFwiYW5zaS1icmlnaHQtd2hpdGVcIilcbiAgICB9LFxuICAgIHRva2VuQ29sb3JzOiBbXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJrZXl3b3JkLm9wZXJhdG9yLmFjY2Vzc29yXCIsXG4gICAgICAgICAgXCJtZXRhLmdyb3VwLmJyYWNlcy5yb3VuZC5mdW5jdGlvbi5hcmd1bWVudHNcIixcbiAgICAgICAgICBcIm1ldGEudGVtcGxhdGUuZXhwcmVzc2lvblwiLFxuICAgICAgICAgIFwibWFya3VwLmZlbmNlZF9jb2RlIG1ldGEuZW1iZWRkZWQuYmxvY2tcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwiZm9yZWdyb3VuZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogXCJlbXBoYXNpc1wiLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1wic3Ryb25nXCIsIFwibWFya3VwLmhlYWRpbmcubWFya2Rvd25cIiwgXCJtYXJrdXAuYm9sZC5tYXJrZG93blwiXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb250U3R5bGU6IFwiYm9sZFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBbXCJtYXJrdXAuaXRhbGljLm1hcmtkb3duXCJdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogXCJtZXRhLmxpbmsuaW5saW5lLm1hcmtkb3duXCIsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9udFN0eWxlOiBcInVuZGVybGluZVwiLFxuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tbGlua1wiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1wic3RyaW5nXCIsIFwibWFya3VwLmZlbmNlZF9jb2RlXCIsIFwibWFya3VwLmlubGluZVwiXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLXN0cmluZ1wiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1wiY29tbWVudFwiLCBcInN0cmluZy5xdW90ZWQuZG9jc3RyaW5nLm11bHRpXCJdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tY29tbWVudFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwiY29uc3RhbnQubnVtZXJpY1wiLFxuICAgICAgICAgIFwiY29uc3RhbnQubGFuZ3VhZ2VcIixcbiAgICAgICAgICBcImNvbnN0YW50Lm90aGVyLnBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgXCJjb25zdGFudC5jaGFyYWN0ZXIuZm9ybWF0LnBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgXCJ2YXJpYWJsZS5sYW5ndWFnZS50aGlzXCIsXG4gICAgICAgICAgXCJ2YXJpYWJsZS5vdGhlci5vYmplY3RcIixcbiAgICAgICAgICBcInZhcmlhYmxlLm90aGVyLmNsYXNzXCIsXG4gICAgICAgICAgXCJ2YXJpYWJsZS5vdGhlci5jb25zdGFudFwiLFxuICAgICAgICAgIFwibWV0YS5wcm9wZXJ0eS1uYW1lXCIsXG4gICAgICAgICAgXCJtZXRhLnByb3BlcnR5LXZhbHVlXCIsXG4gICAgICAgICAgXCJzdXBwb3J0XCJcbiAgICAgICAgXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLWNvbnN0YW50XCIpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJrZXl3b3JkXCIsXG4gICAgICAgICAgXCJzdG9yYWdlLm1vZGlmaWVyXCIsXG4gICAgICAgICAgXCJzdG9yYWdlLnR5cGVcIixcbiAgICAgICAgICBcInN0b3JhZ2UuY29udHJvbC5jbG9qdXJlXCIsXG4gICAgICAgICAgXCJlbnRpdHkubmFtZS5mdW5jdGlvbi5jbG9qdXJlXCIsXG4gICAgICAgICAgXCJlbnRpdHkubmFtZS50YWcueWFtbFwiLFxuICAgICAgICAgIFwic3VwcG9ydC5mdW5jdGlvbi5ub2RlXCIsXG4gICAgICAgICAgXCJzdXBwb3J0LnR5cGUucHJvcGVydHktbmFtZS5qc29uXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5zZXBhcmF0b3Iua2V5LXZhbHVlXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnRlbXBsYXRlLWV4cHJlc3Npb25cIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4ta2V5d29yZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogXCJ2YXJpYWJsZS5wYXJhbWV0ZXIuZnVuY3Rpb25cIixcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLXBhcmFtZXRlclwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwic3VwcG9ydC5mdW5jdGlvblwiLFxuICAgICAgICAgIFwiZW50aXR5Lm5hbWUudHlwZVwiLFxuICAgICAgICAgIFwiZW50aXR5Lm90aGVyLmluaGVyaXRlZC1jbGFzc1wiLFxuICAgICAgICAgIFwibWV0YS5mdW5jdGlvbi1jYWxsXCIsXG4gICAgICAgICAgXCJtZXRhLmluc3RhbmNlLmNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgXCJlbnRpdHkub3RoZXIuYXR0cmlidXRlLW5hbWVcIixcbiAgICAgICAgICBcImVudGl0eS5uYW1lLmZ1bmN0aW9uXCIsXG4gICAgICAgICAgXCJjb25zdGFudC5rZXl3b3JkLmNsb2p1cmVcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tZnVuY3Rpb25cIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFtcbiAgICAgICAgICBcImVudGl0eS5uYW1lLnRhZ1wiLFxuICAgICAgICAgIFwic3RyaW5nLnF1b3RlZFwiLFxuICAgICAgICAgIFwic3RyaW5nLnJlZ2V4cFwiLFxuICAgICAgICAgIFwic3RyaW5nLmludGVycG9sYXRlZFwiLFxuICAgICAgICAgIFwic3RyaW5nLnRlbXBsYXRlXCIsXG4gICAgICAgICAgXCJzdHJpbmcudW5xdW90ZWQucGxhaW4ub3V0LnlhbWxcIixcbiAgICAgICAgICBcImtleXdvcmQub3RoZXIudGVtcGxhdGVcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tc3RyaW5nLWV4cHJlc3Npb25cIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFtcbiAgICAgICAgICBcInB1bmN0dWF0aW9uLmRlZmluaXRpb24uYXJndW1lbnRzXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLmRpY3RcIixcbiAgICAgICAgICBcInB1bmN0dWF0aW9uLnNlcGFyYXRvclwiLFxuICAgICAgICAgIFwibWV0YS5mdW5jdGlvbi1jYWxsLmFyZ3VtZW50c1wiXG4gICAgICAgIF0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9yZWdyb3VuZDogdmFyaWFibGUoXCJ0b2tlbi1wdW5jdHVhdGlvblwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBbQ3VzdG9tXSBNYXJrZG93biBsaW5rc1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwibWFya3VwLnVuZGVybGluZS5saW5rXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLm1ldGFkYXRhLm1hcmtkb3duXCJcbiAgICAgICAgXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLWxpbmtcIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gW0N1c3RvbV0gTWFya2Rvd24gbGlzdFxuICAgICAgICBzY29wZTogW1wiYmVnaW5uaW5nLnB1bmN0dWF0aW9uLmRlZmluaXRpb24ubGlzdC5tYXJrZG93blwiXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLXN0cmluZ1wiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBbQ3VzdG9tXSBNYXJrZG93biBwdW5jdHVhdGlvbiBkZWZpbml0aW9uIGJyYWNrZXRzXG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnN0cmluZy5iZWdpbi5tYXJrZG93blwiLFxuICAgICAgICAgIFwicHVuY3R1YXRpb24uZGVmaW5pdGlvbi5zdHJpbmcuZW5kLm1hcmtkb3duXCIsXG4gICAgICAgICAgXCJzdHJpbmcub3RoZXIubGluay50aXRsZS5tYXJrZG93blwiLFxuICAgICAgICAgIFwic3RyaW5nLm90aGVyLmxpbmsuZGVzY3JpcHRpb24ubWFya2Rvd25cIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4ta2V5d29yZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBbQ3VzdG9tXSBEaWZmXG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJtYXJrdXAuaW5zZXJ0ZWRcIixcbiAgICAgICAgICBcIm1ldGEuZGlmZi5oZWFkZXIudG8tZmlsZVwiLFxuICAgICAgICAgIFwicHVuY3R1YXRpb24uZGVmaW5pdGlvbi5pbnNlcnRlZFwiXG4gICAgICAgIF0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9yZWdyb3VuZDogdmFyaWFibGUoXCJ0b2tlbi1pbnNlcnRlZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwibWFya3VwLmRlbGV0ZWRcIixcbiAgICAgICAgICBcIm1ldGEuZGlmZi5oZWFkZXIuZnJvbS1maWxlXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLmRlbGV0ZWRcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tZGVsZXRlZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwibWFya3VwLmNoYW5nZWRcIixcbiAgICAgICAgICBcInB1bmN0dWF0aW9uLmRlZmluaXRpb24uY2hhbmdlZFwiXG4gICAgICAgIF0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9yZWdyb3VuZDogdmFyaWFibGUoXCJ0b2tlbi1jaGFuZ2VkXCIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIGlmICghZm9udFN0eWxlKSB7XG4gICAgdGhlbWUudG9rZW5Db2xvcnMgPSB0aGVtZS50b2tlbkNvbG9ycz8ubWFwKCh0b2tlbkNvbG9yKSA9PiB7XG4gICAgICBpZiAodG9rZW5Db2xvci5zZXR0aW5ncz8uZm9udFN0eWxlKVxuICAgICAgICBkZWxldGUgdG9rZW5Db2xvci5zZXR0aW5ncy5mb250U3R5bGU7XG4gICAgICByZXR1cm4gdG9rZW5Db2xvcjtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhlbWU7XG59XG5cbmV4cG9ydCB7IGFkZENsYXNzVG9IYXN0LCBhcHBseUNvbG9yUmVwbGFjZW1lbnRzLCBjb2RlVG9IYXN0LCBjb2RlVG9IdG1sLCBjb2RlVG9Ub2tlbnMsIGNvZGVUb1Rva2Vuc0Jhc2UsIGNvZGVUb1Rva2Vuc1dpdGhUaGVtZXMsIGNyZWF0ZUNzc1ZhcmlhYmxlc1RoZW1lLCBjcmVhdGVIaWdobGlnaHRlckNvcmUsIGNyZWF0ZUhpZ2hsaWdodGVyQ29yZVN5bmMsIGNyZWF0ZVBvc2l0aW9uQ29udmVydGVyLCBjcmVhdGVTaGlraUludGVybmFsLCBjcmVhdGVTaGlraUludGVybmFsU3luYywgY3JlYXRlU2luZ2xldG9uU2hvcnRoYW5kcywgY3JlYXRlZEJ1bmRsZWRIaWdobGlnaHRlciwgZW5hYmxlRGVwcmVjYXRpb25XYXJuaW5ncywgZmxhdFRva2VuVmFyaWFudHMsIGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyQ29yZSwgZ2V0VG9rZW5TdHlsZU9iamVjdCwgZ3Vlc3NFbWJlZGRlZExhbmd1YWdlcywgaGFzdFRvSHRtbCwgaXNOb25lVGhlbWUsIGlzUGxhaW5MYW5nLCBpc1NwZWNpYWxMYW5nLCBpc1NwZWNpYWxUaGVtZSwgbWFrZVNpbmdsZXRvbkhpZ2hsaWdodGVyLCBtYWtlU2luZ2xldG9uSGlnaGxpZ2h0ZXJDb3JlLCBub3JtYWxpemVHZXR0ZXIsIG5vcm1hbGl6ZVRoZW1lLCByZXNvbHZlQ29sb3JSZXBsYWNlbWVudHMsIHNwbGl0TGluZXMsIHNwbGl0VG9rZW4sIHNwbGl0VG9rZW5zLCBzdHJpbmdpZnlUb2tlblN0eWxlLCB0b0FycmF5LCB0b2tlbml6ZUFuc2lXaXRoVGhlbWUsIHRva2VuaXplV2l0aFRoZW1lLCB0b2tlbnNUb0hhc3QsIHRyYW5zZm9ybWVyRGVjb3JhdGlvbnMsIHdhcm5EZXByZWNhdGVkIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/@shikijs+core@3.13.0/node_modules/@shikijs/core/dist/index.mjs\n");

/***/ })

};
;