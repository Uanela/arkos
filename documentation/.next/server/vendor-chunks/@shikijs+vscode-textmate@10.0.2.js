"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@shikijs+vscode-textmate@10.0.2";
exports.ids = ["vendor-chunks/@shikijs+vscode-textmate@10.0.2"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/@shikijs+vscode-textmate@10.0.2/node_modules/@shikijs/vscode-textmate/dist/index.js":
/*!*****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@shikijs+vscode-textmate@10.0.2/node_modules/@shikijs/vscode-textmate/dist/index.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EncodedTokenMetadata: () => (/* binding */ EncodedTokenMetadata),\n/* harmony export */   FindOption: () => (/* binding */ FindOption),\n/* harmony export */   FontStyle: () => (/* binding */ FontStyle),\n/* harmony export */   INITIAL: () => (/* binding */ INITIAL),\n/* harmony export */   Registry: () => (/* binding */ Registry),\n/* harmony export */   Theme: () => (/* binding */ Theme),\n/* harmony export */   disposeOnigString: () => (/* binding */ disposeOnigString)\n/* harmony export */ });\n// src/utils.ts\nfunction clone(something) {\n  return doClone(something);\n}\nfunction doClone(something) {\n  if (Array.isArray(something)) {\n    return cloneArray(something);\n  }\n  if (something instanceof RegExp) {\n    return something;\n  }\n  if (typeof something === \"object\") {\n    return cloneObj(something);\n  }\n  return something;\n}\nfunction cloneArray(arr) {\n  let r = [];\n  for (let i = 0, len = arr.length; i < len; i++) {\n    r[i] = doClone(arr[i]);\n  }\n  return r;\n}\nfunction cloneObj(obj) {\n  let r = {};\n  for (let key in obj) {\n    r[key] = doClone(obj[key]);\n  }\n  return r;\n}\nfunction mergeObjects(target, ...sources) {\n  sources.forEach((source) => {\n    for (let key in source) {\n      target[key] = source[key];\n    }\n  });\n  return target;\n}\nfunction basename(path) {\n  const idx = ~path.lastIndexOf(\"/\") || ~path.lastIndexOf(\"\\\\\");\n  if (idx === 0) {\n    return path;\n  } else if (~idx === path.length - 1) {\n    return basename(path.substring(0, path.length - 1));\n  } else {\n    return path.substr(~idx + 1);\n  }\n}\nvar CAPTURING_REGEX_SOURCE = /\\$(\\d+)|\\${(\\d+):\\/(downcase|upcase)}/g;\nvar RegexSource = class {\n  static hasCaptures(regexSource) {\n    if (regexSource === null) {\n      return false;\n    }\n    CAPTURING_REGEX_SOURCE.lastIndex = 0;\n    return CAPTURING_REGEX_SOURCE.test(regexSource);\n  }\n  static replaceCaptures(regexSource, captureSource, captureIndices) {\n    return regexSource.replace(CAPTURING_REGEX_SOURCE, (match, index, commandIndex, command) => {\n      let capture = captureIndices[parseInt(index || commandIndex, 10)];\n      if (capture) {\n        let result = captureSource.substring(capture.start, capture.end);\n        while (result[0] === \".\") {\n          result = result.substring(1);\n        }\n        switch (command) {\n          case \"downcase\":\n            return result.toLowerCase();\n          case \"upcase\":\n            return result.toUpperCase();\n          default:\n            return result;\n        }\n      } else {\n        return match;\n      }\n    });\n  }\n};\nfunction strcmp(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\nfunction strArrCmp(a, b) {\n  if (a === null && b === null) {\n    return 0;\n  }\n  if (!a) {\n    return -1;\n  }\n  if (!b) {\n    return 1;\n  }\n  let len1 = a.length;\n  let len2 = b.length;\n  if (len1 === len2) {\n    for (let i = 0; i < len1; i++) {\n      let res = strcmp(a[i], b[i]);\n      if (res !== 0) {\n        return res;\n      }\n    }\n    return 0;\n  }\n  return len1 - len2;\n}\nfunction isValidHexColor(hex) {\n  if (/^#[0-9a-f]{6}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{8}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{3}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{4}$/i.test(hex)) {\n    return true;\n  }\n  return false;\n}\nfunction escapeRegExpCharacters(value) {\n  return value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, \"\\\\$&\");\n}\nvar CachedFn = class {\n  constructor(fn) {\n    this.fn = fn;\n  }\n  cache = /* @__PURE__ */ new Map();\n  get(key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key);\n    }\n    const value = this.fn(key);\n    this.cache.set(key, value);\n    return value;\n  }\n};\n\n// src/theme.ts\nvar Theme = class {\n  constructor(_colorMap, _defaults, _root) {\n    this._colorMap = _colorMap;\n    this._defaults = _defaults;\n    this._root = _root;\n  }\n  static createFromRawTheme(source, colorMap) {\n    return this.createFromParsedTheme(parseTheme(source), colorMap);\n  }\n  static createFromParsedTheme(source, colorMap) {\n    return resolveParsedThemeRules(source, colorMap);\n  }\n  _cachedMatchRoot = new CachedFn(\n    (scopeName) => this._root.match(scopeName)\n  );\n  getColorMap() {\n    return this._colorMap.getColorMap();\n  }\n  getDefaults() {\n    return this._defaults;\n  }\n  match(scopePath) {\n    if (scopePath === null) {\n      return this._defaults;\n    }\n    const scopeName = scopePath.scopeName;\n    const matchingTrieElements = this._cachedMatchRoot.get(scopeName);\n    const effectiveRule = matchingTrieElements.find(\n      (v) => _scopePathMatchesParentScopes(scopePath.parent, v.parentScopes)\n    );\n    if (!effectiveRule) {\n      return null;\n    }\n    return new StyleAttributes(\n      effectiveRule.fontStyle,\n      effectiveRule.foreground,\n      effectiveRule.background\n    );\n  }\n};\nvar ScopeStack = class _ScopeStack {\n  constructor(parent, scopeName) {\n    this.parent = parent;\n    this.scopeName = scopeName;\n  }\n  static push(path, scopeNames) {\n    for (const name of scopeNames) {\n      path = new _ScopeStack(path, name);\n    }\n    return path;\n  }\n  static from(...segments) {\n    let result = null;\n    for (let i = 0; i < segments.length; i++) {\n      result = new _ScopeStack(result, segments[i]);\n    }\n    return result;\n  }\n  push(scopeName) {\n    return new _ScopeStack(this, scopeName);\n  }\n  getSegments() {\n    let item = this;\n    const result = [];\n    while (item) {\n      result.push(item.scopeName);\n      item = item.parent;\n    }\n    result.reverse();\n    return result;\n  }\n  toString() {\n    return this.getSegments().join(\" \");\n  }\n  extends(other) {\n    if (this === other) {\n      return true;\n    }\n    if (this.parent === null) {\n      return false;\n    }\n    return this.parent.extends(other);\n  }\n  getExtensionIfDefined(base) {\n    const result = [];\n    let item = this;\n    while (item && item !== base) {\n      result.push(item.scopeName);\n      item = item.parent;\n    }\n    return item === base ? result.reverse() : void 0;\n  }\n};\nfunction _scopePathMatchesParentScopes(scopePath, parentScopes) {\n  if (parentScopes.length === 0) {\n    return true;\n  }\n  for (let index = 0; index < parentScopes.length; index++) {\n    let scopePattern = parentScopes[index];\n    let scopeMustMatch = false;\n    if (scopePattern === \">\") {\n      if (index === parentScopes.length - 1) {\n        return false;\n      }\n      scopePattern = parentScopes[++index];\n      scopeMustMatch = true;\n    }\n    while (scopePath) {\n      if (_matchesScope(scopePath.scopeName, scopePattern)) {\n        break;\n      }\n      if (scopeMustMatch) {\n        return false;\n      }\n      scopePath = scopePath.parent;\n    }\n    if (!scopePath) {\n      return false;\n    }\n    scopePath = scopePath.parent;\n  }\n  return true;\n}\nfunction _matchesScope(scopeName, scopePattern) {\n  return scopePattern === scopeName || scopeName.startsWith(scopePattern) && scopeName[scopePattern.length] === \".\";\n}\nvar StyleAttributes = class {\n  constructor(fontStyle, foregroundId, backgroundId) {\n    this.fontStyle = fontStyle;\n    this.foregroundId = foregroundId;\n    this.backgroundId = backgroundId;\n  }\n};\nfunction parseTheme(source) {\n  if (!source) {\n    return [];\n  }\n  if (!source.settings || !Array.isArray(source.settings)) {\n    return [];\n  }\n  let settings = source.settings;\n  let result = [], resultLen = 0;\n  for (let i = 0, len = settings.length; i < len; i++) {\n    let entry = settings[i];\n    if (!entry.settings) {\n      continue;\n    }\n    let scopes;\n    if (typeof entry.scope === \"string\") {\n      let _scope = entry.scope;\n      _scope = _scope.replace(/^[,]+/, \"\");\n      _scope = _scope.replace(/[,]+$/, \"\");\n      scopes = _scope.split(\",\");\n    } else if (Array.isArray(entry.scope)) {\n      scopes = entry.scope;\n    } else {\n      scopes = [\"\"];\n    }\n    let fontStyle = -1 /* NotSet */;\n    if (typeof entry.settings.fontStyle === \"string\") {\n      fontStyle = 0 /* None */;\n      let segments = entry.settings.fontStyle.split(\" \");\n      for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n        let segment = segments[j];\n        switch (segment) {\n          case \"italic\":\n            fontStyle = fontStyle | 1 /* Italic */;\n            break;\n          case \"bold\":\n            fontStyle = fontStyle | 2 /* Bold */;\n            break;\n          case \"underline\":\n            fontStyle = fontStyle | 4 /* Underline */;\n            break;\n          case \"strikethrough\":\n            fontStyle = fontStyle | 8 /* Strikethrough */;\n            break;\n        }\n      }\n    }\n    let foreground = null;\n    if (typeof entry.settings.foreground === \"string\" && isValidHexColor(entry.settings.foreground)) {\n      foreground = entry.settings.foreground;\n    }\n    let background = null;\n    if (typeof entry.settings.background === \"string\" && isValidHexColor(entry.settings.background)) {\n      background = entry.settings.background;\n    }\n    for (let j = 0, lenJ = scopes.length; j < lenJ; j++) {\n      let _scope = scopes[j].trim();\n      let segments = _scope.split(\" \");\n      let scope = segments[segments.length - 1];\n      let parentScopes = null;\n      if (segments.length > 1) {\n        parentScopes = segments.slice(0, segments.length - 1);\n        parentScopes.reverse();\n      }\n      result[resultLen++] = new ParsedThemeRule(\n        scope,\n        parentScopes,\n        i,\n        fontStyle,\n        foreground,\n        background\n      );\n    }\n  }\n  return result;\n}\nvar ParsedThemeRule = class {\n  constructor(scope, parentScopes, index, fontStyle, foreground, background) {\n    this.scope = scope;\n    this.parentScopes = parentScopes;\n    this.index = index;\n    this.fontStyle = fontStyle;\n    this.foreground = foreground;\n    this.background = background;\n  }\n};\nvar FontStyle = /* @__PURE__ */ ((FontStyle2) => {\n  FontStyle2[FontStyle2[\"NotSet\"] = -1] = \"NotSet\";\n  FontStyle2[FontStyle2[\"None\"] = 0] = \"None\";\n  FontStyle2[FontStyle2[\"Italic\"] = 1] = \"Italic\";\n  FontStyle2[FontStyle2[\"Bold\"] = 2] = \"Bold\";\n  FontStyle2[FontStyle2[\"Underline\"] = 4] = \"Underline\";\n  FontStyle2[FontStyle2[\"Strikethrough\"] = 8] = \"Strikethrough\";\n  return FontStyle2;\n})(FontStyle || {});\nfunction resolveParsedThemeRules(parsedThemeRules, _colorMap) {\n  parsedThemeRules.sort((a, b) => {\n    let r = strcmp(a.scope, b.scope);\n    if (r !== 0) {\n      return r;\n    }\n    r = strArrCmp(a.parentScopes, b.parentScopes);\n    if (r !== 0) {\n      return r;\n    }\n    return a.index - b.index;\n  });\n  let defaultFontStyle = 0 /* None */;\n  let defaultForeground = \"#000000\";\n  let defaultBackground = \"#ffffff\";\n  while (parsedThemeRules.length >= 1 && parsedThemeRules[0].scope === \"\") {\n    let incomingDefaults = parsedThemeRules.shift();\n    if (incomingDefaults.fontStyle !== -1 /* NotSet */) {\n      defaultFontStyle = incomingDefaults.fontStyle;\n    }\n    if (incomingDefaults.foreground !== null) {\n      defaultForeground = incomingDefaults.foreground;\n    }\n    if (incomingDefaults.background !== null) {\n      defaultBackground = incomingDefaults.background;\n    }\n  }\n  let colorMap = new ColorMap(_colorMap);\n  let defaults = new StyleAttributes(defaultFontStyle, colorMap.getId(defaultForeground), colorMap.getId(defaultBackground));\n  let root = new ThemeTrieElement(new ThemeTrieElementRule(0, null, -1 /* NotSet */, 0, 0), []);\n  for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n    let rule = parsedThemeRules[i];\n    root.insert(0, rule.scope, rule.parentScopes, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n  }\n  return new Theme(colorMap, defaults, root);\n}\nvar ColorMap = class {\n  _isFrozen;\n  _lastColorId;\n  _id2color;\n  _color2id;\n  constructor(_colorMap) {\n    this._lastColorId = 0;\n    this._id2color = [];\n    this._color2id = /* @__PURE__ */ Object.create(null);\n    if (Array.isArray(_colorMap)) {\n      this._isFrozen = true;\n      for (let i = 0, len = _colorMap.length; i < len; i++) {\n        this._color2id[_colorMap[i]] = i;\n        this._id2color[i] = _colorMap[i];\n      }\n    } else {\n      this._isFrozen = false;\n    }\n  }\n  getId(color) {\n    if (color === null) {\n      return 0;\n    }\n    color = color.toUpperCase();\n    let value = this._color2id[color];\n    if (value) {\n      return value;\n    }\n    if (this._isFrozen) {\n      throw new Error(`Missing color in color map - ${color}`);\n    }\n    value = ++this._lastColorId;\n    this._color2id[color] = value;\n    this._id2color[value] = color;\n    return value;\n  }\n  getColorMap() {\n    return this._id2color.slice(0);\n  }\n};\nvar emptyParentScopes = Object.freeze([]);\nvar ThemeTrieElementRule = class _ThemeTrieElementRule {\n  scopeDepth;\n  parentScopes;\n  fontStyle;\n  foreground;\n  background;\n  constructor(scopeDepth, parentScopes, fontStyle, foreground, background) {\n    this.scopeDepth = scopeDepth;\n    this.parentScopes = parentScopes || emptyParentScopes;\n    this.fontStyle = fontStyle;\n    this.foreground = foreground;\n    this.background = background;\n  }\n  clone() {\n    return new _ThemeTrieElementRule(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);\n  }\n  static cloneArr(arr) {\n    let r = [];\n    for (let i = 0, len = arr.length; i < len; i++) {\n      r[i] = arr[i].clone();\n    }\n    return r;\n  }\n  acceptOverwrite(scopeDepth, fontStyle, foreground, background) {\n    if (this.scopeDepth > scopeDepth) {\n      console.log(\"how did this happen?\");\n    } else {\n      this.scopeDepth = scopeDepth;\n    }\n    if (fontStyle !== -1 /* NotSet */) {\n      this.fontStyle = fontStyle;\n    }\n    if (foreground !== 0) {\n      this.foreground = foreground;\n    }\n    if (background !== 0) {\n      this.background = background;\n    }\n  }\n};\nvar ThemeTrieElement = class _ThemeTrieElement {\n  constructor(_mainRule, rulesWithParentScopes = [], _children = {}) {\n    this._mainRule = _mainRule;\n    this._children = _children;\n    this._rulesWithParentScopes = rulesWithParentScopes;\n  }\n  _rulesWithParentScopes;\n  static _cmpBySpecificity(a, b) {\n    if (a.scopeDepth !== b.scopeDepth) {\n      return b.scopeDepth - a.scopeDepth;\n    }\n    let aParentIndex = 0;\n    let bParentIndex = 0;\n    while (true) {\n      if (a.parentScopes[aParentIndex] === \">\") {\n        aParentIndex++;\n      }\n      if (b.parentScopes[bParentIndex] === \">\") {\n        bParentIndex++;\n      }\n      if (aParentIndex >= a.parentScopes.length || bParentIndex >= b.parentScopes.length) {\n        break;\n      }\n      const parentScopeLengthDiff = b.parentScopes[bParentIndex].length - a.parentScopes[aParentIndex].length;\n      if (parentScopeLengthDiff !== 0) {\n        return parentScopeLengthDiff;\n      }\n      aParentIndex++;\n      bParentIndex++;\n    }\n    return b.parentScopes.length - a.parentScopes.length;\n  }\n  match(scope) {\n    if (scope !== \"\") {\n      let dotIndex = scope.indexOf(\".\");\n      let head;\n      let tail;\n      if (dotIndex === -1) {\n        head = scope;\n        tail = \"\";\n      } else {\n        head = scope.substring(0, dotIndex);\n        tail = scope.substring(dotIndex + 1);\n      }\n      if (this._children.hasOwnProperty(head)) {\n        return this._children[head].match(tail);\n      }\n    }\n    const rules = this._rulesWithParentScopes.concat(this._mainRule);\n    rules.sort(_ThemeTrieElement._cmpBySpecificity);\n    return rules;\n  }\n  insert(scopeDepth, scope, parentScopes, fontStyle, foreground, background) {\n    if (scope === \"\") {\n      this._doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background);\n      return;\n    }\n    let dotIndex = scope.indexOf(\".\");\n    let head;\n    let tail;\n    if (dotIndex === -1) {\n      head = scope;\n      tail = \"\";\n    } else {\n      head = scope.substring(0, dotIndex);\n      tail = scope.substring(dotIndex + 1);\n    }\n    let child;\n    if (this._children.hasOwnProperty(head)) {\n      child = this._children[head];\n    } else {\n      child = new _ThemeTrieElement(this._mainRule.clone(), ThemeTrieElementRule.cloneArr(this._rulesWithParentScopes));\n      this._children[head] = child;\n    }\n    child.insert(scopeDepth + 1, tail, parentScopes, fontStyle, foreground, background);\n  }\n  _doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background) {\n    if (parentScopes === null) {\n      this._mainRule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n      return;\n    }\n    for (let i = 0, len = this._rulesWithParentScopes.length; i < len; i++) {\n      let rule = this._rulesWithParentScopes[i];\n      if (strArrCmp(rule.parentScopes, parentScopes) === 0) {\n        rule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n        return;\n      }\n    }\n    if (fontStyle === -1 /* NotSet */) {\n      fontStyle = this._mainRule.fontStyle;\n    }\n    if (foreground === 0) {\n      foreground = this._mainRule.foreground;\n    }\n    if (background === 0) {\n      background = this._mainRule.background;\n    }\n    this._rulesWithParentScopes.push(new ThemeTrieElementRule(scopeDepth, parentScopes, fontStyle, foreground, background));\n  }\n};\n\n// src/encodedTokenAttributes.ts\nvar EncodedTokenMetadata = class _EncodedTokenMetadata {\n  static toBinaryStr(encodedTokenAttributes) {\n    return encodedTokenAttributes.toString(2).padStart(32, \"0\");\n  }\n  static print(encodedTokenAttributes) {\n    const languageId = _EncodedTokenMetadata.getLanguageId(encodedTokenAttributes);\n    const tokenType = _EncodedTokenMetadata.getTokenType(encodedTokenAttributes);\n    const fontStyle = _EncodedTokenMetadata.getFontStyle(encodedTokenAttributes);\n    const foreground = _EncodedTokenMetadata.getForeground(encodedTokenAttributes);\n    const background = _EncodedTokenMetadata.getBackground(encodedTokenAttributes);\n    console.log({\n      languageId,\n      tokenType,\n      fontStyle,\n      foreground,\n      background\n    });\n  }\n  static getLanguageId(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 255 /* LANGUAGEID_MASK */) >>> 0 /* LANGUAGEID_OFFSET */;\n  }\n  static getTokenType(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 768 /* TOKEN_TYPE_MASK */) >>> 8 /* TOKEN_TYPE_OFFSET */;\n  }\n  static containsBalancedBrackets(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 1024 /* BALANCED_BRACKETS_MASK */) !== 0;\n  }\n  static getFontStyle(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 30720 /* FONT_STYLE_MASK */) >>> 11 /* FONT_STYLE_OFFSET */;\n  }\n  static getForeground(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 16744448 /* FOREGROUND_MASK */) >>> 15 /* FOREGROUND_OFFSET */;\n  }\n  static getBackground(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 4278190080 /* BACKGROUND_MASK */) >>> 24 /* BACKGROUND_OFFSET */;\n  }\n  /**\n   * Updates the fields in `metadata`.\n   * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.\n   */\n  static set(encodedTokenAttributes, languageId, tokenType, containsBalancedBrackets, fontStyle, foreground, background) {\n    let _languageId = _EncodedTokenMetadata.getLanguageId(encodedTokenAttributes);\n    let _tokenType = _EncodedTokenMetadata.getTokenType(encodedTokenAttributes);\n    let _containsBalancedBracketsBit = _EncodedTokenMetadata.containsBalancedBrackets(encodedTokenAttributes) ? 1 : 0;\n    let _fontStyle = _EncodedTokenMetadata.getFontStyle(encodedTokenAttributes);\n    let _foreground = _EncodedTokenMetadata.getForeground(encodedTokenAttributes);\n    let _background = _EncodedTokenMetadata.getBackground(encodedTokenAttributes);\n    if (languageId !== 0) {\n      _languageId = languageId;\n    }\n    if (tokenType !== 8 /* NotSet */) {\n      _tokenType = fromOptionalTokenType(tokenType);\n    }\n    if (containsBalancedBrackets !== null) {\n      _containsBalancedBracketsBit = containsBalancedBrackets ? 1 : 0;\n    }\n    if (fontStyle !== -1 /* NotSet */) {\n      _fontStyle = fontStyle;\n    }\n    if (foreground !== 0) {\n      _foreground = foreground;\n    }\n    if (background !== 0) {\n      _background = background;\n    }\n    return (_languageId << 0 /* LANGUAGEID_OFFSET */ | _tokenType << 8 /* TOKEN_TYPE_OFFSET */ | _containsBalancedBracketsBit << 10 /* BALANCED_BRACKETS_OFFSET */ | _fontStyle << 11 /* FONT_STYLE_OFFSET */ | _foreground << 15 /* FOREGROUND_OFFSET */ | _background << 24 /* BACKGROUND_OFFSET */) >>> 0;\n  }\n};\nfunction toOptionalTokenType(standardType) {\n  return standardType;\n}\nfunction fromOptionalTokenType(standardType) {\n  return standardType;\n}\n\n// src/matcher.ts\nfunction createMatchers(selector, matchesName) {\n  const results = [];\n  const tokenizer = newTokenizer(selector);\n  let token = tokenizer.next();\n  while (token !== null) {\n    let priority = 0;\n    if (token.length === 2 && token.charAt(1) === \":\") {\n      switch (token.charAt(0)) {\n        case \"R\":\n          priority = 1;\n          break;\n        case \"L\":\n          priority = -1;\n          break;\n        default:\n          console.log(`Unknown priority ${token} in scope selector`);\n      }\n      token = tokenizer.next();\n    }\n    let matcher = parseConjunction();\n    results.push({ matcher, priority });\n    if (token !== \",\") {\n      break;\n    }\n    token = tokenizer.next();\n  }\n  return results;\n  function parseOperand() {\n    if (token === \"-\") {\n      token = tokenizer.next();\n      const expressionToNegate = parseOperand();\n      return (matcherInput) => !!expressionToNegate && !expressionToNegate(matcherInput);\n    }\n    if (token === \"(\") {\n      token = tokenizer.next();\n      const expressionInParents = parseInnerExpression();\n      if (token === \")\") {\n        token = tokenizer.next();\n      }\n      return expressionInParents;\n    }\n    if (isIdentifier(token)) {\n      const identifiers = [];\n      do {\n        identifiers.push(token);\n        token = tokenizer.next();\n      } while (isIdentifier(token));\n      return (matcherInput) => matchesName(identifiers, matcherInput);\n    }\n    return null;\n  }\n  function parseConjunction() {\n    const matchers = [];\n    let matcher = parseOperand();\n    while (matcher) {\n      matchers.push(matcher);\n      matcher = parseOperand();\n    }\n    return (matcherInput) => matchers.every((matcher2) => matcher2(matcherInput));\n  }\n  function parseInnerExpression() {\n    const matchers = [];\n    let matcher = parseConjunction();\n    while (matcher) {\n      matchers.push(matcher);\n      if (token === \"|\" || token === \",\") {\n        do {\n          token = tokenizer.next();\n        } while (token === \"|\" || token === \",\");\n      } else {\n        break;\n      }\n      matcher = parseConjunction();\n    }\n    return (matcherInput) => matchers.some((matcher2) => matcher2(matcherInput));\n  }\n}\nfunction isIdentifier(token) {\n  return !!token && !!token.match(/[\\w\\.:]+/);\n}\nfunction newTokenizer(input) {\n  let regex = /([LR]:|[\\w\\.:][\\w\\.:\\-]*|[\\,\\|\\-\\(\\)])/g;\n  let match = regex.exec(input);\n  return {\n    next: () => {\n      if (!match) {\n        return null;\n      }\n      const res = match[0];\n      match = regex.exec(input);\n      return res;\n    }\n  };\n}\n\n// src/onigLib.ts\nvar FindOption = /* @__PURE__ */ ((FindOption2) => {\n  FindOption2[FindOption2[\"None\"] = 0] = \"None\";\n  FindOption2[FindOption2[\"NotBeginString\"] = 1] = \"NotBeginString\";\n  FindOption2[FindOption2[\"NotEndString\"] = 2] = \"NotEndString\";\n  FindOption2[FindOption2[\"NotBeginPosition\"] = 4] = \"NotBeginPosition\";\n  FindOption2[FindOption2[\"DebugCall\"] = 8] = \"DebugCall\";\n  return FindOption2;\n})(FindOption || {});\nfunction disposeOnigString(str) {\n  if (typeof str.dispose === \"function\") {\n    str.dispose();\n  }\n}\n\n// src/grammar/grammarDependencies.ts\nvar TopLevelRuleReference = class {\n  constructor(scopeName) {\n    this.scopeName = scopeName;\n  }\n  toKey() {\n    return this.scopeName;\n  }\n};\nvar TopLevelRepositoryRuleReference = class {\n  constructor(scopeName, ruleName) {\n    this.scopeName = scopeName;\n    this.ruleName = ruleName;\n  }\n  toKey() {\n    return `${this.scopeName}#${this.ruleName}`;\n  }\n};\nvar ExternalReferenceCollector = class {\n  _references = [];\n  _seenReferenceKeys = /* @__PURE__ */ new Set();\n  get references() {\n    return this._references;\n  }\n  visitedRule = /* @__PURE__ */ new Set();\n  add(reference) {\n    const key = reference.toKey();\n    if (this._seenReferenceKeys.has(key)) {\n      return;\n    }\n    this._seenReferenceKeys.add(key);\n    this._references.push(reference);\n  }\n};\nvar ScopeDependencyProcessor = class {\n  constructor(repo, initialScopeName) {\n    this.repo = repo;\n    this.initialScopeName = initialScopeName;\n    this.seenFullScopeRequests.add(this.initialScopeName);\n    this.Q = [new TopLevelRuleReference(this.initialScopeName)];\n  }\n  seenFullScopeRequests = /* @__PURE__ */ new Set();\n  seenPartialScopeRequests = /* @__PURE__ */ new Set();\n  Q;\n  processQueue() {\n    const q = this.Q;\n    this.Q = [];\n    const deps = new ExternalReferenceCollector();\n    for (const dep of q) {\n      collectReferencesOfReference(dep, this.initialScopeName, this.repo, deps);\n    }\n    for (const dep of deps.references) {\n      if (dep instanceof TopLevelRuleReference) {\n        if (this.seenFullScopeRequests.has(dep.scopeName)) {\n          continue;\n        }\n        this.seenFullScopeRequests.add(dep.scopeName);\n        this.Q.push(dep);\n      } else {\n        if (this.seenFullScopeRequests.has(dep.scopeName)) {\n          continue;\n        }\n        if (this.seenPartialScopeRequests.has(dep.toKey())) {\n          continue;\n        }\n        this.seenPartialScopeRequests.add(dep.toKey());\n        this.Q.push(dep);\n      }\n    }\n  }\n};\nfunction collectReferencesOfReference(reference, baseGrammarScopeName, repo, result) {\n  const selfGrammar = repo.lookup(reference.scopeName);\n  if (!selfGrammar) {\n    if (reference.scopeName === baseGrammarScopeName) {\n      throw new Error(`No grammar provided for <${baseGrammarScopeName}>`);\n    }\n    return;\n  }\n  const baseGrammar = repo.lookup(baseGrammarScopeName);\n  if (reference instanceof TopLevelRuleReference) {\n    collectExternalReferencesInTopLevelRule({ baseGrammar, selfGrammar }, result);\n  } else {\n    collectExternalReferencesInTopLevelRepositoryRule(\n      reference.ruleName,\n      { baseGrammar, selfGrammar, repository: selfGrammar.repository },\n      result\n    );\n  }\n  const injections = repo.injections(reference.scopeName);\n  if (injections) {\n    for (const injection of injections) {\n      result.add(new TopLevelRuleReference(injection));\n    }\n  }\n}\nfunction collectExternalReferencesInTopLevelRepositoryRule(ruleName, context, result) {\n  if (context.repository && context.repository[ruleName]) {\n    const rule = context.repository[ruleName];\n    collectExternalReferencesInRules([rule], context, result);\n  }\n}\nfunction collectExternalReferencesInTopLevelRule(context, result) {\n  if (context.selfGrammar.patterns && Array.isArray(context.selfGrammar.patterns)) {\n    collectExternalReferencesInRules(\n      context.selfGrammar.patterns,\n      { ...context, repository: context.selfGrammar.repository },\n      result\n    );\n  }\n  if (context.selfGrammar.injections) {\n    collectExternalReferencesInRules(\n      Object.values(context.selfGrammar.injections),\n      { ...context, repository: context.selfGrammar.repository },\n      result\n    );\n  }\n}\nfunction collectExternalReferencesInRules(rules, context, result) {\n  for (const rule of rules) {\n    if (result.visitedRule.has(rule)) {\n      continue;\n    }\n    result.visitedRule.add(rule);\n    const patternRepository = rule.repository ? mergeObjects({}, context.repository, rule.repository) : context.repository;\n    if (Array.isArray(rule.patterns)) {\n      collectExternalReferencesInRules(rule.patterns, { ...context, repository: patternRepository }, result);\n    }\n    const include = rule.include;\n    if (!include) {\n      continue;\n    }\n    const reference = parseInclude(include);\n    switch (reference.kind) {\n      case 0 /* Base */:\n        collectExternalReferencesInTopLevelRule({ ...context, selfGrammar: context.baseGrammar }, result);\n        break;\n      case 1 /* Self */:\n        collectExternalReferencesInTopLevelRule(context, result);\n        break;\n      case 2 /* RelativeReference */:\n        collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, { ...context, repository: patternRepository }, result);\n        break;\n      case 3 /* TopLevelReference */:\n      case 4 /* TopLevelRepositoryReference */:\n        const selfGrammar = reference.scopeName === context.selfGrammar.scopeName ? context.selfGrammar : reference.scopeName === context.baseGrammar.scopeName ? context.baseGrammar : void 0;\n        if (selfGrammar) {\n          const newContext = { baseGrammar: context.baseGrammar, selfGrammar, repository: patternRepository };\n          if (reference.kind === 4 /* TopLevelRepositoryReference */) {\n            collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, newContext, result);\n          } else {\n            collectExternalReferencesInTopLevelRule(newContext, result);\n          }\n        } else {\n          if (reference.kind === 4 /* TopLevelRepositoryReference */) {\n            result.add(new TopLevelRepositoryRuleReference(reference.scopeName, reference.ruleName));\n          } else {\n            result.add(new TopLevelRuleReference(reference.scopeName));\n          }\n        }\n        break;\n    }\n  }\n}\nvar BaseReference = class {\n  kind = 0 /* Base */;\n};\nvar SelfReference = class {\n  kind = 1 /* Self */;\n};\nvar RelativeReference = class {\n  constructor(ruleName) {\n    this.ruleName = ruleName;\n  }\n  kind = 2 /* RelativeReference */;\n};\nvar TopLevelReference = class {\n  constructor(scopeName) {\n    this.scopeName = scopeName;\n  }\n  kind = 3 /* TopLevelReference */;\n};\nvar TopLevelRepositoryReference = class {\n  constructor(scopeName, ruleName) {\n    this.scopeName = scopeName;\n    this.ruleName = ruleName;\n  }\n  kind = 4 /* TopLevelRepositoryReference */;\n};\nfunction parseInclude(include) {\n  if (include === \"$base\") {\n    return new BaseReference();\n  } else if (include === \"$self\") {\n    return new SelfReference();\n  }\n  const indexOfSharp = include.indexOf(\"#\");\n  if (indexOfSharp === -1) {\n    return new TopLevelReference(include);\n  } else if (indexOfSharp === 0) {\n    return new RelativeReference(include.substring(1));\n  } else {\n    const scopeName = include.substring(0, indexOfSharp);\n    const ruleName = include.substring(indexOfSharp + 1);\n    return new TopLevelRepositoryReference(scopeName, ruleName);\n  }\n}\n\n// src/rule.ts\nvar HAS_BACK_REFERENCES = /\\\\(\\d+)/;\nvar BACK_REFERENCING_END = /\\\\(\\d+)/g;\nvar ruleIdSymbol = Symbol(\"RuleId\");\nvar endRuleId = -1;\nvar whileRuleId = -2;\nfunction ruleIdFromNumber(id) {\n  return id;\n}\nfunction ruleIdToNumber(id) {\n  return id;\n}\nvar Rule = class {\n  $location;\n  id;\n  _nameIsCapturing;\n  _name;\n  _contentNameIsCapturing;\n  _contentName;\n  constructor($location, id, name, contentName) {\n    this.$location = $location;\n    this.id = id;\n    this._name = name || null;\n    this._nameIsCapturing = RegexSource.hasCaptures(this._name);\n    this._contentName = contentName || null;\n    this._contentNameIsCapturing = RegexSource.hasCaptures(this._contentName);\n  }\n  get debugName() {\n    const location = this.$location ? `${basename(this.$location.filename)}:${this.$location.line}` : \"unknown\";\n    return `${this.constructor.name}#${this.id} @ ${location}`;\n  }\n  getName(lineText, captureIndices) {\n    if (!this._nameIsCapturing || this._name === null || lineText === null || captureIndices === null) {\n      return this._name;\n    }\n    return RegexSource.replaceCaptures(this._name, lineText, captureIndices);\n  }\n  getContentName(lineText, captureIndices) {\n    if (!this._contentNameIsCapturing || this._contentName === null) {\n      return this._contentName;\n    }\n    return RegexSource.replaceCaptures(this._contentName, lineText, captureIndices);\n  }\n};\nvar CaptureRule = class extends Rule {\n  retokenizeCapturedWithRuleId;\n  constructor($location, id, name, contentName, retokenizeCapturedWithRuleId) {\n    super($location, id, name, contentName);\n    this.retokenizeCapturedWithRuleId = retokenizeCapturedWithRuleId;\n  }\n  dispose() {\n  }\n  collectPatterns(grammar, out) {\n    throw new Error(\"Not supported!\");\n  }\n  compile(grammar, endRegexSource) {\n    throw new Error(\"Not supported!\");\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    throw new Error(\"Not supported!\");\n  }\n};\nvar MatchRule = class extends Rule {\n  _match;\n  captures;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, match, captures) {\n    super($location, id, name, null);\n    this._match = new RegExpSource(match, this.id);\n    this.captures = captures;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  get debugMatchRegExp() {\n    return `${this._match.source}`;\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._match);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      this.collectPatterns(grammar, this._cachedCompiledPatterns);\n    }\n    return this._cachedCompiledPatterns;\n  }\n};\nvar IncludeOnlyRule = class extends Rule {\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, contentName, patterns) {\n    super($location, id, name, contentName);\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  collectPatterns(grammar, out) {\n    for (const pattern of this.patterns) {\n      const rule = grammar.getRule(pattern);\n      rule.collectPatterns(grammar, out);\n    }\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      this.collectPatterns(grammar, this._cachedCompiledPatterns);\n    }\n    return this._cachedCompiledPatterns;\n  }\n};\nvar BeginEndRule = class extends Rule {\n  _begin;\n  beginCaptures;\n  _end;\n  endHasBackReferences;\n  endCaptures;\n  applyEndPatternLast;\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, contentName, begin, beginCaptures, end, endCaptures, applyEndPatternLast, patterns) {\n    super($location, id, name, contentName);\n    this._begin = new RegExpSource(begin, this.id);\n    this.beginCaptures = beginCaptures;\n    this._end = new RegExpSource(end ? end : \"\\uFFFF\", -1);\n    this.endHasBackReferences = this._end.hasBackReferences;\n    this.endCaptures = endCaptures;\n    this.applyEndPatternLast = applyEndPatternLast || false;\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  get debugBeginRegExp() {\n    return `${this._begin.source}`;\n  }\n  get debugEndRegExp() {\n    return `${this._end.source}`;\n  }\n  getEndWithResolvedBackReferences(lineText, captureIndices) {\n    return this._end.resolveBackReferences(lineText, captureIndices);\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._begin);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar, endRegexSource).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar, endRegexSource) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      for (const pattern of this.patterns) {\n        const rule = grammar.getRule(pattern);\n        rule.collectPatterns(grammar, this._cachedCompiledPatterns);\n      }\n      if (this.applyEndPatternLast) {\n        this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end);\n      } else {\n        this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);\n      }\n    }\n    if (this._end.hasBackReferences) {\n      if (this.applyEndPatternLast) {\n        this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, endRegexSource);\n      } else {\n        this._cachedCompiledPatterns.setSource(0, endRegexSource);\n      }\n    }\n    return this._cachedCompiledPatterns;\n  }\n};\nvar BeginWhileRule = class extends Rule {\n  _begin;\n  beginCaptures;\n  whileCaptures;\n  _while;\n  whileHasBackReferences;\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  _cachedCompiledWhilePatterns;\n  constructor($location, id, name, contentName, begin, beginCaptures, _while, whileCaptures, patterns) {\n    super($location, id, name, contentName);\n    this._begin = new RegExpSource(begin, this.id);\n    this.beginCaptures = beginCaptures;\n    this.whileCaptures = whileCaptures;\n    this._while = new RegExpSource(_while, whileRuleId);\n    this.whileHasBackReferences = this._while.hasBackReferences;\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n    this._cachedCompiledWhilePatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n    if (this._cachedCompiledWhilePatterns) {\n      this._cachedCompiledWhilePatterns.dispose();\n      this._cachedCompiledWhilePatterns = null;\n    }\n  }\n  get debugBeginRegExp() {\n    return `${this._begin.source}`;\n  }\n  get debugWhileRegExp() {\n    return `${this._while.source}`;\n  }\n  getWhileWithResolvedBackReferences(lineText, captureIndices) {\n    return this._while.resolveBackReferences(lineText, captureIndices);\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._begin);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      for (const pattern of this.patterns) {\n        const rule = grammar.getRule(pattern);\n        rule.collectPatterns(grammar, this._cachedCompiledPatterns);\n      }\n    }\n    return this._cachedCompiledPatterns;\n  }\n  compileWhile(grammar, endRegexSource) {\n    return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compile(grammar);\n  }\n  compileWhileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledWhilePatterns(grammar, endRegexSource) {\n    if (!this._cachedCompiledWhilePatterns) {\n      this._cachedCompiledWhilePatterns = new RegExpSourceList();\n      this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while);\n    }\n    if (this._while.hasBackReferences) {\n      this._cachedCompiledWhilePatterns.setSource(0, endRegexSource ? endRegexSource : \"\\uFFFF\");\n    }\n    return this._cachedCompiledWhilePatterns;\n  }\n};\nvar RuleFactory = class _RuleFactory {\n  static createCaptureRule(helper, $location, name, contentName, retokenizeCapturedWithRuleId) {\n    return helper.registerRule((id) => {\n      return new CaptureRule($location, id, name, contentName, retokenizeCapturedWithRuleId);\n    });\n  }\n  static getCompiledRuleId(desc, helper, repository) {\n    if (!desc.id) {\n      helper.registerRule((id) => {\n        desc.id = id;\n        if (desc.match) {\n          return new MatchRule(\n            desc.$vscodeTextmateLocation,\n            desc.id,\n            desc.name,\n            desc.match,\n            _RuleFactory._compileCaptures(desc.captures, helper, repository)\n          );\n        }\n        if (typeof desc.begin === \"undefined\") {\n          if (desc.repository) {\n            repository = mergeObjects({}, repository, desc.repository);\n          }\n          let patterns = desc.patterns;\n          if (typeof patterns === \"undefined\" && desc.include) {\n            patterns = [{ include: desc.include }];\n          }\n          return new IncludeOnlyRule(\n            desc.$vscodeTextmateLocation,\n            desc.id,\n            desc.name,\n            desc.contentName,\n            _RuleFactory._compilePatterns(patterns, helper, repository)\n          );\n        }\n        if (desc.while) {\n          return new BeginWhileRule(\n            desc.$vscodeTextmateLocation,\n            desc.id,\n            desc.name,\n            desc.contentName,\n            desc.begin,\n            _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository),\n            desc.while,\n            _RuleFactory._compileCaptures(desc.whileCaptures || desc.captures, helper, repository),\n            _RuleFactory._compilePatterns(desc.patterns, helper, repository)\n          );\n        }\n        return new BeginEndRule(\n          desc.$vscodeTextmateLocation,\n          desc.id,\n          desc.name,\n          desc.contentName,\n          desc.begin,\n          _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository),\n          desc.end,\n          _RuleFactory._compileCaptures(desc.endCaptures || desc.captures, helper, repository),\n          desc.applyEndPatternLast,\n          _RuleFactory._compilePatterns(desc.patterns, helper, repository)\n        );\n      });\n    }\n    return desc.id;\n  }\n  static _compileCaptures(captures, helper, repository) {\n    let r = [];\n    if (captures) {\n      let maximumCaptureId = 0;\n      for (const captureId in captures) {\n        if (captureId === \"$vscodeTextmateLocation\") {\n          continue;\n        }\n        const numericCaptureId = parseInt(captureId, 10);\n        if (numericCaptureId > maximumCaptureId) {\n          maximumCaptureId = numericCaptureId;\n        }\n      }\n      for (let i = 0; i <= maximumCaptureId; i++) {\n        r[i] = null;\n      }\n      for (const captureId in captures) {\n        if (captureId === \"$vscodeTextmateLocation\") {\n          continue;\n        }\n        const numericCaptureId = parseInt(captureId, 10);\n        let retokenizeCapturedWithRuleId = 0;\n        if (captures[captureId].patterns) {\n          retokenizeCapturedWithRuleId = _RuleFactory.getCompiledRuleId(captures[captureId], helper, repository);\n        }\n        r[numericCaptureId] = _RuleFactory.createCaptureRule(helper, captures[captureId].$vscodeTextmateLocation, captures[captureId].name, captures[captureId].contentName, retokenizeCapturedWithRuleId);\n      }\n    }\n    return r;\n  }\n  static _compilePatterns(patterns, helper, repository) {\n    let r = [];\n    if (patterns) {\n      for (let i = 0, len = patterns.length; i < len; i++) {\n        const pattern = patterns[i];\n        let ruleId = -1;\n        if (pattern.include) {\n          const reference = parseInclude(pattern.include);\n          switch (reference.kind) {\n            case 0 /* Base */:\n            case 1 /* Self */:\n              ruleId = _RuleFactory.getCompiledRuleId(repository[pattern.include], helper, repository);\n              break;\n            case 2 /* RelativeReference */:\n              let localIncludedRule = repository[reference.ruleName];\n              if (localIncludedRule) {\n                ruleId = _RuleFactory.getCompiledRuleId(localIncludedRule, helper, repository);\n              } else {\n              }\n              break;\n            case 3 /* TopLevelReference */:\n            case 4 /* TopLevelRepositoryReference */:\n              const externalGrammarName = reference.scopeName;\n              const externalGrammarInclude = reference.kind === 4 /* TopLevelRepositoryReference */ ? reference.ruleName : null;\n              const externalGrammar = helper.getExternalGrammar(externalGrammarName, repository);\n              if (externalGrammar) {\n                if (externalGrammarInclude) {\n                  let externalIncludedRule = externalGrammar.repository[externalGrammarInclude];\n                  if (externalIncludedRule) {\n                    ruleId = _RuleFactory.getCompiledRuleId(externalIncludedRule, helper, externalGrammar.repository);\n                  } else {\n                  }\n                } else {\n                  ruleId = _RuleFactory.getCompiledRuleId(externalGrammar.repository.$self, helper, externalGrammar.repository);\n                }\n              } else {\n              }\n              break;\n          }\n        } else {\n          ruleId = _RuleFactory.getCompiledRuleId(pattern, helper, repository);\n        }\n        if (ruleId !== -1) {\n          const rule = helper.getRule(ruleId);\n          let skipRule = false;\n          if (rule instanceof IncludeOnlyRule || rule instanceof BeginEndRule || rule instanceof BeginWhileRule) {\n            if (rule.hasMissingPatterns && rule.patterns.length === 0) {\n              skipRule = true;\n            }\n          }\n          if (skipRule) {\n            continue;\n          }\n          r.push(ruleId);\n        }\n      }\n    }\n    return {\n      patterns: r,\n      hasMissingPatterns: (patterns ? patterns.length : 0) !== r.length\n    };\n  }\n};\nvar RegExpSource = class _RegExpSource {\n  source;\n  ruleId;\n  hasAnchor;\n  hasBackReferences;\n  _anchorCache;\n  constructor(regExpSource, ruleId) {\n    if (regExpSource && typeof regExpSource === \"string\") {\n      const len = regExpSource.length;\n      let lastPushedPos = 0;\n      let output = [];\n      let hasAnchor = false;\n      for (let pos = 0; pos < len; pos++) {\n        const ch = regExpSource.charAt(pos);\n        if (ch === \"\\\\\") {\n          if (pos + 1 < len) {\n            const nextCh = regExpSource.charAt(pos + 1);\n            if (nextCh === \"z\") {\n              output.push(regExpSource.substring(lastPushedPos, pos));\n              output.push(\"$(?!\\\\n)(?<!\\\\n)\");\n              lastPushedPos = pos + 2;\n            } else if (nextCh === \"A\" || nextCh === \"G\") {\n              hasAnchor = true;\n            }\n            pos++;\n          }\n        }\n      }\n      this.hasAnchor = hasAnchor;\n      if (lastPushedPos === 0) {\n        this.source = regExpSource;\n      } else {\n        output.push(regExpSource.substring(lastPushedPos, len));\n        this.source = output.join(\"\");\n      }\n    } else {\n      this.hasAnchor = false;\n      this.source = regExpSource;\n    }\n    if (this.hasAnchor) {\n      this._anchorCache = this._buildAnchorCache();\n    } else {\n      this._anchorCache = null;\n    }\n    this.ruleId = ruleId;\n    if (typeof this.source === \"string\") {\n      this.hasBackReferences = HAS_BACK_REFERENCES.test(this.source);\n    } else {\n      this.hasBackReferences = false;\n    }\n  }\n  clone() {\n    return new _RegExpSource(this.source, this.ruleId);\n  }\n  setSource(newSource) {\n    if (this.source === newSource) {\n      return;\n    }\n    this.source = newSource;\n    if (this.hasAnchor) {\n      this._anchorCache = this._buildAnchorCache();\n    }\n  }\n  resolveBackReferences(lineText, captureIndices) {\n    if (typeof this.source !== \"string\") {\n      throw new Error(\"This method should only be called if the source is a string\");\n    }\n    let capturedValues = captureIndices.map((capture) => {\n      return lineText.substring(capture.start, capture.end);\n    });\n    BACK_REFERENCING_END.lastIndex = 0;\n    return this.source.replace(BACK_REFERENCING_END, (match, g1) => {\n      return escapeRegExpCharacters(capturedValues[parseInt(g1, 10)] || \"\");\n    });\n  }\n  _buildAnchorCache() {\n    if (typeof this.source !== \"string\") {\n      throw new Error(\"This method should only be called if the source is a string\");\n    }\n    let A0_G0_result = [];\n    let A0_G1_result = [];\n    let A1_G0_result = [];\n    let A1_G1_result = [];\n    let pos, len, ch, nextCh;\n    for (pos = 0, len = this.source.length; pos < len; pos++) {\n      ch = this.source.charAt(pos);\n      A0_G0_result[pos] = ch;\n      A0_G1_result[pos] = ch;\n      A1_G0_result[pos] = ch;\n      A1_G1_result[pos] = ch;\n      if (ch === \"\\\\\") {\n        if (pos + 1 < len) {\n          nextCh = this.source.charAt(pos + 1);\n          if (nextCh === \"A\") {\n            A0_G0_result[pos + 1] = \"\\uFFFF\";\n            A0_G1_result[pos + 1] = \"\\uFFFF\";\n            A1_G0_result[pos + 1] = \"A\";\n            A1_G1_result[pos + 1] = \"A\";\n          } else if (nextCh === \"G\") {\n            A0_G0_result[pos + 1] = \"\\uFFFF\";\n            A0_G1_result[pos + 1] = \"G\";\n            A1_G0_result[pos + 1] = \"\\uFFFF\";\n            A1_G1_result[pos + 1] = \"G\";\n          } else {\n            A0_G0_result[pos + 1] = nextCh;\n            A0_G1_result[pos + 1] = nextCh;\n            A1_G0_result[pos + 1] = nextCh;\n            A1_G1_result[pos + 1] = nextCh;\n          }\n          pos++;\n        }\n      }\n    }\n    return {\n      A0_G0: A0_G0_result.join(\"\"),\n      A0_G1: A0_G1_result.join(\"\"),\n      A1_G0: A1_G0_result.join(\"\"),\n      A1_G1: A1_G1_result.join(\"\")\n    };\n  }\n  resolveAnchors(allowA, allowG) {\n    if (!this.hasAnchor || !this._anchorCache || typeof this.source !== \"string\") {\n      return this.source;\n    }\n    if (allowA) {\n      if (allowG) {\n        return this._anchorCache.A1_G1;\n      } else {\n        return this._anchorCache.A1_G0;\n      }\n    } else {\n      if (allowG) {\n        return this._anchorCache.A0_G1;\n      } else {\n        return this._anchorCache.A0_G0;\n      }\n    }\n  }\n};\nvar RegExpSourceList = class {\n  _items;\n  _hasAnchors;\n  _cached;\n  _anchorCache;\n  constructor() {\n    this._items = [];\n    this._hasAnchors = false;\n    this._cached = null;\n    this._anchorCache = {\n      A0_G0: null,\n      A0_G1: null,\n      A1_G0: null,\n      A1_G1: null\n    };\n  }\n  dispose() {\n    this._disposeCaches();\n  }\n  _disposeCaches() {\n    if (this._cached) {\n      this._cached.dispose();\n      this._cached = null;\n    }\n    if (this._anchorCache.A0_G0) {\n      this._anchorCache.A0_G0.dispose();\n      this._anchorCache.A0_G0 = null;\n    }\n    if (this._anchorCache.A0_G1) {\n      this._anchorCache.A0_G1.dispose();\n      this._anchorCache.A0_G1 = null;\n    }\n    if (this._anchorCache.A1_G0) {\n      this._anchorCache.A1_G0.dispose();\n      this._anchorCache.A1_G0 = null;\n    }\n    if (this._anchorCache.A1_G1) {\n      this._anchorCache.A1_G1.dispose();\n      this._anchorCache.A1_G1 = null;\n    }\n  }\n  push(item) {\n    this._items.push(item);\n    this._hasAnchors = this._hasAnchors || item.hasAnchor;\n  }\n  unshift(item) {\n    this._items.unshift(item);\n    this._hasAnchors = this._hasAnchors || item.hasAnchor;\n  }\n  length() {\n    return this._items.length;\n  }\n  setSource(index, newSource) {\n    if (this._items[index].source !== newSource) {\n      this._disposeCaches();\n      this._items[index].setSource(newSource);\n    }\n  }\n  compile(onigLib) {\n    if (!this._cached) {\n      let regExps = this._items.map((e) => e.source);\n      this._cached = new CompiledRule(onigLib, regExps, this._items.map((e) => e.ruleId));\n    }\n    return this._cached;\n  }\n  compileAG(onigLib, allowA, allowG) {\n    if (!this._hasAnchors) {\n      return this.compile(onigLib);\n    } else {\n      if (allowA) {\n        if (allowG) {\n          if (!this._anchorCache.A1_G1) {\n            this._anchorCache.A1_G1 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A1_G1;\n        } else {\n          if (!this._anchorCache.A1_G0) {\n            this._anchorCache.A1_G0 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A1_G0;\n        }\n      } else {\n        if (allowG) {\n          if (!this._anchorCache.A0_G1) {\n            this._anchorCache.A0_G1 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A0_G1;\n        } else {\n          if (!this._anchorCache.A0_G0) {\n            this._anchorCache.A0_G0 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A0_G0;\n        }\n      }\n    }\n  }\n  _resolveAnchors(onigLib, allowA, allowG) {\n    let regExps = this._items.map((e) => e.resolveAnchors(allowA, allowG));\n    return new CompiledRule(onigLib, regExps, this._items.map((e) => e.ruleId));\n  }\n};\nvar CompiledRule = class {\n  constructor(onigLib, regExps, rules) {\n    this.regExps = regExps;\n    this.rules = rules;\n    this.scanner = onigLib.createOnigScanner(regExps);\n  }\n  scanner;\n  dispose() {\n    if (typeof this.scanner.dispose === \"function\") {\n      this.scanner.dispose();\n    }\n  }\n  toString() {\n    const r = [];\n    for (let i = 0, len = this.rules.length; i < len; i++) {\n      r.push(\"   - \" + this.rules[i] + \": \" + this.regExps[i]);\n    }\n    return r.join(\"\\n\");\n  }\n  findNextMatchSync(string, startPosition, options) {\n    const result = this.scanner.findNextMatchSync(string, startPosition, options);\n    if (!result) {\n      return null;\n    }\n    return {\n      ruleId: this.rules[result.index],\n      captureIndices: result.captureIndices\n    };\n  }\n};\n\n// src/grammar/basicScopesAttributeProvider.ts\nvar BasicScopeAttributes = class {\n  constructor(languageId, tokenType) {\n    this.languageId = languageId;\n    this.tokenType = tokenType;\n  }\n};\nvar BasicScopeAttributesProvider = class _BasicScopeAttributesProvider {\n  _defaultAttributes;\n  _embeddedLanguagesMatcher;\n  constructor(initialLanguageId, embeddedLanguages) {\n    this._defaultAttributes = new BasicScopeAttributes(initialLanguageId, 8 /* NotSet */);\n    this._embeddedLanguagesMatcher = new ScopeMatcher(Object.entries(embeddedLanguages || {}));\n  }\n  getDefaultAttributes() {\n    return this._defaultAttributes;\n  }\n  getBasicScopeAttributes(scopeName) {\n    if (scopeName === null) {\n      return _BasicScopeAttributesProvider._NULL_SCOPE_METADATA;\n    }\n    return this._getBasicScopeAttributes.get(scopeName);\n  }\n  static _NULL_SCOPE_METADATA = new BasicScopeAttributes(0, 0);\n  _getBasicScopeAttributes = new CachedFn((scopeName) => {\n    const languageId = this._scopeToLanguage(scopeName);\n    const standardTokenType = this._toStandardTokenType(scopeName);\n    return new BasicScopeAttributes(languageId, standardTokenType);\n  });\n  /**\n   * Given a produced TM scope, return the language that token describes or null if unknown.\n   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null\n   */\n  _scopeToLanguage(scope) {\n    return this._embeddedLanguagesMatcher.match(scope) || 0;\n  }\n  _toStandardTokenType(scopeName) {\n    const m = scopeName.match(_BasicScopeAttributesProvider.STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n      return 8 /* NotSet */;\n    }\n    switch (m[1]) {\n      case \"comment\":\n        return 1 /* Comment */;\n      case \"string\":\n        return 2 /* String */;\n      case \"regex\":\n        return 3 /* RegEx */;\n      case \"meta.embedded\":\n        return 0 /* Other */;\n    }\n    throw new Error(\"Unexpected match for standard token type!\");\n  }\n  static STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|meta\\.embedded)\\b/;\n};\nvar ScopeMatcher = class {\n  values;\n  scopesRegExp;\n  constructor(values) {\n    if (values.length === 0) {\n      this.values = null;\n      this.scopesRegExp = null;\n    } else {\n      this.values = new Map(values);\n      const escapedScopes = values.map(\n        ([scopeName, value]) => escapeRegExpCharacters(scopeName)\n      );\n      escapedScopes.sort();\n      escapedScopes.reverse();\n      this.scopesRegExp = new RegExp(\n        `^((${escapedScopes.join(\")|(\")}))($|\\\\.)`,\n        \"\"\n      );\n    }\n  }\n  match(scope) {\n    if (!this.scopesRegExp) {\n      return void 0;\n    }\n    const m = scope.match(this.scopesRegExp);\n    if (!m) {\n      return void 0;\n    }\n    return this.values.get(m[1]);\n  }\n};\n\n// src/debug.ts\nvar DebugFlags = {\n  InDebugMode: typeof process !== \"undefined\" && !!process.env[\"VSCODE_TEXTMATE_DEBUG\"]\n};\nvar UseOnigurumaFindOptions = false;\n\n// src/grammar/tokenizeString.ts\nvar TokenizeStringResult = class {\n  constructor(stack, stoppedEarly) {\n    this.stack = stack;\n    this.stoppedEarly = stoppedEarly;\n  }\n};\nfunction _tokenizeString(grammar, lineText, isFirstLine, linePos, stack, lineTokens, checkWhileConditions, timeLimit) {\n  const lineLength = lineText.content.length;\n  let STOP = false;\n  let anchorPosition = -1;\n  if (checkWhileConditions) {\n    const whileCheckResult = _checkWhileConditions(\n      grammar,\n      lineText,\n      isFirstLine,\n      linePos,\n      stack,\n      lineTokens\n    );\n    stack = whileCheckResult.stack;\n    linePos = whileCheckResult.linePos;\n    isFirstLine = whileCheckResult.isFirstLine;\n    anchorPosition = whileCheckResult.anchorPosition;\n  }\n  const startTime = Date.now();\n  while (!STOP) {\n    if (timeLimit !== 0) {\n      const elapsedTime = Date.now() - startTime;\n      if (elapsedTime > timeLimit) {\n        return new TokenizeStringResult(stack, true);\n      }\n    }\n    scanNext();\n  }\n  return new TokenizeStringResult(stack, false);\n  function scanNext() {\n    if (false) {}\n    const r = matchRuleOrInjections(\n      grammar,\n      lineText,\n      isFirstLine,\n      linePos,\n      stack,\n      anchorPosition\n    );\n    if (!r) {\n      lineTokens.produce(stack, lineLength);\n      STOP = true;\n      return;\n    }\n    const captureIndices = r.captureIndices;\n    const matchedRuleId = r.matchedRuleId;\n    const hasAdvanced = captureIndices && captureIndices.length > 0 ? captureIndices[0].end > linePos : false;\n    if (matchedRuleId === endRuleId) {\n      const poppedRule = stack.getRule(grammar);\n      if (false) {}\n      lineTokens.produce(stack, captureIndices[0].start);\n      stack = stack.withContentNameScopesList(stack.nameScopesList);\n      handleCaptures(\n        grammar,\n        lineText,\n        isFirstLine,\n        stack,\n        lineTokens,\n        poppedRule.endCaptures,\n        captureIndices\n      );\n      lineTokens.produce(stack, captureIndices[0].end);\n      const popped = stack;\n      stack = stack.parent;\n      anchorPosition = popped.getAnchorPos();\n      if (!hasAdvanced && popped.getEnterPos() === linePos) {\n        if (false) {}\n        stack = popped;\n        lineTokens.produce(stack, lineLength);\n        STOP = true;\n        return;\n      }\n    } else {\n      const _rule = grammar.getRule(matchedRuleId);\n      lineTokens.produce(stack, captureIndices[0].start);\n      const beforePush = stack;\n      const scopeName = _rule.getName(lineText.content, captureIndices);\n      const nameScopesList = stack.contentNameScopesList.pushAttributed(\n        scopeName,\n        grammar\n      );\n      stack = stack.push(\n        matchedRuleId,\n        linePos,\n        anchorPosition,\n        captureIndices[0].end === lineLength,\n        null,\n        nameScopesList,\n        nameScopesList\n      );\n      if (_rule instanceof BeginEndRule) {\n        const pushedRule = _rule;\n        if (false) {}\n        handleCaptures(\n          grammar,\n          lineText,\n          isFirstLine,\n          stack,\n          lineTokens,\n          pushedRule.beginCaptures,\n          captureIndices\n        );\n        lineTokens.produce(stack, captureIndices[0].end);\n        anchorPosition = captureIndices[0].end;\n        const contentName = pushedRule.getContentName(\n          lineText.content,\n          captureIndices\n        );\n        const contentNameScopesList = nameScopesList.pushAttributed(\n          contentName,\n          grammar\n        );\n        stack = stack.withContentNameScopesList(contentNameScopesList);\n        if (pushedRule.endHasBackReferences) {\n          stack = stack.withEndRule(\n            pushedRule.getEndWithResolvedBackReferences(\n              lineText.content,\n              captureIndices\n            )\n          );\n        }\n        if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n          if (false) {}\n          stack = stack.pop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      } else if (_rule instanceof BeginWhileRule) {\n        const pushedRule = _rule;\n        if (false) {}\n        handleCaptures(\n          grammar,\n          lineText,\n          isFirstLine,\n          stack,\n          lineTokens,\n          pushedRule.beginCaptures,\n          captureIndices\n        );\n        lineTokens.produce(stack, captureIndices[0].end);\n        anchorPosition = captureIndices[0].end;\n        const contentName = pushedRule.getContentName(\n          lineText.content,\n          captureIndices\n        );\n        const contentNameScopesList = nameScopesList.pushAttributed(\n          contentName,\n          grammar\n        );\n        stack = stack.withContentNameScopesList(contentNameScopesList);\n        if (pushedRule.whileHasBackReferences) {\n          stack = stack.withEndRule(\n            pushedRule.getWhileWithResolvedBackReferences(\n              lineText.content,\n              captureIndices\n            )\n          );\n        }\n        if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n          if (false) {}\n          stack = stack.pop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      } else {\n        const matchingRule = _rule;\n        if (false) {}\n        handleCaptures(\n          grammar,\n          lineText,\n          isFirstLine,\n          stack,\n          lineTokens,\n          matchingRule.captures,\n          captureIndices\n        );\n        lineTokens.produce(stack, captureIndices[0].end);\n        stack = stack.pop();\n        if (!hasAdvanced) {\n          if (false) {}\n          stack = stack.safePop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      }\n    }\n    if (captureIndices[0].end > linePos) {\n      linePos = captureIndices[0].end;\n      isFirstLine = false;\n    }\n  }\n}\nfunction _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens) {\n  let anchorPosition = stack.beginRuleCapturedEOL ? 0 : -1;\n  const whileRules = [];\n  for (let node = stack; node; node = node.pop()) {\n    const nodeRule = node.getRule(grammar);\n    if (nodeRule instanceof BeginWhileRule) {\n      whileRules.push({\n        rule: nodeRule,\n        stack: node\n      });\n    }\n  }\n  for (let whileRule = whileRules.pop(); whileRule; whileRule = whileRules.pop()) {\n    const { ruleScanner, findOptions } = prepareRuleWhileSearch(whileRule.rule, grammar, whileRule.stack.endRule, isFirstLine, linePos === anchorPosition);\n    const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n    if (false) {}\n    if (r) {\n      const matchedRuleId = r.ruleId;\n      if (matchedRuleId !== whileRuleId) {\n        stack = whileRule.stack.pop();\n        break;\n      }\n      if (r.captureIndices && r.captureIndices.length) {\n        lineTokens.produce(whileRule.stack, r.captureIndices[0].start);\n        handleCaptures(grammar, lineText, isFirstLine, whileRule.stack, lineTokens, whileRule.rule.whileCaptures, r.captureIndices);\n        lineTokens.produce(whileRule.stack, r.captureIndices[0].end);\n        anchorPosition = r.captureIndices[0].end;\n        if (r.captureIndices[0].end > linePos) {\n          linePos = r.captureIndices[0].end;\n          isFirstLine = false;\n        }\n      }\n    } else {\n      if (false) {}\n      stack = whileRule.stack.pop();\n      break;\n    }\n  }\n  return { stack, linePos, anchorPosition, isFirstLine };\n}\nfunction matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  const matchResult = matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n  const injections = grammar.getInjections();\n  if (injections.length === 0) {\n    return matchResult;\n  }\n  const injectionResult = matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n  if (!injectionResult) {\n    return matchResult;\n  }\n  if (!matchResult) {\n    return injectionResult;\n  }\n  const matchResultScore = matchResult.captureIndices[0].start;\n  const injectionResultScore = injectionResult.captureIndices[0].start;\n  if (injectionResultScore < matchResultScore || injectionResult.priorityMatch && injectionResultScore === matchResultScore) {\n    return injectionResult;\n  }\n  return matchResult;\n}\nfunction matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  const rule = stack.getRule(grammar);\n  const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, stack.endRule, isFirstLine, linePos === anchorPosition);\n  const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n  if (r) {\n    return {\n      captureIndices: r.captureIndices,\n      matchedRuleId: r.ruleId\n    };\n  }\n  return null;\n}\nfunction matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  let bestMatchRating = Number.MAX_VALUE;\n  let bestMatchCaptureIndices = null;\n  let bestMatchRuleId;\n  let bestMatchResultPriority = 0;\n  const scopes = stack.contentNameScopesList.getScopeNames();\n  for (let i = 0, len = injections.length; i < len; i++) {\n    const injection = injections[i];\n    if (!injection.matcher(scopes)) {\n      continue;\n    }\n    const rule = grammar.getRule(injection.ruleId);\n    const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, null, isFirstLine, linePos === anchorPosition);\n    const matchResult = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n    if (!matchResult) {\n      continue;\n    }\n    if (false) {}\n    const matchRating = matchResult.captureIndices[0].start;\n    if (matchRating >= bestMatchRating) {\n      continue;\n    }\n    bestMatchRating = matchRating;\n    bestMatchCaptureIndices = matchResult.captureIndices;\n    bestMatchRuleId = matchResult.ruleId;\n    bestMatchResultPriority = injection.priority;\n    if (bestMatchRating === linePos) {\n      break;\n    }\n  }\n  if (bestMatchCaptureIndices) {\n    return {\n      priorityMatch: bestMatchResultPriority === -1,\n      captureIndices: bestMatchCaptureIndices,\n      matchedRuleId: bestMatchRuleId\n    };\n  }\n  return null;\n}\nfunction prepareRuleSearch(rule, grammar, endRegexSource, allowA, allowG) {\n  if (UseOnigurumaFindOptions) {\n    const ruleScanner2 = rule.compile(grammar, endRegexSource);\n    const findOptions = getFindOptions(allowA, allowG);\n    return { ruleScanner: ruleScanner2, findOptions };\n  }\n  const ruleScanner = rule.compileAG(grammar, endRegexSource, allowA, allowG);\n  return { ruleScanner, findOptions: 0 /* None */ };\n}\nfunction prepareRuleWhileSearch(rule, grammar, endRegexSource, allowA, allowG) {\n  if (UseOnigurumaFindOptions) {\n    const ruleScanner2 = rule.compileWhile(grammar, endRegexSource);\n    const findOptions = getFindOptions(allowA, allowG);\n    return { ruleScanner: ruleScanner2, findOptions };\n  }\n  const ruleScanner = rule.compileWhileAG(grammar, endRegexSource, allowA, allowG);\n  return { ruleScanner, findOptions: 0 /* None */ };\n}\nfunction getFindOptions(allowA, allowG) {\n  let options = 0 /* None */;\n  if (!allowA) {\n    options |= 1 /* NotBeginString */;\n  }\n  if (!allowG) {\n    options |= 4 /* NotBeginPosition */;\n  }\n  return options;\n}\nfunction handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, captures, captureIndices) {\n  if (captures.length === 0) {\n    return;\n  }\n  const lineTextContent = lineText.content;\n  const len = Math.min(captures.length, captureIndices.length);\n  const localStack = [];\n  const maxEnd = captureIndices[0].end;\n  for (let i = 0; i < len; i++) {\n    const captureRule = captures[i];\n    if (captureRule === null) {\n      continue;\n    }\n    const captureIndex = captureIndices[i];\n    if (captureIndex.length === 0) {\n      continue;\n    }\n    if (captureIndex.start > maxEnd) {\n      break;\n    }\n    while (localStack.length > 0 && localStack[localStack.length - 1].endPos <= captureIndex.start) {\n      lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n      localStack.pop();\n    }\n    if (localStack.length > 0) {\n      lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, captureIndex.start);\n    } else {\n      lineTokens.produce(stack, captureIndex.start);\n    }\n    if (captureRule.retokenizeCapturedWithRuleId) {\n      const scopeName = captureRule.getName(lineTextContent, captureIndices);\n      const nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);\n      const contentName = captureRule.getContentName(lineTextContent, captureIndices);\n      const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);\n      const stackClone = stack.push(captureRule.retokenizeCapturedWithRuleId, captureIndex.start, -1, false, null, nameScopesList, contentNameScopesList);\n      const onigSubStr = grammar.createOnigString(lineTextContent.substring(0, captureIndex.end));\n      _tokenizeString(\n        grammar,\n        onigSubStr,\n        isFirstLine && captureIndex.start === 0,\n        captureIndex.start,\n        stackClone,\n        lineTokens,\n        false,\n        /* no time limit */\n        0\n      );\n      disposeOnigString(onigSubStr);\n      continue;\n    }\n    const captureRuleScopeName = captureRule.getName(lineTextContent, captureIndices);\n    if (captureRuleScopeName !== null) {\n      const base = localStack.length > 0 ? localStack[localStack.length - 1].scopes : stack.contentNameScopesList;\n      const captureRuleScopesList = base.pushAttributed(captureRuleScopeName, grammar);\n      localStack.push(new LocalStackElement(captureRuleScopesList, captureIndex.end));\n    }\n  }\n  while (localStack.length > 0) {\n    lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n    localStack.pop();\n  }\n}\nvar LocalStackElement = class {\n  scopes;\n  endPos;\n  constructor(scopes, endPos) {\n    this.scopes = scopes;\n    this.endPos = endPos;\n  }\n};\n\n// src/grammar/grammar.ts\nfunction createGrammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib) {\n  return new Grammar(\n    scopeName,\n    grammar,\n    initialLanguage,\n    embeddedLanguages,\n    tokenTypes,\n    balancedBracketSelectors,\n    grammarRepository,\n    onigLib\n  );\n}\nfunction collectInjections(result, selector, rule, ruleFactoryHelper, grammar) {\n  const matchers = createMatchers(selector, nameMatcher);\n  const ruleId = RuleFactory.getCompiledRuleId(rule, ruleFactoryHelper, grammar.repository);\n  for (const matcher of matchers) {\n    result.push({\n      debugSelector: selector,\n      matcher: matcher.matcher,\n      ruleId,\n      grammar,\n      priority: matcher.priority\n    });\n  }\n}\nfunction nameMatcher(identifers, scopes) {\n  if (scopes.length < identifers.length) {\n    return false;\n  }\n  let lastIndex = 0;\n  return identifers.every((identifier) => {\n    for (let i = lastIndex; i < scopes.length; i++) {\n      if (scopesAreMatching(scopes[i], identifier)) {\n        lastIndex = i + 1;\n        return true;\n      }\n    }\n    return false;\n  });\n}\nfunction scopesAreMatching(thisScopeName, scopeName) {\n  if (!thisScopeName) {\n    return false;\n  }\n  if (thisScopeName === scopeName) {\n    return true;\n  }\n  const len = scopeName.length;\n  return thisScopeName.length > len && thisScopeName.substr(0, len) === scopeName && thisScopeName[len] === \".\";\n}\nvar Grammar = class {\n  constructor(_rootScopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, _onigLib) {\n    this._rootScopeName = _rootScopeName;\n    this.balancedBracketSelectors = balancedBracketSelectors;\n    this._onigLib = _onigLib;\n    this._basicScopeAttributesProvider = new BasicScopeAttributesProvider(\n      initialLanguage,\n      embeddedLanguages\n    );\n    this._rootId = -1;\n    this._lastRuleId = 0;\n    this._ruleId2desc = [null];\n    this._includedGrammars = {};\n    this._grammarRepository = grammarRepository;\n    this._grammar = initGrammar(grammar, null);\n    this._injections = null;\n    this._tokenTypeMatchers = [];\n    if (tokenTypes) {\n      for (const selector of Object.keys(tokenTypes)) {\n        const matchers = createMatchers(selector, nameMatcher);\n        for (const matcher of matchers) {\n          this._tokenTypeMatchers.push({\n            matcher: matcher.matcher,\n            type: tokenTypes[selector]\n          });\n        }\n      }\n    }\n  }\n  _rootId;\n  _lastRuleId;\n  _ruleId2desc;\n  _includedGrammars;\n  _grammarRepository;\n  _grammar;\n  _injections;\n  _basicScopeAttributesProvider;\n  _tokenTypeMatchers;\n  get themeProvider() {\n    return this._grammarRepository;\n  }\n  dispose() {\n    for (const rule of this._ruleId2desc) {\n      if (rule) {\n        rule.dispose();\n      }\n    }\n  }\n  createOnigScanner(sources) {\n    return this._onigLib.createOnigScanner(sources);\n  }\n  createOnigString(sources) {\n    return this._onigLib.createOnigString(sources);\n  }\n  getMetadataForScope(scope) {\n    return this._basicScopeAttributesProvider.getBasicScopeAttributes(scope);\n  }\n  _collectInjections() {\n    const grammarRepository = {\n      lookup: (scopeName2) => {\n        if (scopeName2 === this._rootScopeName) {\n          return this._grammar;\n        }\n        return this.getExternalGrammar(scopeName2);\n      },\n      injections: (scopeName2) => {\n        return this._grammarRepository.injections(scopeName2);\n      }\n    };\n    const result = [];\n    const scopeName = this._rootScopeName;\n    const grammar = grammarRepository.lookup(scopeName);\n    if (grammar) {\n      const rawInjections = grammar.injections;\n      if (rawInjections) {\n        for (let expression in rawInjections) {\n          collectInjections(\n            result,\n            expression,\n            rawInjections[expression],\n            this,\n            grammar\n          );\n        }\n      }\n      const injectionScopeNames = this._grammarRepository.injections(scopeName);\n      if (injectionScopeNames) {\n        injectionScopeNames.forEach((injectionScopeName) => {\n          const injectionGrammar = this.getExternalGrammar(injectionScopeName);\n          if (injectionGrammar) {\n            const selector = injectionGrammar.injectionSelector;\n            if (selector) {\n              collectInjections(\n                result,\n                selector,\n                injectionGrammar,\n                this,\n                injectionGrammar\n              );\n            }\n          }\n        });\n      }\n    }\n    result.sort((i1, i2) => i1.priority - i2.priority);\n    return result;\n  }\n  getInjections() {\n    if (this._injections === null) {\n      this._injections = this._collectInjections();\n    }\n    return this._injections;\n  }\n  registerRule(factory) {\n    const id = ++this._lastRuleId;\n    const result = factory(ruleIdFromNumber(id));\n    this._ruleId2desc[id] = result;\n    return result;\n  }\n  getRule(ruleId) {\n    return this._ruleId2desc[ruleIdToNumber(ruleId)];\n  }\n  getExternalGrammar(scopeName, repository) {\n    if (this._includedGrammars[scopeName]) {\n      return this._includedGrammars[scopeName];\n    } else if (this._grammarRepository) {\n      const rawIncludedGrammar = this._grammarRepository.lookup(scopeName);\n      if (rawIncludedGrammar) {\n        this._includedGrammars[scopeName] = initGrammar(\n          rawIncludedGrammar,\n          repository && repository.$base\n        );\n        return this._includedGrammars[scopeName];\n      }\n    }\n    return void 0;\n  }\n  tokenizeLine(lineText, prevState, timeLimit = 0) {\n    const r = this._tokenize(lineText, prevState, false, timeLimit);\n    return {\n      tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),\n      ruleStack: r.ruleStack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n  tokenizeLine2(lineText, prevState, timeLimit = 0) {\n    const r = this._tokenize(lineText, prevState, true, timeLimit);\n    return {\n      tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),\n      ruleStack: r.ruleStack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n  _tokenize(lineText, prevState, emitBinaryTokens, timeLimit) {\n    if (this._rootId === -1) {\n      this._rootId = RuleFactory.getCompiledRuleId(\n        this._grammar.repository.$self,\n        this,\n        this._grammar.repository\n      );\n      this.getInjections();\n    }\n    let isFirstLine;\n    if (!prevState || prevState === StateStackImpl.NULL) {\n      isFirstLine = true;\n      const rawDefaultMetadata = this._basicScopeAttributesProvider.getDefaultAttributes();\n      const defaultStyle = this.themeProvider.getDefaults();\n      const defaultMetadata = EncodedTokenMetadata.set(\n        0,\n        rawDefaultMetadata.languageId,\n        rawDefaultMetadata.tokenType,\n        null,\n        defaultStyle.fontStyle,\n        defaultStyle.foregroundId,\n        defaultStyle.backgroundId\n      );\n      const rootScopeName = this.getRule(this._rootId).getName(\n        null,\n        null\n      );\n      let scopeList;\n      if (rootScopeName) {\n        scopeList = AttributedScopeStack.createRootAndLookUpScopeName(\n          rootScopeName,\n          defaultMetadata,\n          this\n        );\n      } else {\n        scopeList = AttributedScopeStack.createRoot(\n          \"unknown\",\n          defaultMetadata\n        );\n      }\n      prevState = new StateStackImpl(\n        null,\n        this._rootId,\n        -1,\n        -1,\n        false,\n        null,\n        scopeList,\n        scopeList\n      );\n    } else {\n      isFirstLine = false;\n      prevState.reset();\n    }\n    lineText = lineText + \"\\n\";\n    const onigLineText = this.createOnigString(lineText);\n    const lineLength = onigLineText.content.length;\n    const lineTokens = new LineTokens(\n      emitBinaryTokens,\n      lineText,\n      this._tokenTypeMatchers,\n      this.balancedBracketSelectors\n    );\n    const r = _tokenizeString(\n      this,\n      onigLineText,\n      isFirstLine,\n      0,\n      prevState,\n      lineTokens,\n      true,\n      timeLimit\n    );\n    disposeOnigString(onigLineText);\n    return {\n      lineLength,\n      lineTokens,\n      ruleStack: r.stack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n};\nfunction initGrammar(grammar, base) {\n  grammar = clone(grammar);\n  grammar.repository = grammar.repository || {};\n  grammar.repository.$self = {\n    $vscodeTextmateLocation: grammar.$vscodeTextmateLocation,\n    patterns: grammar.patterns,\n    name: grammar.scopeName\n  };\n  grammar.repository.$base = base || grammar.repository.$self;\n  return grammar;\n}\nvar AttributedScopeStack = class _AttributedScopeStack {\n  /**\n   * Invariant:\n   * ```\n   * if (parent && !scopePath.extends(parent.scopePath)) {\n   * \tthrow new Error();\n   * }\n   * ```\n   */\n  constructor(parent, scopePath, tokenAttributes) {\n    this.parent = parent;\n    this.scopePath = scopePath;\n    this.tokenAttributes = tokenAttributes;\n  }\n  static fromExtension(namesScopeList, contentNameScopesList) {\n    let current = namesScopeList;\n    let scopeNames = namesScopeList?.scopePath ?? null;\n    for (const frame of contentNameScopesList) {\n      scopeNames = ScopeStack.push(scopeNames, frame.scopeNames);\n      current = new _AttributedScopeStack(current, scopeNames, frame.encodedTokenAttributes);\n    }\n    return current;\n  }\n  static createRoot(scopeName, tokenAttributes) {\n    return new _AttributedScopeStack(null, new ScopeStack(null, scopeName), tokenAttributes);\n  }\n  static createRootAndLookUpScopeName(scopeName, tokenAttributes, grammar) {\n    const rawRootMetadata = grammar.getMetadataForScope(scopeName);\n    const scopePath = new ScopeStack(null, scopeName);\n    const rootStyle = grammar.themeProvider.themeMatch(scopePath);\n    const resolvedTokenAttributes = _AttributedScopeStack.mergeAttributes(\n      tokenAttributes,\n      rawRootMetadata,\n      rootStyle\n    );\n    return new _AttributedScopeStack(null, scopePath, resolvedTokenAttributes);\n  }\n  get scopeName() {\n    return this.scopePath.scopeName;\n  }\n  toString() {\n    return this.getScopeNames().join(\" \");\n  }\n  equals(other) {\n    return _AttributedScopeStack.equals(this, other);\n  }\n  static equals(a, b) {\n    do {\n      if (a === b) {\n        return true;\n      }\n      if (!a && !b) {\n        return true;\n      }\n      if (!a || !b) {\n        return false;\n      }\n      if (a.scopeName !== b.scopeName || a.tokenAttributes !== b.tokenAttributes) {\n        return false;\n      }\n      a = a.parent;\n      b = b.parent;\n    } while (true);\n  }\n  static mergeAttributes(existingTokenAttributes, basicScopeAttributes, styleAttributes) {\n    let fontStyle = -1 /* NotSet */;\n    let foreground = 0;\n    let background = 0;\n    if (styleAttributes !== null) {\n      fontStyle = styleAttributes.fontStyle;\n      foreground = styleAttributes.foregroundId;\n      background = styleAttributes.backgroundId;\n    }\n    return EncodedTokenMetadata.set(\n      existingTokenAttributes,\n      basicScopeAttributes.languageId,\n      basicScopeAttributes.tokenType,\n      null,\n      fontStyle,\n      foreground,\n      background\n    );\n  }\n  pushAttributed(scopePath, grammar) {\n    if (scopePath === null) {\n      return this;\n    }\n    if (scopePath.indexOf(\" \") === -1) {\n      return _AttributedScopeStack._pushAttributed(this, scopePath, grammar);\n    }\n    const scopes = scopePath.split(/ /g);\n    let result = this;\n    for (const scope of scopes) {\n      result = _AttributedScopeStack._pushAttributed(result, scope, grammar);\n    }\n    return result;\n  }\n  static _pushAttributed(target, scopeName, grammar) {\n    const rawMetadata = grammar.getMetadataForScope(scopeName);\n    const newPath = target.scopePath.push(scopeName);\n    const scopeThemeMatchResult = grammar.themeProvider.themeMatch(newPath);\n    const metadata = _AttributedScopeStack.mergeAttributes(\n      target.tokenAttributes,\n      rawMetadata,\n      scopeThemeMatchResult\n    );\n    return new _AttributedScopeStack(target, newPath, metadata);\n  }\n  getScopeNames() {\n    return this.scopePath.getSegments();\n  }\n  getExtensionIfDefined(base) {\n    const result = [];\n    let self = this;\n    while (self && self !== base) {\n      result.push({\n        encodedTokenAttributes: self.tokenAttributes,\n        scopeNames: self.scopePath.getExtensionIfDefined(self.parent?.scopePath ?? null)\n      });\n      self = self.parent;\n    }\n    return self === base ? result.reverse() : void 0;\n  }\n};\nvar StateStackImpl = class _StateStackImpl {\n  /**\n   * Invariant:\n   * ```\n   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {\n   * \tthrow new Error();\n   * }\n   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {\n   * \tthrow new Error();\n   * }\n   * ```\n   */\n  constructor(parent, ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {\n    this.parent = parent;\n    this.ruleId = ruleId;\n    this.beginRuleCapturedEOL = beginRuleCapturedEOL;\n    this.endRule = endRule;\n    this.nameScopesList = nameScopesList;\n    this.contentNameScopesList = contentNameScopesList;\n    this.depth = this.parent ? this.parent.depth + 1 : 1;\n    this._enterPos = enterPos;\n    this._anchorPos = anchorPos;\n  }\n  _stackElementBrand = void 0;\n  // TODO remove me\n  static NULL = new _StateStackImpl(\n    null,\n    0,\n    0,\n    0,\n    false,\n    null,\n    null,\n    null\n  );\n  /**\n   * The position on the current line where this state was pushed.\n   * This is relevant only while tokenizing a line, to detect endless loops.\n   * Its value is meaningless across lines.\n   */\n  _enterPos;\n  /**\n   * The captured anchor position when this stack element was pushed.\n   * This is relevant only while tokenizing a line, to restore the anchor position when popping.\n   * Its value is meaningless across lines.\n   */\n  _anchorPos;\n  /**\n   * The depth of the stack.\n   */\n  depth;\n  equals(other) {\n    if (other === null) {\n      return false;\n    }\n    return _StateStackImpl._equals(this, other);\n  }\n  static _equals(a, b) {\n    if (a === b) {\n      return true;\n    }\n    if (!this._structuralEquals(a, b)) {\n      return false;\n    }\n    return AttributedScopeStack.equals(a.contentNameScopesList, b.contentNameScopesList);\n  }\n  /**\n   * A structural equals check. Does not take into account `scopes`.\n   */\n  static _structuralEquals(a, b) {\n    do {\n      if (a === b) {\n        return true;\n      }\n      if (!a && !b) {\n        return true;\n      }\n      if (!a || !b) {\n        return false;\n      }\n      if (a.depth !== b.depth || a.ruleId !== b.ruleId || a.endRule !== b.endRule) {\n        return false;\n      }\n      a = a.parent;\n      b = b.parent;\n    } while (true);\n  }\n  clone() {\n    return this;\n  }\n  static _reset(el) {\n    while (el) {\n      el._enterPos = -1;\n      el._anchorPos = -1;\n      el = el.parent;\n    }\n  }\n  reset() {\n    _StateStackImpl._reset(this);\n  }\n  pop() {\n    return this.parent;\n  }\n  safePop() {\n    if (this.parent) {\n      return this.parent;\n    }\n    return this;\n  }\n  push(ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {\n    return new _StateStackImpl(\n      this,\n      ruleId,\n      enterPos,\n      anchorPos,\n      beginRuleCapturedEOL,\n      endRule,\n      nameScopesList,\n      contentNameScopesList\n    );\n  }\n  getEnterPos() {\n    return this._enterPos;\n  }\n  getAnchorPos() {\n    return this._anchorPos;\n  }\n  getRule(grammar) {\n    return grammar.getRule(this.ruleId);\n  }\n  toString() {\n    const r = [];\n    this._writeString(r, 0);\n    return \"[\" + r.join(\",\") + \"]\";\n  }\n  _writeString(res, outIndex) {\n    if (this.parent) {\n      outIndex = this.parent._writeString(res, outIndex);\n    }\n    res[outIndex++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`;\n    return outIndex;\n  }\n  withContentNameScopesList(contentNameScopeStack) {\n    if (this.contentNameScopesList === contentNameScopeStack) {\n      return this;\n    }\n    return this.parent.push(\n      this.ruleId,\n      this._enterPos,\n      this._anchorPos,\n      this.beginRuleCapturedEOL,\n      this.endRule,\n      this.nameScopesList,\n      contentNameScopeStack\n    );\n  }\n  withEndRule(endRule) {\n    if (this.endRule === endRule) {\n      return this;\n    }\n    return new _StateStackImpl(\n      this.parent,\n      this.ruleId,\n      this._enterPos,\n      this._anchorPos,\n      this.beginRuleCapturedEOL,\n      endRule,\n      this.nameScopesList,\n      this.contentNameScopesList\n    );\n  }\n  // Used to warn of endless loops\n  hasSameRuleAs(other) {\n    let el = this;\n    while (el && el._enterPos === other._enterPos) {\n      if (el.ruleId === other.ruleId) {\n        return true;\n      }\n      el = el.parent;\n    }\n    return false;\n  }\n  toStateStackFrame() {\n    return {\n      ruleId: ruleIdToNumber(this.ruleId),\n      beginRuleCapturedEOL: this.beginRuleCapturedEOL,\n      endRule: this.endRule,\n      nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],\n      contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? []\n    };\n  }\n  static pushFrame(self, frame) {\n    const namesScopeList = AttributedScopeStack.fromExtension(self?.nameScopesList ?? null, frame.nameScopesList);\n    return new _StateStackImpl(\n      self,\n      ruleIdFromNumber(frame.ruleId),\n      frame.enterPos ?? -1,\n      frame.anchorPos ?? -1,\n      frame.beginRuleCapturedEOL,\n      frame.endRule,\n      namesScopeList,\n      AttributedScopeStack.fromExtension(namesScopeList, frame.contentNameScopesList)\n    );\n  }\n};\nvar BalancedBracketSelectors = class {\n  balancedBracketScopes;\n  unbalancedBracketScopes;\n  allowAny = false;\n  constructor(balancedBracketScopes, unbalancedBracketScopes) {\n    this.balancedBracketScopes = balancedBracketScopes.flatMap(\n      (selector) => {\n        if (selector === \"*\") {\n          this.allowAny = true;\n          return [];\n        }\n        return createMatchers(selector, nameMatcher).map((m) => m.matcher);\n      }\n    );\n    this.unbalancedBracketScopes = unbalancedBracketScopes.flatMap(\n      (selector) => createMatchers(selector, nameMatcher).map((m) => m.matcher)\n    );\n  }\n  get matchesAlways() {\n    return this.allowAny && this.unbalancedBracketScopes.length === 0;\n  }\n  get matchesNever() {\n    return this.balancedBracketScopes.length === 0 && !this.allowAny;\n  }\n  match(scopes) {\n    for (const excluder of this.unbalancedBracketScopes) {\n      if (excluder(scopes)) {\n        return false;\n      }\n    }\n    for (const includer of this.balancedBracketScopes) {\n      if (includer(scopes)) {\n        return true;\n      }\n    }\n    return this.allowAny;\n  }\n};\nvar LineTokens = class {\n  constructor(emitBinaryTokens, lineText, tokenTypeOverrides, balancedBracketSelectors) {\n    this.balancedBracketSelectors = balancedBracketSelectors;\n    this._emitBinaryTokens = emitBinaryTokens;\n    this._tokenTypeOverrides = tokenTypeOverrides;\n    if (false) {} else {\n      this._lineText = null;\n    }\n    this._tokens = [];\n    this._binaryTokens = [];\n    this._lastTokenEndIndex = 0;\n  }\n  _emitBinaryTokens;\n  /**\n   * defined only if `false`.\n   */\n  _lineText;\n  /**\n   * used only if `_emitBinaryTokens` is false.\n   */\n  _tokens;\n  /**\n   * used only if `_emitBinaryTokens` is true.\n   */\n  _binaryTokens;\n  _lastTokenEndIndex;\n  _tokenTypeOverrides;\n  produce(stack, endIndex) {\n    this.produceFromScopes(stack.contentNameScopesList, endIndex);\n  }\n  produceFromScopes(scopesList, endIndex) {\n    if (this._lastTokenEndIndex >= endIndex) {\n      return;\n    }\n    if (this._emitBinaryTokens) {\n      let metadata = scopesList?.tokenAttributes ?? 0;\n      let containsBalancedBrackets = false;\n      if (this.balancedBracketSelectors?.matchesAlways) {\n        containsBalancedBrackets = true;\n      }\n      if (this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {\n        const scopes2 = scopesList?.getScopeNames() ?? [];\n        for (const tokenType of this._tokenTypeOverrides) {\n          if (tokenType.matcher(scopes2)) {\n            metadata = EncodedTokenMetadata.set(\n              metadata,\n              0,\n              toOptionalTokenType(tokenType.type),\n              null,\n              -1 /* NotSet */,\n              0,\n              0\n            );\n          }\n        }\n        if (this.balancedBracketSelectors) {\n          containsBalancedBrackets = this.balancedBracketSelectors.match(scopes2);\n        }\n      }\n      if (containsBalancedBrackets) {\n        metadata = EncodedTokenMetadata.set(\n          metadata,\n          0,\n          8 /* NotSet */,\n          containsBalancedBrackets,\n          -1 /* NotSet */,\n          0,\n          0\n        );\n      }\n      if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === metadata) {\n        this._lastTokenEndIndex = endIndex;\n        return;\n      }\n      this._binaryTokens.push(this._lastTokenEndIndex);\n      this._binaryTokens.push(metadata);\n      this._lastTokenEndIndex = endIndex;\n      return;\n    }\n    const scopes = scopesList?.getScopeNames() ?? [];\n    this._tokens.push({\n      startIndex: this._lastTokenEndIndex,\n      endIndex,\n      // value: lineText.substring(lastTokenEndIndex, endIndex),\n      scopes\n    });\n    this._lastTokenEndIndex = endIndex;\n  }\n  getResult(stack, lineLength) {\n    if (this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === lineLength - 1) {\n      this._tokens.pop();\n    }\n    if (this._tokens.length === 0) {\n      this._lastTokenEndIndex = -1;\n      this.produce(stack, lineLength);\n      this._tokens[this._tokens.length - 1].startIndex = 0;\n    }\n    return this._tokens;\n  }\n  getBinaryResult(stack, lineLength) {\n    if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === lineLength - 1) {\n      this._binaryTokens.pop();\n      this._binaryTokens.pop();\n    }\n    if (this._binaryTokens.length === 0) {\n      this._lastTokenEndIndex = -1;\n      this.produce(stack, lineLength);\n      this._binaryTokens[this._binaryTokens.length - 2] = 0;\n    }\n    const result = new Uint32Array(this._binaryTokens.length);\n    for (let i = 0, len = this._binaryTokens.length; i < len; i++) {\n      result[i] = this._binaryTokens[i];\n    }\n    return result;\n  }\n};\n\n// src/registry.ts\nvar SyncRegistry = class {\n  constructor(theme, _onigLib) {\n    this._onigLib = _onigLib;\n    this._theme = theme;\n  }\n  _grammars = /* @__PURE__ */ new Map();\n  _rawGrammars = /* @__PURE__ */ new Map();\n  _injectionGrammars = /* @__PURE__ */ new Map();\n  _theme;\n  dispose() {\n    for (const grammar of this._grammars.values()) {\n      grammar.dispose();\n    }\n  }\n  setTheme(theme) {\n    this._theme = theme;\n  }\n  getColorMap() {\n    return this._theme.getColorMap();\n  }\n  /**\n   * Add `grammar` to registry and return a list of referenced scope names\n   */\n  addGrammar(grammar, injectionScopeNames) {\n    this._rawGrammars.set(grammar.scopeName, grammar);\n    if (injectionScopeNames) {\n      this._injectionGrammars.set(grammar.scopeName, injectionScopeNames);\n    }\n  }\n  /**\n   * Lookup a raw grammar.\n   */\n  lookup(scopeName) {\n    return this._rawGrammars.get(scopeName);\n  }\n  /**\n   * Returns the injections for the given grammar\n   */\n  injections(targetScope) {\n    return this._injectionGrammars.get(targetScope);\n  }\n  /**\n   * Get the default theme settings\n   */\n  getDefaults() {\n    return this._theme.getDefaults();\n  }\n  /**\n   * Match a scope in the theme.\n   */\n  themeMatch(scopePath) {\n    return this._theme.match(scopePath);\n  }\n  /**\n   * Lookup a grammar.\n   */\n  grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {\n    if (!this._grammars.has(scopeName)) {\n      let rawGrammar = this._rawGrammars.get(scopeName);\n      if (!rawGrammar) {\n        return null;\n      }\n      this._grammars.set(scopeName, createGrammar(\n        scopeName,\n        rawGrammar,\n        initialLanguage,\n        embeddedLanguages,\n        tokenTypes,\n        balancedBracketSelectors,\n        this,\n        this._onigLib\n      ));\n    }\n    return this._grammars.get(scopeName);\n  }\n};\n\n// src/index.ts\nvar Registry = class {\n  _options;\n  _syncRegistry;\n  _ensureGrammarCache;\n  constructor(options) {\n    this._options = options;\n    this._syncRegistry = new SyncRegistry(\n      Theme.createFromRawTheme(options.theme, options.colorMap),\n      options.onigLib\n    );\n    this._ensureGrammarCache = /* @__PURE__ */ new Map();\n  }\n  dispose() {\n    this._syncRegistry.dispose();\n  }\n  /**\n   * Change the theme. Once called, no previous `ruleStack` should be used anymore.\n   */\n  setTheme(theme, colorMap) {\n    this._syncRegistry.setTheme(Theme.createFromRawTheme(theme, colorMap));\n  }\n  /**\n   * Returns a lookup array for color ids.\n   */\n  getColorMap() {\n    return this._syncRegistry.getColorMap();\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   * Please do not use language id 0.\n   */\n  loadGrammarWithEmbeddedLanguages(initialScopeName, initialLanguage, embeddedLanguages) {\n    return this.loadGrammarWithConfiguration(initialScopeName, initialLanguage, { embeddedLanguages });\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   * Please do not use language id 0.\n   */\n  loadGrammarWithConfiguration(initialScopeName, initialLanguage, configuration) {\n    return this._loadGrammar(\n      initialScopeName,\n      initialLanguage,\n      configuration.embeddedLanguages,\n      configuration.tokenTypes,\n      new BalancedBracketSelectors(\n        configuration.balancedBracketSelectors || [],\n        configuration.unbalancedBracketSelectors || []\n      )\n    );\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   */\n  loadGrammar(initialScopeName) {\n    return this._loadGrammar(initialScopeName, 0, null, null, null);\n  }\n  _loadGrammar(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {\n    const dependencyProcessor = new ScopeDependencyProcessor(this._syncRegistry, initialScopeName);\n    while (dependencyProcessor.Q.length > 0) {\n      dependencyProcessor.Q.map((request) => this._loadSingleGrammar(request.scopeName));\n      dependencyProcessor.processQueue();\n    }\n    return this._grammarForScopeName(\n      initialScopeName,\n      initialLanguage,\n      embeddedLanguages,\n      tokenTypes,\n      balancedBracketSelectors\n    );\n  }\n  _loadSingleGrammar(scopeName) {\n    if (!this._ensureGrammarCache.has(scopeName)) {\n      this._doLoadSingleGrammar(scopeName);\n      this._ensureGrammarCache.set(scopeName, true);\n    }\n  }\n  _doLoadSingleGrammar(scopeName) {\n    const grammar = this._options.loadGrammar(scopeName);\n    if (grammar) {\n      const injections = typeof this._options.getInjections === \"function\" ? this._options.getInjections(scopeName) : void 0;\n      this._syncRegistry.addGrammar(grammar, injections);\n    }\n  }\n  /**\n   * Adds a rawGrammar.\n   */\n  addGrammar(rawGrammar, injections = [], initialLanguage = 0, embeddedLanguages = null) {\n    this._syncRegistry.addGrammar(rawGrammar, injections);\n    return this._grammarForScopeName(rawGrammar.scopeName, initialLanguage, embeddedLanguages);\n  }\n  /**\n   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.\n   */\n  _grammarForScopeName(scopeName, initialLanguage = 0, embeddedLanguages = null, tokenTypes = null, balancedBracketSelectors = null) {\n    return this._syncRegistry.grammarForScopeName(\n      scopeName,\n      initialLanguage,\n      embeddedLanguages,\n      tokenTypes,\n      balancedBracketSelectors\n    );\n  }\n};\nvar INITIAL = StateStackImpl.NULL;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaGlraWpzK3ZzY29kZS10ZXh0bWF0ZUAxMC4wLjIvbm9kZV9tb2R1bGVzL0BzaGlraWpzL3ZzY29kZS10ZXh0bWF0ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDBCQUEwQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixFQUFFO0FBQ3BCO0FBQ0E7QUFDQSxrQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBLGtCQUFrQixFQUFFO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsRUFBRTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUJBQWlCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsTUFBTTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxTQUFTO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWUsR0FBRyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxQkFBcUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywwQkFBMEI7QUFDeEUsSUFBSTtBQUNKO0FBQ0E7QUFDQSxRQUFRLDhEQUE4RDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBd0Q7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBd0Q7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQSx3REFBd0QsMkNBQTJDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsOENBQThDO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsMkNBQTJDO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0NBQWtDLEdBQUcsb0JBQW9CO0FBQ2xHLGNBQWMsc0JBQXNCLEdBQUcsU0FBUyxJQUFJLFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFdBQVc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBSyxFQUFFLEVBS1Y7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQUssRUFBRSxFQUlWO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUssRUFBRSxFQUlWO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSyxFQUFFLEVBSVY7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLLEVBQUUsRUFJVjtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxZQUFZLEtBQUssRUFBRSxFQUVWO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSyxFQUFFLEVBSVY7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsWUFBWSxLQUFLLEVBQUUsRUFJVjtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSyxFQUFFLEVBSVY7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BELFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0EsUUFBUSxLQUFLLEVBQUUsRUFHVjtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFVBQVUsS0FBSyxFQUFFLEVBRVY7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQkFBMkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFLLEVBQUUsRUFHVjtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZLElBQUksZ0NBQWdDLElBQUksdUNBQXVDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBSyxFQUFFLEVBRVYsQ0FBQztBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsbUJBQW1CO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTRSIsInNvdXJjZXMiOlsiL1VzZXJzL3VhbmVsYV9jb21vL0RvY3VtZW50cy9kZXZlbG9wbWVudC9ub2RlanMvYXJrb3Mvbm9kZV9tb2R1bGVzLy5wbnBtL0BzaGlraWpzK3ZzY29kZS10ZXh0bWF0ZUAxMC4wLjIvbm9kZV9tb2R1bGVzL0BzaGlraWpzL3ZzY29kZS10ZXh0bWF0ZS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy50c1xuZnVuY3Rpb24gY2xvbmUoc29tZXRoaW5nKSB7XG4gIHJldHVybiBkb0Nsb25lKHNvbWV0aGluZyk7XG59XG5mdW5jdGlvbiBkb0Nsb25lKHNvbWV0aGluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShzb21ldGhpbmcpKSB7XG4gICAgcmV0dXJuIGNsb25lQXJyYXkoc29tZXRoaW5nKTtcbiAgfVxuICBpZiAoc29tZXRoaW5nIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHNvbWV0aGluZztcbiAgfVxuICBpZiAodHlwZW9mIHNvbWV0aGluZyA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBjbG9uZU9iaihzb21ldGhpbmcpO1xuICB9XG4gIHJldHVybiBzb21ldGhpbmc7XG59XG5mdW5jdGlvbiBjbG9uZUFycmF5KGFycikge1xuICBsZXQgciA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcltpXSA9IGRvQ2xvbmUoYXJyW2ldKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIGNsb25lT2JqKG9iaikge1xuICBsZXQgciA9IHt9O1xuICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAgcltrZXldID0gZG9DbG9uZShvYmpba2V5XSk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBtZXJnZU9iamVjdHModGFyZ2V0LCAuLi5zb3VyY2VzKSB7XG4gIHNvdXJjZXMuZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgZm9yIChsZXQga2V5IGluIHNvdXJjZSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gYmFzZW5hbWUocGF0aCkge1xuICBjb25zdCBpZHggPSB+cGF0aC5sYXN0SW5kZXhPZihcIi9cIikgfHwgfnBhdGgubGFzdEluZGV4T2YoXCJcXFxcXCIpO1xuICBpZiAoaWR4ID09PSAwKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH0gZWxzZSBpZiAofmlkeCA9PT0gcGF0aC5sZW5ndGggLSAxKSB7XG4gICAgcmV0dXJuIGJhc2VuYW1lKHBhdGguc3Vic3RyaW5nKDAsIHBhdGgubGVuZ3RoIC0gMSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXRoLnN1YnN0cih+aWR4ICsgMSk7XG4gIH1cbn1cbnZhciBDQVBUVVJJTkdfUkVHRVhfU09VUkNFID0gL1xcJChcXGQrKXxcXCR7KFxcZCspOlxcLyhkb3duY2FzZXx1cGNhc2UpfS9nO1xudmFyIFJlZ2V4U291cmNlID0gY2xhc3Mge1xuICBzdGF0aWMgaGFzQ2FwdHVyZXMocmVnZXhTb3VyY2UpIHtcbiAgICBpZiAocmVnZXhTb3VyY2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgQ0FQVFVSSU5HX1JFR0VYX1NPVVJDRS5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiBDQVBUVVJJTkdfUkVHRVhfU09VUkNFLnRlc3QocmVnZXhTb3VyY2UpO1xuICB9XG4gIHN0YXRpYyByZXBsYWNlQ2FwdHVyZXMocmVnZXhTb3VyY2UsIGNhcHR1cmVTb3VyY2UsIGNhcHR1cmVJbmRpY2VzKSB7XG4gICAgcmV0dXJuIHJlZ2V4U291cmNlLnJlcGxhY2UoQ0FQVFVSSU5HX1JFR0VYX1NPVVJDRSwgKG1hdGNoLCBpbmRleCwgY29tbWFuZEluZGV4LCBjb21tYW5kKSA9PiB7XG4gICAgICBsZXQgY2FwdHVyZSA9IGNhcHR1cmVJbmRpY2VzW3BhcnNlSW50KGluZGV4IHx8IGNvbW1hbmRJbmRleCwgMTApXTtcbiAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBjYXB0dXJlU291cmNlLnN1YnN0cmluZyhjYXB0dXJlLnN0YXJ0LCBjYXB0dXJlLmVuZCk7XG4gICAgICAgIHdoaWxlIChyZXN1bHRbMF0gPT09IFwiLlwiKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICBjYXNlIFwiZG93bmNhc2VcIjpcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBjYXNlIFwidXBjYXNlXCI6XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIHN0cmNtcChhLCBiKSB7XG4gIGlmIChhIDwgYikge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHN0ckFyckNtcChhLCBiKSB7XG4gIGlmIChhID09PSBudWxsICYmIGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoIWEpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKCFiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgbGV0IGxlbjEgPSBhLmxlbmd0aDtcbiAgbGV0IGxlbjIgPSBiLmxlbmd0aDtcbiAgaWYgKGxlbjEgPT09IGxlbjIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjE7IGkrKykge1xuICAgICAgbGV0IHJlcyA9IHN0cmNtcChhW2ldLCBiW2ldKTtcbiAgICAgIGlmIChyZXMgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIGxlbjEgLSBsZW4yO1xufVxuZnVuY3Rpb24gaXNWYWxpZEhleENvbG9yKGhleCkge1xuICBpZiAoL14jWzAtOWEtZl17Nn0kL2kudGVzdChoZXgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKC9eI1swLTlhLWZdezh9JC9pLnRlc3QoaGV4KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICgvXiNbMC05YS1mXXszfSQvaS50ZXN0KGhleCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoL14jWzAtOWEtZl17NH0kL2kudGVzdChoZXgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwQ2hhcmFjdGVycyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZSgvW1xcLVxcXFxcXHtcXH1cXCpcXCtcXD9cXHxcXF5cXCRcXC5cXCxcXFtcXF1cXChcXClcXCNcXHNdL2csIFwiXFxcXCQmXCIpO1xufVxudmFyIENhY2hlZEZuID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihmbikge1xuICAgIHRoaXMuZm4gPSBmbjtcbiAgfVxuICBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGdldChrZXkpIHtcbiAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5mbihrZXkpO1xuICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL3RoZW1lLnRzXG52YXIgVGhlbWUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9jb2xvck1hcCwgX2RlZmF1bHRzLCBfcm9vdCkge1xuICAgIHRoaXMuX2NvbG9yTWFwID0gX2NvbG9yTWFwO1xuICAgIHRoaXMuX2RlZmF1bHRzID0gX2RlZmF1bHRzO1xuICAgIHRoaXMuX3Jvb3QgPSBfcm9vdDtcbiAgfVxuICBzdGF0aWMgY3JlYXRlRnJvbVJhd1RoZW1lKHNvdXJjZSwgY29sb3JNYXApIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVGcm9tUGFyc2VkVGhlbWUocGFyc2VUaGVtZShzb3VyY2UpLCBjb2xvck1hcCk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUZyb21QYXJzZWRUaGVtZShzb3VyY2UsIGNvbG9yTWFwKSB7XG4gICAgcmV0dXJuIHJlc29sdmVQYXJzZWRUaGVtZVJ1bGVzKHNvdXJjZSwgY29sb3JNYXApO1xuICB9XG4gIF9jYWNoZWRNYXRjaFJvb3QgPSBuZXcgQ2FjaGVkRm4oXG4gICAgKHNjb3BlTmFtZSkgPT4gdGhpcy5fcm9vdC5tYXRjaChzY29wZU5hbWUpXG4gICk7XG4gIGdldENvbG9yTWFwKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2xvck1hcC5nZXRDb2xvck1hcCgpO1xuICB9XG4gIGdldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWZhdWx0cztcbiAgfVxuICBtYXRjaChzY29wZVBhdGgpIHtcbiAgICBpZiAoc2NvcGVQYXRoID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdHM7XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlTmFtZSA9IHNjb3BlUGF0aC5zY29wZU5hbWU7XG4gICAgY29uc3QgbWF0Y2hpbmdUcmllRWxlbWVudHMgPSB0aGlzLl9jYWNoZWRNYXRjaFJvb3QuZ2V0KHNjb3BlTmFtZSk7XG4gICAgY29uc3QgZWZmZWN0aXZlUnVsZSA9IG1hdGNoaW5nVHJpZUVsZW1lbnRzLmZpbmQoXG4gICAgICAodikgPT4gX3Njb3BlUGF0aE1hdGNoZXNQYXJlbnRTY29wZXMoc2NvcGVQYXRoLnBhcmVudCwgdi5wYXJlbnRTY29wZXMpXG4gICAgKTtcbiAgICBpZiAoIWVmZmVjdGl2ZVJ1bGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0eWxlQXR0cmlidXRlcyhcbiAgICAgIGVmZmVjdGl2ZVJ1bGUuZm9udFN0eWxlLFxuICAgICAgZWZmZWN0aXZlUnVsZS5mb3JlZ3JvdW5kLFxuICAgICAgZWZmZWN0aXZlUnVsZS5iYWNrZ3JvdW5kXG4gICAgKTtcbiAgfVxufTtcbnZhciBTY29wZVN0YWNrID0gY2xhc3MgX1Njb3BlU3RhY2sge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQsIHNjb3BlTmFtZSkge1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuc2NvcGVOYW1lID0gc2NvcGVOYW1lO1xuICB9XG4gIHN0YXRpYyBwdXNoKHBhdGgsIHNjb3BlTmFtZXMpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc2NvcGVOYW1lcykge1xuICAgICAgcGF0aCA9IG5ldyBfU2NvcGVTdGFjayhwYXRoLCBuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgc3RhdGljIGZyb20oLi4uc2VnbWVudHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQgPSBuZXcgX1Njb3BlU3RhY2socmVzdWx0LCBzZWdtZW50c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcHVzaChzY29wZU5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9TY29wZVN0YWNrKHRoaXMsIHNjb3BlTmFtZSk7XG4gIH1cbiAgZ2V0U2VnbWVudHMoKSB7XG4gICAgbGV0IGl0ZW0gPSB0aGlzO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChpdGVtKSB7XG4gICAgICByZXN1bHQucHVzaChpdGVtLnNjb3BlTmFtZSk7XG4gICAgICBpdGVtID0gaXRlbS5wYXJlbnQ7XG4gICAgfVxuICAgIHJlc3VsdC5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTZWdtZW50cygpLmpvaW4oXCIgXCIpO1xuICB9XG4gIGV4dGVuZHMob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyZW50LmV4dGVuZHMob3RoZXIpO1xuICB9XG4gIGdldEV4dGVuc2lvbklmRGVmaW5lZChiYXNlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGl0ZW0gPSB0aGlzO1xuICAgIHdoaWxlIChpdGVtICYmIGl0ZW0gIT09IGJhc2UpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGl0ZW0uc2NvcGVOYW1lKTtcbiAgICAgIGl0ZW0gPSBpdGVtLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW0gPT09IGJhc2UgPyByZXN1bHQucmV2ZXJzZSgpIDogdm9pZCAwO1xuICB9XG59O1xuZnVuY3Rpb24gX3Njb3BlUGF0aE1hdGNoZXNQYXJlbnRTY29wZXMoc2NvcGVQYXRoLCBwYXJlbnRTY29wZXMpIHtcbiAgaWYgKHBhcmVudFNjb3Blcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGFyZW50U2NvcGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCBzY29wZVBhdHRlcm4gPSBwYXJlbnRTY29wZXNbaW5kZXhdO1xuICAgIGxldCBzY29wZU11c3RNYXRjaCA9IGZhbHNlO1xuICAgIGlmIChzY29wZVBhdHRlcm4gPT09IFwiPlwiKSB7XG4gICAgICBpZiAoaW5kZXggPT09IHBhcmVudFNjb3Blcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNjb3BlUGF0dGVybiA9IHBhcmVudFNjb3Blc1srK2luZGV4XTtcbiAgICAgIHNjb3BlTXVzdE1hdGNoID0gdHJ1ZTtcbiAgICB9XG4gICAgd2hpbGUgKHNjb3BlUGF0aCkge1xuICAgICAgaWYgKF9tYXRjaGVzU2NvcGUoc2NvcGVQYXRoLnNjb3BlTmFtZSwgc2NvcGVQYXR0ZXJuKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzY29wZU11c3RNYXRjaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzY29wZVBhdGggPSBzY29wZVBhdGgucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIXNjb3BlUGF0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzY29wZVBhdGggPSBzY29wZVBhdGgucGFyZW50O1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gX21hdGNoZXNTY29wZShzY29wZU5hbWUsIHNjb3BlUGF0dGVybikge1xuICByZXR1cm4gc2NvcGVQYXR0ZXJuID09PSBzY29wZU5hbWUgfHwgc2NvcGVOYW1lLnN0YXJ0c1dpdGgoc2NvcGVQYXR0ZXJuKSAmJiBzY29wZU5hbWVbc2NvcGVQYXR0ZXJuLmxlbmd0aF0gPT09IFwiLlwiO1xufVxudmFyIFN0eWxlQXR0cmlidXRlcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZm9udFN0eWxlLCBmb3JlZ3JvdW5kSWQsIGJhY2tncm91bmRJZCkge1xuICAgIHRoaXMuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgIHRoaXMuZm9yZWdyb3VuZElkID0gZm9yZWdyb3VuZElkO1xuICAgIHRoaXMuYmFja2dyb3VuZElkID0gYmFja2dyb3VuZElkO1xuICB9XG59O1xuZnVuY3Rpb24gcGFyc2VUaGVtZShzb3VyY2UpIHtcbiAgaWYgKCFzb3VyY2UpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFzb3VyY2Uuc2V0dGluZ3MgfHwgIUFycmF5LmlzQXJyYXkoc291cmNlLnNldHRpbmdzKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBsZXQgc2V0dGluZ3MgPSBzb3VyY2Uuc2V0dGluZ3M7XG4gIGxldCByZXN1bHQgPSBbXSwgcmVzdWx0TGVuID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNldHRpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbGV0IGVudHJ5ID0gc2V0dGluZ3NbaV07XG4gICAgaWYgKCFlbnRyeS5zZXR0aW5ncykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCBzY29wZXM7XG4gICAgaWYgKHR5cGVvZiBlbnRyeS5zY29wZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbGV0IF9zY29wZSA9IGVudHJ5LnNjb3BlO1xuICAgICAgX3Njb3BlID0gX3Njb3BlLnJlcGxhY2UoL15bLF0rLywgXCJcIik7XG4gICAgICBfc2NvcGUgPSBfc2NvcGUucmVwbGFjZSgvWyxdKyQvLCBcIlwiKTtcbiAgICAgIHNjb3BlcyA9IF9zY29wZS5zcGxpdChcIixcIik7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVudHJ5LnNjb3BlKSkge1xuICAgICAgc2NvcGVzID0gZW50cnkuc2NvcGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjb3BlcyA9IFtcIlwiXTtcbiAgICB9XG4gICAgbGV0IGZvbnRTdHlsZSA9IC0xIC8qIE5vdFNldCAqLztcbiAgICBpZiAodHlwZW9mIGVudHJ5LnNldHRpbmdzLmZvbnRTdHlsZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZm9udFN0eWxlID0gMCAvKiBOb25lICovO1xuICAgICAgbGV0IHNlZ21lbnRzID0gZW50cnkuc2V0dGluZ3MuZm9udFN0eWxlLnNwbGl0KFwiIFwiKTtcbiAgICAgIGZvciAobGV0IGogPSAwLCBsZW5KID0gc2VnbWVudHMubGVuZ3RoOyBqIDwgbGVuSjsgaisrKSB7XG4gICAgICAgIGxldCBzZWdtZW50ID0gc2VnbWVudHNbal07XG4gICAgICAgIHN3aXRjaCAoc2VnbWVudCkge1xuICAgICAgICAgIGNhc2UgXCJpdGFsaWNcIjpcbiAgICAgICAgICAgIGZvbnRTdHlsZSA9IGZvbnRTdHlsZSB8IDEgLyogSXRhbGljICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImJvbGRcIjpcbiAgICAgICAgICAgIGZvbnRTdHlsZSA9IGZvbnRTdHlsZSB8IDIgLyogQm9sZCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ1bmRlcmxpbmVcIjpcbiAgICAgICAgICAgIGZvbnRTdHlsZSA9IGZvbnRTdHlsZSB8IDQgLyogVW5kZXJsaW5lICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInN0cmlrZXRocm91Z2hcIjpcbiAgICAgICAgICAgIGZvbnRTdHlsZSA9IGZvbnRTdHlsZSB8IDggLyogU3RyaWtldGhyb3VnaCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBmb3JlZ3JvdW5kID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIGVudHJ5LnNldHRpbmdzLmZvcmVncm91bmQgPT09IFwic3RyaW5nXCIgJiYgaXNWYWxpZEhleENvbG9yKGVudHJ5LnNldHRpbmdzLmZvcmVncm91bmQpKSB7XG4gICAgICBmb3JlZ3JvdW5kID0gZW50cnkuc2V0dGluZ3MuZm9yZWdyb3VuZDtcbiAgICB9XG4gICAgbGV0IGJhY2tncm91bmQgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgZW50cnkuc2V0dGluZ3MuYmFja2dyb3VuZCA9PT0gXCJzdHJpbmdcIiAmJiBpc1ZhbGlkSGV4Q29sb3IoZW50cnkuc2V0dGluZ3MuYmFja2dyb3VuZCkpIHtcbiAgICAgIGJhY2tncm91bmQgPSBlbnRyeS5zZXR0aW5ncy5iYWNrZ3JvdW5kO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gMCwgbGVuSiA9IHNjb3Blcy5sZW5ndGg7IGogPCBsZW5KOyBqKyspIHtcbiAgICAgIGxldCBfc2NvcGUgPSBzY29wZXNbal0udHJpbSgpO1xuICAgICAgbGV0IHNlZ21lbnRzID0gX3Njb3BlLnNwbGl0KFwiIFwiKTtcbiAgICAgIGxldCBzY29wZSA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgbGV0IHBhcmVudFNjb3BlcyA9IG51bGw7XG4gICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBwYXJlbnRTY29wZXMgPSBzZWdtZW50cy5zbGljZSgwLCBzZWdtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgICAgcGFyZW50U2NvcGVzLnJldmVyc2UoKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdFtyZXN1bHRMZW4rK10gPSBuZXcgUGFyc2VkVGhlbWVSdWxlKFxuICAgICAgICBzY29wZSxcbiAgICAgICAgcGFyZW50U2NvcGVzLFxuICAgICAgICBpLFxuICAgICAgICBmb250U3R5bGUsXG4gICAgICAgIGZvcmVncm91bmQsXG4gICAgICAgIGJhY2tncm91bmRcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgUGFyc2VkVGhlbWVSdWxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzY29wZSwgcGFyZW50U2NvcGVzLCBpbmRleCwgZm9udFN0eWxlLCBmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKSB7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMucGFyZW50U2NvcGVzID0gcGFyZW50U2NvcGVzO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG4gIH1cbn07XG52YXIgRm9udFN0eWxlID0gLyogQF9fUFVSRV9fICovICgoRm9udFN0eWxlMikgPT4ge1xuICBGb250U3R5bGUyW0ZvbnRTdHlsZTJbXCJOb3RTZXRcIl0gPSAtMV0gPSBcIk5vdFNldFwiO1xuICBGb250U3R5bGUyW0ZvbnRTdHlsZTJbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgRm9udFN0eWxlMltGb250U3R5bGUyW1wiSXRhbGljXCJdID0gMV0gPSBcIkl0YWxpY1wiO1xuICBGb250U3R5bGUyW0ZvbnRTdHlsZTJbXCJCb2xkXCJdID0gMl0gPSBcIkJvbGRcIjtcbiAgRm9udFN0eWxlMltGb250U3R5bGUyW1wiVW5kZXJsaW5lXCJdID0gNF0gPSBcIlVuZGVybGluZVwiO1xuICBGb250U3R5bGUyW0ZvbnRTdHlsZTJbXCJTdHJpa2V0aHJvdWdoXCJdID0gOF0gPSBcIlN0cmlrZXRocm91Z2hcIjtcbiAgcmV0dXJuIEZvbnRTdHlsZTI7XG59KShGb250U3R5bGUgfHwge30pO1xuZnVuY3Rpb24gcmVzb2x2ZVBhcnNlZFRoZW1lUnVsZXMocGFyc2VkVGhlbWVSdWxlcywgX2NvbG9yTWFwKSB7XG4gIHBhcnNlZFRoZW1lUnVsZXMuc29ydCgoYSwgYikgPT4ge1xuICAgIGxldCByID0gc3RyY21wKGEuc2NvcGUsIGIuc2NvcGUpO1xuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgciA9IHN0ckFyckNtcChhLnBhcmVudFNjb3BlcywgYi5wYXJlbnRTY29wZXMpO1xuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICB9KTtcbiAgbGV0IGRlZmF1bHRGb250U3R5bGUgPSAwIC8qIE5vbmUgKi87XG4gIGxldCBkZWZhdWx0Rm9yZWdyb3VuZCA9IFwiIzAwMDAwMFwiO1xuICBsZXQgZGVmYXVsdEJhY2tncm91bmQgPSBcIiNmZmZmZmZcIjtcbiAgd2hpbGUgKHBhcnNlZFRoZW1lUnVsZXMubGVuZ3RoID49IDEgJiYgcGFyc2VkVGhlbWVSdWxlc1swXS5zY29wZSA9PT0gXCJcIikge1xuICAgIGxldCBpbmNvbWluZ0RlZmF1bHRzID0gcGFyc2VkVGhlbWVSdWxlcy5zaGlmdCgpO1xuICAgIGlmIChpbmNvbWluZ0RlZmF1bHRzLmZvbnRTdHlsZSAhPT0gLTEgLyogTm90U2V0ICovKSB7XG4gICAgICBkZWZhdWx0Rm9udFN0eWxlID0gaW5jb21pbmdEZWZhdWx0cy5mb250U3R5bGU7XG4gICAgfVxuICAgIGlmIChpbmNvbWluZ0RlZmF1bHRzLmZvcmVncm91bmQgIT09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRGb3JlZ3JvdW5kID0gaW5jb21pbmdEZWZhdWx0cy5mb3JlZ3JvdW5kO1xuICAgIH1cbiAgICBpZiAoaW5jb21pbmdEZWZhdWx0cy5iYWNrZ3JvdW5kICE9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0QmFja2dyb3VuZCA9IGluY29taW5nRGVmYXVsdHMuYmFja2dyb3VuZDtcbiAgICB9XG4gIH1cbiAgbGV0IGNvbG9yTWFwID0gbmV3IENvbG9yTWFwKF9jb2xvck1hcCk7XG4gIGxldCBkZWZhdWx0cyA9IG5ldyBTdHlsZUF0dHJpYnV0ZXMoZGVmYXVsdEZvbnRTdHlsZSwgY29sb3JNYXAuZ2V0SWQoZGVmYXVsdEZvcmVncm91bmQpLCBjb2xvck1hcC5nZXRJZChkZWZhdWx0QmFja2dyb3VuZCkpO1xuICBsZXQgcm9vdCA9IG5ldyBUaGVtZVRyaWVFbGVtZW50KG5ldyBUaGVtZVRyaWVFbGVtZW50UnVsZSgwLCBudWxsLCAtMSAvKiBOb3RTZXQgKi8sIDAsIDApLCBbXSk7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYXJzZWRUaGVtZVJ1bGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbGV0IHJ1bGUgPSBwYXJzZWRUaGVtZVJ1bGVzW2ldO1xuICAgIHJvb3QuaW5zZXJ0KDAsIHJ1bGUuc2NvcGUsIHJ1bGUucGFyZW50U2NvcGVzLCBydWxlLmZvbnRTdHlsZSwgY29sb3JNYXAuZ2V0SWQocnVsZS5mb3JlZ3JvdW5kKSwgY29sb3JNYXAuZ2V0SWQocnVsZS5iYWNrZ3JvdW5kKSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBUaGVtZShjb2xvck1hcCwgZGVmYXVsdHMsIHJvb3QpO1xufVxudmFyIENvbG9yTWFwID0gY2xhc3Mge1xuICBfaXNGcm96ZW47XG4gIF9sYXN0Q29sb3JJZDtcbiAgX2lkMmNvbG9yO1xuICBfY29sb3IyaWQ7XG4gIGNvbnN0cnVjdG9yKF9jb2xvck1hcCkge1xuICAgIHRoaXMuX2xhc3RDb2xvcklkID0gMDtcbiAgICB0aGlzLl9pZDJjb2xvciA9IFtdO1xuICAgIHRoaXMuX2NvbG9yMmlkID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX2NvbG9yTWFwKSkge1xuICAgICAgdGhpcy5faXNGcm96ZW4gPSB0cnVlO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IF9jb2xvck1hcC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLl9jb2xvcjJpZFtfY29sb3JNYXBbaV1dID0gaTtcbiAgICAgICAgdGhpcy5faWQyY29sb3JbaV0gPSBfY29sb3JNYXBbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lzRnJvemVuID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGdldElkKGNvbG9yKSB7XG4gICAgaWYgKGNvbG9yID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29sb3IgPSBjb2xvci50b1VwcGVyQ2FzZSgpO1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuX2NvbG9yMmlkW2NvbG9yXTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzRnJvemVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgY29sb3IgaW4gY29sb3IgbWFwIC0gJHtjb2xvcn1gKTtcbiAgICB9XG4gICAgdmFsdWUgPSArK3RoaXMuX2xhc3RDb2xvcklkO1xuICAgIHRoaXMuX2NvbG9yMmlkW2NvbG9yXSA9IHZhbHVlO1xuICAgIHRoaXMuX2lkMmNvbG9yW3ZhbHVlXSA9IGNvbG9yO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBnZXRDb2xvck1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQyY29sb3Iuc2xpY2UoMCk7XG4gIH1cbn07XG52YXIgZW1wdHlQYXJlbnRTY29wZXMgPSBPYmplY3QuZnJlZXplKFtdKTtcbnZhciBUaGVtZVRyaWVFbGVtZW50UnVsZSA9IGNsYXNzIF9UaGVtZVRyaWVFbGVtZW50UnVsZSB7XG4gIHNjb3BlRGVwdGg7XG4gIHBhcmVudFNjb3BlcztcbiAgZm9udFN0eWxlO1xuICBmb3JlZ3JvdW5kO1xuICBiYWNrZ3JvdW5kO1xuICBjb25zdHJ1Y3RvcihzY29wZURlcHRoLCBwYXJlbnRTY29wZXMsIGZvbnRTdHlsZSwgZm9yZWdyb3VuZCwgYmFja2dyb3VuZCkge1xuICAgIHRoaXMuc2NvcGVEZXB0aCA9IHNjb3BlRGVwdGg7XG4gICAgdGhpcy5wYXJlbnRTY29wZXMgPSBwYXJlbnRTY29wZXMgfHwgZW1wdHlQYXJlbnRTY29wZXM7XG4gICAgdGhpcy5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZDtcbiAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX1RoZW1lVHJpZUVsZW1lbnRSdWxlKHRoaXMuc2NvcGVEZXB0aCwgdGhpcy5wYXJlbnRTY29wZXMsIHRoaXMuZm9udFN0eWxlLCB0aGlzLmZvcmVncm91bmQsIHRoaXMuYmFja2dyb3VuZCk7XG4gIH1cbiAgc3RhdGljIGNsb25lQXJyKGFycikge1xuICAgIGxldCByID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcltpXSA9IGFycltpXS5jbG9uZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICBhY2NlcHRPdmVyd3JpdGUoc2NvcGVEZXB0aCwgZm9udFN0eWxlLCBmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKSB7XG4gICAgaWYgKHRoaXMuc2NvcGVEZXB0aCA+IHNjb3BlRGVwdGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiaG93IGRpZCB0aGlzIGhhcHBlbj9cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2NvcGVEZXB0aCA9IHNjb3BlRGVwdGg7XG4gICAgfVxuICAgIGlmIChmb250U3R5bGUgIT09IC0xIC8qIE5vdFNldCAqLykge1xuICAgICAgdGhpcy5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgfVxuICAgIGlmIChmb3JlZ3JvdW5kICE9PSAwKSB7XG4gICAgICB0aGlzLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kO1xuICAgIH1cbiAgICBpZiAoYmFja2dyb3VuZCAhPT0gMCkge1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcbiAgICB9XG4gIH1cbn07XG52YXIgVGhlbWVUcmllRWxlbWVudCA9IGNsYXNzIF9UaGVtZVRyaWVFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoX21haW5SdWxlLCBydWxlc1dpdGhQYXJlbnRTY29wZXMgPSBbXSwgX2NoaWxkcmVuID0ge30pIHtcbiAgICB0aGlzLl9tYWluUnVsZSA9IF9tYWluUnVsZTtcbiAgICB0aGlzLl9jaGlsZHJlbiA9IF9jaGlsZHJlbjtcbiAgICB0aGlzLl9ydWxlc1dpdGhQYXJlbnRTY29wZXMgPSBydWxlc1dpdGhQYXJlbnRTY29wZXM7XG4gIH1cbiAgX3J1bGVzV2l0aFBhcmVudFNjb3BlcztcbiAgc3RhdGljIF9jbXBCeVNwZWNpZmljaXR5KGEsIGIpIHtcbiAgICBpZiAoYS5zY29wZURlcHRoICE9PSBiLnNjb3BlRGVwdGgpIHtcbiAgICAgIHJldHVybiBiLnNjb3BlRGVwdGggLSBhLnNjb3BlRGVwdGg7XG4gICAgfVxuICAgIGxldCBhUGFyZW50SW5kZXggPSAwO1xuICAgIGxldCBiUGFyZW50SW5kZXggPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoYS5wYXJlbnRTY29wZXNbYVBhcmVudEluZGV4XSA9PT0gXCI+XCIpIHtcbiAgICAgICAgYVBhcmVudEluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAoYi5wYXJlbnRTY29wZXNbYlBhcmVudEluZGV4XSA9PT0gXCI+XCIpIHtcbiAgICAgICAgYlBhcmVudEluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAoYVBhcmVudEluZGV4ID49IGEucGFyZW50U2NvcGVzLmxlbmd0aCB8fCBiUGFyZW50SW5kZXggPj0gYi5wYXJlbnRTY29wZXMubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50U2NvcGVMZW5ndGhEaWZmID0gYi5wYXJlbnRTY29wZXNbYlBhcmVudEluZGV4XS5sZW5ndGggLSBhLnBhcmVudFNjb3Blc1thUGFyZW50SW5kZXhdLmxlbmd0aDtcbiAgICAgIGlmIChwYXJlbnRTY29wZUxlbmd0aERpZmYgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudFNjb3BlTGVuZ3RoRGlmZjtcbiAgICAgIH1cbiAgICAgIGFQYXJlbnRJbmRleCsrO1xuICAgICAgYlBhcmVudEluZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiBiLnBhcmVudFNjb3Blcy5sZW5ndGggLSBhLnBhcmVudFNjb3Blcy5sZW5ndGg7XG4gIH1cbiAgbWF0Y2goc2NvcGUpIHtcbiAgICBpZiAoc2NvcGUgIT09IFwiXCIpIHtcbiAgICAgIGxldCBkb3RJbmRleCA9IHNjb3BlLmluZGV4T2YoXCIuXCIpO1xuICAgICAgbGV0IGhlYWQ7XG4gICAgICBsZXQgdGFpbDtcbiAgICAgIGlmIChkb3RJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgaGVhZCA9IHNjb3BlO1xuICAgICAgICB0YWlsID0gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYWQgPSBzY29wZS5zdWJzdHJpbmcoMCwgZG90SW5kZXgpO1xuICAgICAgICB0YWlsID0gc2NvcGUuc3Vic3RyaW5nKGRvdEluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY2hpbGRyZW4uaGFzT3duUHJvcGVydHkoaGVhZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuW2hlYWRdLm1hdGNoKHRhaWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBydWxlcyA9IHRoaXMuX3J1bGVzV2l0aFBhcmVudFNjb3Blcy5jb25jYXQodGhpcy5fbWFpblJ1bGUpO1xuICAgIHJ1bGVzLnNvcnQoX1RoZW1lVHJpZUVsZW1lbnQuX2NtcEJ5U3BlY2lmaWNpdHkpO1xuICAgIHJldHVybiBydWxlcztcbiAgfVxuICBpbnNlcnQoc2NvcGVEZXB0aCwgc2NvcGUsIHBhcmVudFNjb3BlcywgZm9udFN0eWxlLCBmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKSB7XG4gICAgaWYgKHNjb3BlID09PSBcIlwiKSB7XG4gICAgICB0aGlzLl9kb0luc2VydEhlcmUoc2NvcGVEZXB0aCwgcGFyZW50U2NvcGVzLCBmb250U3R5bGUsIGZvcmVncm91bmQsIGJhY2tncm91bmQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZG90SW5kZXggPSBzY29wZS5pbmRleE9mKFwiLlwiKTtcbiAgICBsZXQgaGVhZDtcbiAgICBsZXQgdGFpbDtcbiAgICBpZiAoZG90SW5kZXggPT09IC0xKSB7XG4gICAgICBoZWFkID0gc2NvcGU7XG4gICAgICB0YWlsID0gXCJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZCA9IHNjb3BlLnN1YnN0cmluZygwLCBkb3RJbmRleCk7XG4gICAgICB0YWlsID0gc2NvcGUuc3Vic3RyaW5nKGRvdEluZGV4ICsgMSk7XG4gICAgfVxuICAgIGxldCBjaGlsZDtcbiAgICBpZiAodGhpcy5fY2hpbGRyZW4uaGFzT3duUHJvcGVydHkoaGVhZCkpIHtcbiAgICAgIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baGVhZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkID0gbmV3IF9UaGVtZVRyaWVFbGVtZW50KHRoaXMuX21haW5SdWxlLmNsb25lKCksIFRoZW1lVHJpZUVsZW1lbnRSdWxlLmNsb25lQXJyKHRoaXMuX3J1bGVzV2l0aFBhcmVudFNjb3BlcykpO1xuICAgICAgdGhpcy5fY2hpbGRyZW5baGVhZF0gPSBjaGlsZDtcbiAgICB9XG4gICAgY2hpbGQuaW5zZXJ0KHNjb3BlRGVwdGggKyAxLCB0YWlsLCBwYXJlbnRTY29wZXMsIGZvbnRTdHlsZSwgZm9yZWdyb3VuZCwgYmFja2dyb3VuZCk7XG4gIH1cbiAgX2RvSW5zZXJ0SGVyZShzY29wZURlcHRoLCBwYXJlbnRTY29wZXMsIGZvbnRTdHlsZSwgZm9yZWdyb3VuZCwgYmFja2dyb3VuZCkge1xuICAgIGlmIChwYXJlbnRTY29wZXMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX21haW5SdWxlLmFjY2VwdE92ZXJ3cml0ZShzY29wZURlcHRoLCBmb250U3R5bGUsIGZvcmVncm91bmQsIGJhY2tncm91bmQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fcnVsZXNXaXRoUGFyZW50U2NvcGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsZXQgcnVsZSA9IHRoaXMuX3J1bGVzV2l0aFBhcmVudFNjb3Blc1tpXTtcbiAgICAgIGlmIChzdHJBcnJDbXAocnVsZS5wYXJlbnRTY29wZXMsIHBhcmVudFNjb3BlcykgPT09IDApIHtcbiAgICAgICAgcnVsZS5hY2NlcHRPdmVyd3JpdGUoc2NvcGVEZXB0aCwgZm9udFN0eWxlLCBmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZm9udFN0eWxlID09PSAtMSAvKiBOb3RTZXQgKi8pIHtcbiAgICAgIGZvbnRTdHlsZSA9IHRoaXMuX21haW5SdWxlLmZvbnRTdHlsZTtcbiAgICB9XG4gICAgaWYgKGZvcmVncm91bmQgPT09IDApIHtcbiAgICAgIGZvcmVncm91bmQgPSB0aGlzLl9tYWluUnVsZS5mb3JlZ3JvdW5kO1xuICAgIH1cbiAgICBpZiAoYmFja2dyb3VuZCA9PT0gMCkge1xuICAgICAgYmFja2dyb3VuZCA9IHRoaXMuX21haW5SdWxlLmJhY2tncm91bmQ7XG4gICAgfVxuICAgIHRoaXMuX3J1bGVzV2l0aFBhcmVudFNjb3Blcy5wdXNoKG5ldyBUaGVtZVRyaWVFbGVtZW50UnVsZShzY29wZURlcHRoLCBwYXJlbnRTY29wZXMsIGZvbnRTdHlsZSwgZm9yZWdyb3VuZCwgYmFja2dyb3VuZCkpO1xuICB9XG59O1xuXG4vLyBzcmMvZW5jb2RlZFRva2VuQXR0cmlidXRlcy50c1xudmFyIEVuY29kZWRUb2tlbk1ldGFkYXRhID0gY2xhc3MgX0VuY29kZWRUb2tlbk1ldGFkYXRhIHtcbiAgc3RhdGljIHRvQmluYXJ5U3RyKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gZW5jb2RlZFRva2VuQXR0cmlidXRlcy50b1N0cmluZygyKS5wYWRTdGFydCgzMiwgXCIwXCIpO1xuICB9XG4gIHN0YXRpYyBwcmludChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgbGFuZ3VhZ2VJZCA9IF9FbmNvZGVkVG9rZW5NZXRhZGF0YS5nZXRMYW5ndWFnZUlkKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpO1xuICAgIGNvbnN0IHRva2VuVHlwZSA9IF9FbmNvZGVkVG9rZW5NZXRhZGF0YS5nZXRUb2tlblR5cGUoZW5jb2RlZFRva2VuQXR0cmlidXRlcyk7XG4gICAgY29uc3QgZm9udFN0eWxlID0gX0VuY29kZWRUb2tlbk1ldGFkYXRhLmdldEZvbnRTdHlsZShlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgICBjb25zdCBmb3JlZ3JvdW5kID0gX0VuY29kZWRUb2tlbk1ldGFkYXRhLmdldEZvcmVncm91bmQoZW5jb2RlZFRva2VuQXR0cmlidXRlcyk7XG4gICAgY29uc3QgYmFja2dyb3VuZCA9IF9FbmNvZGVkVG9rZW5NZXRhZGF0YS5nZXRCYWNrZ3JvdW5kKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpO1xuICAgIGNvbnNvbGUubG9nKHtcbiAgICAgIGxhbmd1YWdlSWQsXG4gICAgICB0b2tlblR5cGUsXG4gICAgICBmb250U3R5bGUsXG4gICAgICBmb3JlZ3JvdW5kLFxuICAgICAgYmFja2dyb3VuZFxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRMYW5ndWFnZUlkKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMgJiAyNTUgLyogTEFOR1VBR0VJRF9NQVNLICovKSA+Pj4gMCAvKiBMQU5HVUFHRUlEX09GRlNFVCAqLztcbiAgfVxuICBzdGF0aWMgZ2V0VG9rZW5UeXBlKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMgJiA3NjggLyogVE9LRU5fVFlQRV9NQVNLICovKSA+Pj4gOCAvKiBUT0tFTl9UWVBFX09GRlNFVCAqLztcbiAgfVxuICBzdGF0aWMgY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMgJiAxMDI0IC8qIEJBTEFOQ0VEX0JSQUNLRVRTX01BU0sgKi8pICE9PSAwO1xuICB9XG4gIHN0YXRpYyBnZXRGb250U3R5bGUoZW5jb2RlZFRva2VuQXR0cmlidXRlcykge1xuICAgIHJldHVybiAoZW5jb2RlZFRva2VuQXR0cmlidXRlcyAmIDMwNzIwIC8qIEZPTlRfU1RZTEVfTUFTSyAqLykgPj4+IDExIC8qIEZPTlRfU1RZTEVfT0ZGU0VUICovO1xuICB9XG4gIHN0YXRpYyBnZXRGb3JlZ3JvdW5kKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMgJiAxNjc0NDQ0OCAvKiBGT1JFR1JPVU5EX01BU0sgKi8pID4+PiAxNSAvKiBGT1JFR1JPVU5EX09GRlNFVCAqLztcbiAgfVxuICBzdGF0aWMgZ2V0QmFja2dyb3VuZChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzICYgNDI3ODE5MDA4MCAvKiBCQUNLR1JPVU5EX01BU0sgKi8pID4+PiAyNCAvKiBCQUNLR1JPVU5EX09GRlNFVCAqLztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZmllbGRzIGluIGBtZXRhZGF0YWAuXG4gICAqIEEgdmFsdWUgb2YgYDBgLCBgTm90U2V0YCBvciBgbnVsbGAgaW5kaWNhdGVzIHRoYXQgdGhlIGNvcnJlc3BvbmRpbmcgZmllbGQgc2hvdWxkIGJlIGxlZnQgYXMgaXMuXG4gICAqL1xuICBzdGF0aWMgc2V0KGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMsIGxhbmd1YWdlSWQsIHRva2VuVHlwZSwgY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzLCBmb250U3R5bGUsIGZvcmVncm91bmQsIGJhY2tncm91bmQpIHtcbiAgICBsZXQgX2xhbmd1YWdlSWQgPSBfRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0TGFuZ3VhZ2VJZChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgICBsZXQgX3Rva2VuVHlwZSA9IF9FbmNvZGVkVG9rZW5NZXRhZGF0YS5nZXRUb2tlblR5cGUoZW5jb2RlZFRva2VuQXR0cmlidXRlcyk7XG4gICAgbGV0IF9jb250YWluc0JhbGFuY2VkQnJhY2tldHNCaXQgPSBfRW5jb2RlZFRva2VuTWV0YWRhdGEuY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpID8gMSA6IDA7XG4gICAgbGV0IF9mb250U3R5bGUgPSBfRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0Rm9udFN0eWxlKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpO1xuICAgIGxldCBfZm9yZWdyb3VuZCA9IF9FbmNvZGVkVG9rZW5NZXRhZGF0YS5nZXRGb3JlZ3JvdW5kKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpO1xuICAgIGxldCBfYmFja2dyb3VuZCA9IF9FbmNvZGVkVG9rZW5NZXRhZGF0YS5nZXRCYWNrZ3JvdW5kKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpO1xuICAgIGlmIChsYW5ndWFnZUlkICE9PSAwKSB7XG4gICAgICBfbGFuZ3VhZ2VJZCA9IGxhbmd1YWdlSWQ7XG4gICAgfVxuICAgIGlmICh0b2tlblR5cGUgIT09IDggLyogTm90U2V0ICovKSB7XG4gICAgICBfdG9rZW5UeXBlID0gZnJvbU9wdGlvbmFsVG9rZW5UeXBlKHRva2VuVHlwZSk7XG4gICAgfVxuICAgIGlmIChjb250YWluc0JhbGFuY2VkQnJhY2tldHMgIT09IG51bGwpIHtcbiAgICAgIF9jb250YWluc0JhbGFuY2VkQnJhY2tldHNCaXQgPSBjb250YWluc0JhbGFuY2VkQnJhY2tldHMgPyAxIDogMDtcbiAgICB9XG4gICAgaWYgKGZvbnRTdHlsZSAhPT0gLTEgLyogTm90U2V0ICovKSB7XG4gICAgICBfZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgIH1cbiAgICBpZiAoZm9yZWdyb3VuZCAhPT0gMCkge1xuICAgICAgX2ZvcmVncm91bmQgPSBmb3JlZ3JvdW5kO1xuICAgIH1cbiAgICBpZiAoYmFja2dyb3VuZCAhPT0gMCkge1xuICAgICAgX2JhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuICAgIH1cbiAgICByZXR1cm4gKF9sYW5ndWFnZUlkIDw8IDAgLyogTEFOR1VBR0VJRF9PRkZTRVQgKi8gfCBfdG9rZW5UeXBlIDw8IDggLyogVE9LRU5fVFlQRV9PRkZTRVQgKi8gfCBfY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzQml0IDw8IDEwIC8qIEJBTEFOQ0VEX0JSQUNLRVRTX09GRlNFVCAqLyB8IF9mb250U3R5bGUgPDwgMTEgLyogRk9OVF9TVFlMRV9PRkZTRVQgKi8gfCBfZm9yZWdyb3VuZCA8PCAxNSAvKiBGT1JFR1JPVU5EX09GRlNFVCAqLyB8IF9iYWNrZ3JvdW5kIDw8IDI0IC8qIEJBQ0tHUk9VTkRfT0ZGU0VUICovKSA+Pj4gMDtcbiAgfVxufTtcbmZ1bmN0aW9uIHRvT3B0aW9uYWxUb2tlblR5cGUoc3RhbmRhcmRUeXBlKSB7XG4gIHJldHVybiBzdGFuZGFyZFR5cGU7XG59XG5mdW5jdGlvbiBmcm9tT3B0aW9uYWxUb2tlblR5cGUoc3RhbmRhcmRUeXBlKSB7XG4gIHJldHVybiBzdGFuZGFyZFR5cGU7XG59XG5cbi8vIHNyYy9tYXRjaGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVNYXRjaGVycyhzZWxlY3RvciwgbWF0Y2hlc05hbWUpIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBjb25zdCB0b2tlbml6ZXIgPSBuZXdUb2tlbml6ZXIoc2VsZWN0b3IpO1xuICBsZXQgdG9rZW4gPSB0b2tlbml6ZXIubmV4dCgpO1xuICB3aGlsZSAodG9rZW4gIT09IG51bGwpIHtcbiAgICBsZXQgcHJpb3JpdHkgPSAwO1xuICAgIGlmICh0b2tlbi5sZW5ndGggPT09IDIgJiYgdG9rZW4uY2hhckF0KDEpID09PSBcIjpcIikge1xuICAgICAgc3dpdGNoICh0b2tlbi5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSBcIlJcIjpcbiAgICAgICAgICBwcmlvcml0eSA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgcHJpb3JpdHkgPSAtMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLmxvZyhgVW5rbm93biBwcmlvcml0eSAke3Rva2VufSBpbiBzY29wZSBzZWxlY3RvcmApO1xuICAgICAgfVxuICAgICAgdG9rZW4gPSB0b2tlbml6ZXIubmV4dCgpO1xuICAgIH1cbiAgICBsZXQgbWF0Y2hlciA9IHBhcnNlQ29uanVuY3Rpb24oKTtcbiAgICByZXN1bHRzLnB1c2goeyBtYXRjaGVyLCBwcmlvcml0eSB9KTtcbiAgICBpZiAodG9rZW4gIT09IFwiLFwiKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdG9rZW4gPSB0b2tlbml6ZXIubmV4dCgpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xuICBmdW5jdGlvbiBwYXJzZU9wZXJhbmQoKSB7XG4gICAgaWYgKHRva2VuID09PSBcIi1cIikge1xuICAgICAgdG9rZW4gPSB0b2tlbml6ZXIubmV4dCgpO1xuICAgICAgY29uc3QgZXhwcmVzc2lvblRvTmVnYXRlID0gcGFyc2VPcGVyYW5kKCk7XG4gICAgICByZXR1cm4gKG1hdGNoZXJJbnB1dCkgPT4gISFleHByZXNzaW9uVG9OZWdhdGUgJiYgIWV4cHJlc3Npb25Ub05lZ2F0ZShtYXRjaGVySW5wdXQpO1xuICAgIH1cbiAgICBpZiAodG9rZW4gPT09IFwiKFwiKSB7XG4gICAgICB0b2tlbiA9IHRva2VuaXplci5uZXh0KCk7XG4gICAgICBjb25zdCBleHByZXNzaW9uSW5QYXJlbnRzID0gcGFyc2VJbm5lckV4cHJlc3Npb24oKTtcbiAgICAgIGlmICh0b2tlbiA9PT0gXCIpXCIpIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbml6ZXIubmV4dCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cHJlc3Npb25JblBhcmVudHM7XG4gICAgfVxuICAgIGlmIChpc0lkZW50aWZpZXIodG9rZW4pKSB7XG4gICAgICBjb25zdCBpZGVudGlmaWVycyA9IFtdO1xuICAgICAgZG8ge1xuICAgICAgICBpZGVudGlmaWVycy5wdXNoKHRva2VuKTtcbiAgICAgICAgdG9rZW4gPSB0b2tlbml6ZXIubmV4dCgpO1xuICAgICAgfSB3aGlsZSAoaXNJZGVudGlmaWVyKHRva2VuKSk7XG4gICAgICByZXR1cm4gKG1hdGNoZXJJbnB1dCkgPT4gbWF0Y2hlc05hbWUoaWRlbnRpZmllcnMsIG1hdGNoZXJJbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlQ29uanVuY3Rpb24oKSB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBbXTtcbiAgICBsZXQgbWF0Y2hlciA9IHBhcnNlT3BlcmFuZCgpO1xuICAgIHdoaWxlIChtYXRjaGVyKSB7XG4gICAgICBtYXRjaGVycy5wdXNoKG1hdGNoZXIpO1xuICAgICAgbWF0Y2hlciA9IHBhcnNlT3BlcmFuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gKG1hdGNoZXJJbnB1dCkgPT4gbWF0Y2hlcnMuZXZlcnkoKG1hdGNoZXIyKSA9PiBtYXRjaGVyMihtYXRjaGVySW5wdXQpKTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUlubmVyRXhwcmVzc2lvbigpIHtcbiAgICBjb25zdCBtYXRjaGVycyA9IFtdO1xuICAgIGxldCBtYXRjaGVyID0gcGFyc2VDb25qdW5jdGlvbigpO1xuICAgIHdoaWxlIChtYXRjaGVyKSB7XG4gICAgICBtYXRjaGVycy5wdXNoKG1hdGNoZXIpO1xuICAgICAgaWYgKHRva2VuID09PSBcInxcIiB8fCB0b2tlbiA9PT0gXCIsXCIpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHRva2VuID0gdG9rZW5pemVyLm5leHQoKTtcbiAgICAgICAgfSB3aGlsZSAodG9rZW4gPT09IFwifFwiIHx8IHRva2VuID09PSBcIixcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1hdGNoZXIgPSBwYXJzZUNvbmp1bmN0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiAobWF0Y2hlcklucHV0KSA9PiBtYXRjaGVycy5zb21lKChtYXRjaGVyMikgPT4gbWF0Y2hlcjIobWF0Y2hlcklucHV0KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzSWRlbnRpZmllcih0b2tlbikge1xuICByZXR1cm4gISF0b2tlbiAmJiAhIXRva2VuLm1hdGNoKC9bXFx3XFwuOl0rLyk7XG59XG5mdW5jdGlvbiBuZXdUb2tlbml6ZXIoaW5wdXQpIHtcbiAgbGV0IHJlZ2V4ID0gLyhbTFJdOnxbXFx3XFwuOl1bXFx3XFwuOlxcLV0qfFtcXCxcXHxcXC1cXChcXCldKS9nO1xuICBsZXQgbWF0Y2ggPSByZWdleC5leGVjKGlucHV0KTtcbiAgcmV0dXJuIHtcbiAgICBuZXh0OiAoKSA9PiB7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzID0gbWF0Y2hbMF07XG4gICAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoaW5wdXQpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9vbmlnTGliLnRzXG52YXIgRmluZE9wdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyAoKEZpbmRPcHRpb24yKSA9PiB7XG4gIEZpbmRPcHRpb24yW0ZpbmRPcHRpb24yW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gIEZpbmRPcHRpb24yW0ZpbmRPcHRpb24yW1wiTm90QmVnaW5TdHJpbmdcIl0gPSAxXSA9IFwiTm90QmVnaW5TdHJpbmdcIjtcbiAgRmluZE9wdGlvbjJbRmluZE9wdGlvbjJbXCJOb3RFbmRTdHJpbmdcIl0gPSAyXSA9IFwiTm90RW5kU3RyaW5nXCI7XG4gIEZpbmRPcHRpb24yW0ZpbmRPcHRpb24yW1wiTm90QmVnaW5Qb3NpdGlvblwiXSA9IDRdID0gXCJOb3RCZWdpblBvc2l0aW9uXCI7XG4gIEZpbmRPcHRpb24yW0ZpbmRPcHRpb24yW1wiRGVidWdDYWxsXCJdID0gOF0gPSBcIkRlYnVnQ2FsbFwiO1xuICByZXR1cm4gRmluZE9wdGlvbjI7XG59KShGaW5kT3B0aW9uIHx8IHt9KTtcbmZ1bmN0aW9uIGRpc3Bvc2VPbmlnU3RyaW5nKHN0cikge1xuICBpZiAodHlwZW9mIHN0ci5kaXNwb3NlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBzdHIuZGlzcG9zZSgpO1xuICB9XG59XG5cbi8vIHNyYy9ncmFtbWFyL2dyYW1tYXJEZXBlbmRlbmNpZXMudHNcbnZhciBUb3BMZXZlbFJ1bGVSZWZlcmVuY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNjb3BlTmFtZSkge1xuICAgIHRoaXMuc2NvcGVOYW1lID0gc2NvcGVOYW1lO1xuICB9XG4gIHRvS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnNjb3BlTmFtZTtcbiAgfVxufTtcbnZhciBUb3BMZXZlbFJlcG9zaXRvcnlSdWxlUmVmZXJlbmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzY29wZU5hbWUsIHJ1bGVOYW1lKSB7XG4gICAgdGhpcy5zY29wZU5hbWUgPSBzY29wZU5hbWU7XG4gICAgdGhpcy5ydWxlTmFtZSA9IHJ1bGVOYW1lO1xuICB9XG4gIHRvS2V5KCkge1xuICAgIHJldHVybiBgJHt0aGlzLnNjb3BlTmFtZX0jJHt0aGlzLnJ1bGVOYW1lfWA7XG4gIH1cbn07XG52YXIgRXh0ZXJuYWxSZWZlcmVuY2VDb2xsZWN0b3IgPSBjbGFzcyB7XG4gIF9yZWZlcmVuY2VzID0gW107XG4gIF9zZWVuUmVmZXJlbmNlS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGdldCByZWZlcmVuY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWZlcmVuY2VzO1xuICB9XG4gIHZpc2l0ZWRSdWxlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgYWRkKHJlZmVyZW5jZSkge1xuICAgIGNvbnN0IGtleSA9IHJlZmVyZW5jZS50b0tleSgpO1xuICAgIGlmICh0aGlzLl9zZWVuUmVmZXJlbmNlS2V5cy5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zZWVuUmVmZXJlbmNlS2V5cy5hZGQoa2V5KTtcbiAgICB0aGlzLl9yZWZlcmVuY2VzLnB1c2gocmVmZXJlbmNlKTtcbiAgfVxufTtcbnZhciBTY29wZURlcGVuZGVuY3lQcm9jZXNzb3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlcG8sIGluaXRpYWxTY29wZU5hbWUpIHtcbiAgICB0aGlzLnJlcG8gPSByZXBvO1xuICAgIHRoaXMuaW5pdGlhbFNjb3BlTmFtZSA9IGluaXRpYWxTY29wZU5hbWU7XG4gICAgdGhpcy5zZWVuRnVsbFNjb3BlUmVxdWVzdHMuYWRkKHRoaXMuaW5pdGlhbFNjb3BlTmFtZSk7XG4gICAgdGhpcy5RID0gW25ldyBUb3BMZXZlbFJ1bGVSZWZlcmVuY2UodGhpcy5pbml0aWFsU2NvcGVOYW1lKV07XG4gIH1cbiAgc2VlbkZ1bGxTY29wZVJlcXVlc3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgc2VlblBhcnRpYWxTY29wZVJlcXVlc3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgUTtcbiAgcHJvY2Vzc1F1ZXVlKCkge1xuICAgIGNvbnN0IHEgPSB0aGlzLlE7XG4gICAgdGhpcy5RID0gW107XG4gICAgY29uc3QgZGVwcyA9IG5ldyBFeHRlcm5hbFJlZmVyZW5jZUNvbGxlY3RvcigpO1xuICAgIGZvciAoY29uc3QgZGVwIG9mIHEpIHtcbiAgICAgIGNvbGxlY3RSZWZlcmVuY2VzT2ZSZWZlcmVuY2UoZGVwLCB0aGlzLmluaXRpYWxTY29wZU5hbWUsIHRoaXMucmVwbywgZGVwcyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZGVwIG9mIGRlcHMucmVmZXJlbmNlcykge1xuICAgICAgaWYgKGRlcCBpbnN0YW5jZW9mIFRvcExldmVsUnVsZVJlZmVyZW5jZSkge1xuICAgICAgICBpZiAodGhpcy5zZWVuRnVsbFNjb3BlUmVxdWVzdHMuaGFzKGRlcC5zY29wZU5hbWUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWVuRnVsbFNjb3BlUmVxdWVzdHMuYWRkKGRlcC5zY29wZU5hbWUpO1xuICAgICAgICB0aGlzLlEucHVzaChkZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuc2VlbkZ1bGxTY29wZVJlcXVlc3RzLmhhcyhkZXAuc2NvcGVOYW1lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlZW5QYXJ0aWFsU2NvcGVSZXF1ZXN0cy5oYXMoZGVwLnRvS2V5KCkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWVuUGFydGlhbFNjb3BlUmVxdWVzdHMuYWRkKGRlcC50b0tleSgpKTtcbiAgICAgICAgdGhpcy5RLnB1c2goZGVwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBjb2xsZWN0UmVmZXJlbmNlc09mUmVmZXJlbmNlKHJlZmVyZW5jZSwgYmFzZUdyYW1tYXJTY29wZU5hbWUsIHJlcG8sIHJlc3VsdCkge1xuICBjb25zdCBzZWxmR3JhbW1hciA9IHJlcG8ubG9va3VwKHJlZmVyZW5jZS5zY29wZU5hbWUpO1xuICBpZiAoIXNlbGZHcmFtbWFyKSB7XG4gICAgaWYgKHJlZmVyZW5jZS5zY29wZU5hbWUgPT09IGJhc2VHcmFtbWFyU2NvcGVOYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGdyYW1tYXIgcHJvdmlkZWQgZm9yIDwke2Jhc2VHcmFtbWFyU2NvcGVOYW1lfT5gKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGJhc2VHcmFtbWFyID0gcmVwby5sb29rdXAoYmFzZUdyYW1tYXJTY29wZU5hbWUpO1xuICBpZiAocmVmZXJlbmNlIGluc3RhbmNlb2YgVG9wTGV2ZWxSdWxlUmVmZXJlbmNlKSB7XG4gICAgY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlc0luVG9wTGV2ZWxSdWxlKHsgYmFzZUdyYW1tYXIsIHNlbGZHcmFtbWFyIH0sIHJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlc0luVG9wTGV2ZWxSZXBvc2l0b3J5UnVsZShcbiAgICAgIHJlZmVyZW5jZS5ydWxlTmFtZSxcbiAgICAgIHsgYmFzZUdyYW1tYXIsIHNlbGZHcmFtbWFyLCByZXBvc2l0b3J5OiBzZWxmR3JhbW1hci5yZXBvc2l0b3J5IH0sXG4gICAgICByZXN1bHRcbiAgICApO1xuICB9XG4gIGNvbnN0IGluamVjdGlvbnMgPSByZXBvLmluamVjdGlvbnMocmVmZXJlbmNlLnNjb3BlTmFtZSk7XG4gIGlmIChpbmplY3Rpb25zKSB7XG4gICAgZm9yIChjb25zdCBpbmplY3Rpb24gb2YgaW5qZWN0aW9ucykge1xuICAgICAgcmVzdWx0LmFkZChuZXcgVG9wTGV2ZWxSdWxlUmVmZXJlbmNlKGluamVjdGlvbikpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlc0luVG9wTGV2ZWxSZXBvc2l0b3J5UnVsZShydWxlTmFtZSwgY29udGV4dCwgcmVzdWx0KSB7XG4gIGlmIChjb250ZXh0LnJlcG9zaXRvcnkgJiYgY29udGV4dC5yZXBvc2l0b3J5W3J1bGVOYW1lXSkge1xuICAgIGNvbnN0IHJ1bGUgPSBjb250ZXh0LnJlcG9zaXRvcnlbcnVsZU5hbWVdO1xuICAgIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblJ1bGVzKFtydWxlXSwgY29udGV4dCwgcmVzdWx0KTtcbiAgfVxufVxuZnVuY3Rpb24gY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlc0luVG9wTGV2ZWxSdWxlKGNvbnRleHQsIHJlc3VsdCkge1xuICBpZiAoY29udGV4dC5zZWxmR3JhbW1hci5wYXR0ZXJucyAmJiBBcnJheS5pc0FycmF5KGNvbnRleHQuc2VsZkdyYW1tYXIucGF0dGVybnMpKSB7XG4gICAgY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlc0luUnVsZXMoXG4gICAgICBjb250ZXh0LnNlbGZHcmFtbWFyLnBhdHRlcm5zLFxuICAgICAgeyAuLi5jb250ZXh0LCByZXBvc2l0b3J5OiBjb250ZXh0LnNlbGZHcmFtbWFyLnJlcG9zaXRvcnkgfSxcbiAgICAgIHJlc3VsdFxuICAgICk7XG4gIH1cbiAgaWYgKGNvbnRleHQuc2VsZkdyYW1tYXIuaW5qZWN0aW9ucykge1xuICAgIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblJ1bGVzKFxuICAgICAgT2JqZWN0LnZhbHVlcyhjb250ZXh0LnNlbGZHcmFtbWFyLmluamVjdGlvbnMpLFxuICAgICAgeyAuLi5jb250ZXh0LCByZXBvc2l0b3J5OiBjb250ZXh0LnNlbGZHcmFtbWFyLnJlcG9zaXRvcnkgfSxcbiAgICAgIHJlc3VsdFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblJ1bGVzKHJ1bGVzLCBjb250ZXh0LCByZXN1bHQpIHtcbiAgZm9yIChjb25zdCBydWxlIG9mIHJ1bGVzKSB7XG4gICAgaWYgKHJlc3VsdC52aXNpdGVkUnVsZS5oYXMocnVsZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXN1bHQudmlzaXRlZFJ1bGUuYWRkKHJ1bGUpO1xuICAgIGNvbnN0IHBhdHRlcm5SZXBvc2l0b3J5ID0gcnVsZS5yZXBvc2l0b3J5ID8gbWVyZ2VPYmplY3RzKHt9LCBjb250ZXh0LnJlcG9zaXRvcnksIHJ1bGUucmVwb3NpdG9yeSkgOiBjb250ZXh0LnJlcG9zaXRvcnk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocnVsZS5wYXR0ZXJucykpIHtcbiAgICAgIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblJ1bGVzKHJ1bGUucGF0dGVybnMsIHsgLi4uY29udGV4dCwgcmVwb3NpdG9yeTogcGF0dGVyblJlcG9zaXRvcnkgfSwgcmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgaW5jbHVkZSA9IHJ1bGUuaW5jbHVkZTtcbiAgICBpZiAoIWluY2x1ZGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCByZWZlcmVuY2UgPSBwYXJzZUluY2x1ZGUoaW5jbHVkZSk7XG4gICAgc3dpdGNoIChyZWZlcmVuY2Uua2luZCkge1xuICAgICAgY2FzZSAwIC8qIEJhc2UgKi86XG4gICAgICAgIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblRvcExldmVsUnVsZSh7IC4uLmNvbnRleHQsIHNlbGZHcmFtbWFyOiBjb250ZXh0LmJhc2VHcmFtbWFyIH0sIHJlc3VsdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxIC8qIFNlbGYgKi86XG4gICAgICAgIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblRvcExldmVsUnVsZShjb250ZXh0LCByZXN1bHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMiAvKiBSZWxhdGl2ZVJlZmVyZW5jZSAqLzpcbiAgICAgICAgY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlc0luVG9wTGV2ZWxSZXBvc2l0b3J5UnVsZShyZWZlcmVuY2UucnVsZU5hbWUsIHsgLi4uY29udGV4dCwgcmVwb3NpdG9yeTogcGF0dGVyblJlcG9zaXRvcnkgfSwgcmVzdWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDMgLyogVG9wTGV2ZWxSZWZlcmVuY2UgKi86XG4gICAgICBjYXNlIDQgLyogVG9wTGV2ZWxSZXBvc2l0b3J5UmVmZXJlbmNlICovOlxuICAgICAgICBjb25zdCBzZWxmR3JhbW1hciA9IHJlZmVyZW5jZS5zY29wZU5hbWUgPT09IGNvbnRleHQuc2VsZkdyYW1tYXIuc2NvcGVOYW1lID8gY29udGV4dC5zZWxmR3JhbW1hciA6IHJlZmVyZW5jZS5zY29wZU5hbWUgPT09IGNvbnRleHQuYmFzZUdyYW1tYXIuc2NvcGVOYW1lID8gY29udGV4dC5iYXNlR3JhbW1hciA6IHZvaWQgMDtcbiAgICAgICAgaWYgKHNlbGZHcmFtbWFyKSB7XG4gICAgICAgICAgY29uc3QgbmV3Q29udGV4dCA9IHsgYmFzZUdyYW1tYXI6IGNvbnRleHQuYmFzZUdyYW1tYXIsIHNlbGZHcmFtbWFyLCByZXBvc2l0b3J5OiBwYXR0ZXJuUmVwb3NpdG9yeSB9O1xuICAgICAgICAgIGlmIChyZWZlcmVuY2Uua2luZCA9PT0gNCAvKiBUb3BMZXZlbFJlcG9zaXRvcnlSZWZlcmVuY2UgKi8pIHtcbiAgICAgICAgICAgIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblRvcExldmVsUmVwb3NpdG9yeVJ1bGUocmVmZXJlbmNlLnJ1bGVOYW1lLCBuZXdDb250ZXh0LCByZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5Ub3BMZXZlbFJ1bGUobmV3Q29udGV4dCwgcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHJlZmVyZW5jZS5raW5kID09PSA0IC8qIFRvcExldmVsUmVwb3NpdG9yeVJlZmVyZW5jZSAqLykge1xuICAgICAgICAgICAgcmVzdWx0LmFkZChuZXcgVG9wTGV2ZWxSZXBvc2l0b3J5UnVsZVJlZmVyZW5jZShyZWZlcmVuY2Uuc2NvcGVOYW1lLCByZWZlcmVuY2UucnVsZU5hbWUpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmFkZChuZXcgVG9wTGV2ZWxSdWxlUmVmZXJlbmNlKHJlZmVyZW5jZS5zY29wZU5hbWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG52YXIgQmFzZVJlZmVyZW5jZSA9IGNsYXNzIHtcbiAga2luZCA9IDAgLyogQmFzZSAqLztcbn07XG52YXIgU2VsZlJlZmVyZW5jZSA9IGNsYXNzIHtcbiAga2luZCA9IDEgLyogU2VsZiAqLztcbn07XG52YXIgUmVsYXRpdmVSZWZlcmVuY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJ1bGVOYW1lKSB7XG4gICAgdGhpcy5ydWxlTmFtZSA9IHJ1bGVOYW1lO1xuICB9XG4gIGtpbmQgPSAyIC8qIFJlbGF0aXZlUmVmZXJlbmNlICovO1xufTtcbnZhciBUb3BMZXZlbFJlZmVyZW5jZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2NvcGVOYW1lKSB7XG4gICAgdGhpcy5zY29wZU5hbWUgPSBzY29wZU5hbWU7XG4gIH1cbiAga2luZCA9IDMgLyogVG9wTGV2ZWxSZWZlcmVuY2UgKi87XG59O1xudmFyIFRvcExldmVsUmVwb3NpdG9yeVJlZmVyZW5jZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2NvcGVOYW1lLCBydWxlTmFtZSkge1xuICAgIHRoaXMuc2NvcGVOYW1lID0gc2NvcGVOYW1lO1xuICAgIHRoaXMucnVsZU5hbWUgPSBydWxlTmFtZTtcbiAgfVxuICBraW5kID0gNCAvKiBUb3BMZXZlbFJlcG9zaXRvcnlSZWZlcmVuY2UgKi87XG59O1xuZnVuY3Rpb24gcGFyc2VJbmNsdWRlKGluY2x1ZGUpIHtcbiAgaWYgKGluY2x1ZGUgPT09IFwiJGJhc2VcIikge1xuICAgIHJldHVybiBuZXcgQmFzZVJlZmVyZW5jZSgpO1xuICB9IGVsc2UgaWYgKGluY2x1ZGUgPT09IFwiJHNlbGZcIikge1xuICAgIHJldHVybiBuZXcgU2VsZlJlZmVyZW5jZSgpO1xuICB9XG4gIGNvbnN0IGluZGV4T2ZTaGFycCA9IGluY2x1ZGUuaW5kZXhPZihcIiNcIik7XG4gIGlmIChpbmRleE9mU2hhcnAgPT09IC0xKSB7XG4gICAgcmV0dXJuIG5ldyBUb3BMZXZlbFJlZmVyZW5jZShpbmNsdWRlKTtcbiAgfSBlbHNlIGlmIChpbmRleE9mU2hhcnAgPT09IDApIHtcbiAgICByZXR1cm4gbmV3IFJlbGF0aXZlUmVmZXJlbmNlKGluY2x1ZGUuc3Vic3RyaW5nKDEpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzY29wZU5hbWUgPSBpbmNsdWRlLnN1YnN0cmluZygwLCBpbmRleE9mU2hhcnApO1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gaW5jbHVkZS5zdWJzdHJpbmcoaW5kZXhPZlNoYXJwICsgMSk7XG4gICAgcmV0dXJuIG5ldyBUb3BMZXZlbFJlcG9zaXRvcnlSZWZlcmVuY2Uoc2NvcGVOYW1lLCBydWxlTmFtZSk7XG4gIH1cbn1cblxuLy8gc3JjL3J1bGUudHNcbnZhciBIQVNfQkFDS19SRUZFUkVOQ0VTID0gL1xcXFwoXFxkKykvO1xudmFyIEJBQ0tfUkVGRVJFTkNJTkdfRU5EID0gL1xcXFwoXFxkKykvZztcbnZhciBydWxlSWRTeW1ib2wgPSBTeW1ib2woXCJSdWxlSWRcIik7XG52YXIgZW5kUnVsZUlkID0gLTE7XG52YXIgd2hpbGVSdWxlSWQgPSAtMjtcbmZ1bmN0aW9uIHJ1bGVJZEZyb21OdW1iZXIoaWQpIHtcbiAgcmV0dXJuIGlkO1xufVxuZnVuY3Rpb24gcnVsZUlkVG9OdW1iZXIoaWQpIHtcbiAgcmV0dXJuIGlkO1xufVxudmFyIFJ1bGUgPSBjbGFzcyB7XG4gICRsb2NhdGlvbjtcbiAgaWQ7XG4gIF9uYW1lSXNDYXB0dXJpbmc7XG4gIF9uYW1lO1xuICBfY29udGVudE5hbWVJc0NhcHR1cmluZztcbiAgX2NvbnRlbnROYW1lO1xuICBjb25zdHJ1Y3RvcigkbG9jYXRpb24sIGlkLCBuYW1lLCBjb250ZW50TmFtZSkge1xuICAgIHRoaXMuJGxvY2F0aW9uID0gJGxvY2F0aW9uO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLl9uYW1lID0gbmFtZSB8fCBudWxsO1xuICAgIHRoaXMuX25hbWVJc0NhcHR1cmluZyA9IFJlZ2V4U291cmNlLmhhc0NhcHR1cmVzKHRoaXMuX25hbWUpO1xuICAgIHRoaXMuX2NvbnRlbnROYW1lID0gY29udGVudE5hbWUgfHwgbnVsbDtcbiAgICB0aGlzLl9jb250ZW50TmFtZUlzQ2FwdHVyaW5nID0gUmVnZXhTb3VyY2UuaGFzQ2FwdHVyZXModGhpcy5fY29udGVudE5hbWUpO1xuICB9XG4gIGdldCBkZWJ1Z05hbWUoKSB7XG4gICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLiRsb2NhdGlvbiA/IGAke2Jhc2VuYW1lKHRoaXMuJGxvY2F0aW9uLmZpbGVuYW1lKX06JHt0aGlzLiRsb2NhdGlvbi5saW5lfWAgOiBcInVua25vd25cIjtcbiAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSMke3RoaXMuaWR9IEAgJHtsb2NhdGlvbn1gO1xuICB9XG4gIGdldE5hbWUobGluZVRleHQsIGNhcHR1cmVJbmRpY2VzKSB7XG4gICAgaWYgKCF0aGlzLl9uYW1lSXNDYXB0dXJpbmcgfHwgdGhpcy5fbmFtZSA9PT0gbnVsbCB8fCBsaW5lVGV4dCA9PT0gbnVsbCB8fCBjYXB0dXJlSW5kaWNlcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIHJldHVybiBSZWdleFNvdXJjZS5yZXBsYWNlQ2FwdHVyZXModGhpcy5fbmFtZSwgbGluZVRleHQsIGNhcHR1cmVJbmRpY2VzKTtcbiAgfVxuICBnZXRDb250ZW50TmFtZShsaW5lVGV4dCwgY2FwdHVyZUluZGljZXMpIHtcbiAgICBpZiAoIXRoaXMuX2NvbnRlbnROYW1lSXNDYXB0dXJpbmcgfHwgdGhpcy5fY29udGVudE5hbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZW50TmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIFJlZ2V4U291cmNlLnJlcGxhY2VDYXB0dXJlcyh0aGlzLl9jb250ZW50TmFtZSwgbGluZVRleHQsIGNhcHR1cmVJbmRpY2VzKTtcbiAgfVxufTtcbnZhciBDYXB0dXJlUnVsZSA9IGNsYXNzIGV4dGVuZHMgUnVsZSB7XG4gIHJldG9rZW5pemVDYXB0dXJlZFdpdGhSdWxlSWQ7XG4gIGNvbnN0cnVjdG9yKCRsb2NhdGlvbiwgaWQsIG5hbWUsIGNvbnRlbnROYW1lLCByZXRva2VuaXplQ2FwdHVyZWRXaXRoUnVsZUlkKSB7XG4gICAgc3VwZXIoJGxvY2F0aW9uLCBpZCwgbmFtZSwgY29udGVudE5hbWUpO1xuICAgIHRoaXMucmV0b2tlbml6ZUNhcHR1cmVkV2l0aFJ1bGVJZCA9IHJldG9rZW5pemVDYXB0dXJlZFdpdGhSdWxlSWQ7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgfVxuICBjb2xsZWN0UGF0dGVybnMoZ3JhbW1hciwgb3V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZCFcIik7XG4gIH1cbiAgY29tcGlsZShncmFtbWFyLCBlbmRSZWdleFNvdXJjZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQhXCIpO1xuICB9XG4gIGNvbXBpbGVBRyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSwgYWxsb3dBLCBhbGxvd0cpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkIVwiKTtcbiAgfVxufTtcbnZhciBNYXRjaFJ1bGUgPSBjbGFzcyBleHRlbmRzIFJ1bGUge1xuICBfbWF0Y2g7XG4gIGNhcHR1cmVzO1xuICBfY2FjaGVkQ29tcGlsZWRQYXR0ZXJucztcbiAgY29uc3RydWN0b3IoJGxvY2F0aW9uLCBpZCwgbmFtZSwgbWF0Y2gsIGNhcHR1cmVzKSB7XG4gICAgc3VwZXIoJGxvY2F0aW9uLCBpZCwgbmFtZSwgbnVsbCk7XG4gICAgdGhpcy5fbWF0Y2ggPSBuZXcgUmVnRXhwU291cmNlKG1hdGNoLCB0aGlzLmlkKTtcbiAgICB0aGlzLmNhcHR1cmVzID0gY2FwdHVyZXM7XG4gICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyA9IG51bGw7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucykge1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZ2V0IGRlYnVnTWF0Y2hSZWdFeHAoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuX21hdGNoLnNvdXJjZX1gO1xuICB9XG4gIGNvbGxlY3RQYXR0ZXJucyhncmFtbWFyLCBvdXQpIHtcbiAgICBvdXQucHVzaCh0aGlzLl9tYXRjaCk7XG4gIH1cbiAgY29tcGlsZShncmFtbWFyLCBlbmRSZWdleFNvdXJjZSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZWRDb21waWxlZFBhdHRlcm5zKGdyYW1tYXIpLmNvbXBpbGUoZ3JhbW1hcik7XG4gIH1cbiAgY29tcGlsZUFHKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlLCBhbGxvd0EsIGFsbG93Rykge1xuICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZWRDb21waWxlZFBhdHRlcm5zKGdyYW1tYXIpLmNvbXBpbGVBRyhncmFtbWFyLCBhbGxvd0EsIGFsbG93Ryk7XG4gIH1cbiAgX2dldENhY2hlZENvbXBpbGVkUGF0dGVybnMoZ3JhbW1hcikge1xuICAgIGlmICghdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucykge1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyA9IG5ldyBSZWdFeHBTb3VyY2VMaXN0KCk7XG4gICAgICB0aGlzLmNvbGxlY3RQYXR0ZXJucyhncmFtbWFyLCB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnM7XG4gIH1cbn07XG52YXIgSW5jbHVkZU9ubHlSdWxlID0gY2xhc3MgZXh0ZW5kcyBSdWxlIHtcbiAgaGFzTWlzc2luZ1BhdHRlcm5zO1xuICBwYXR0ZXJucztcbiAgX2NhY2hlZENvbXBpbGVkUGF0dGVybnM7XG4gIGNvbnN0cnVjdG9yKCRsb2NhdGlvbiwgaWQsIG5hbWUsIGNvbnRlbnROYW1lLCBwYXR0ZXJucykge1xuICAgIHN1cGVyKCRsb2NhdGlvbiwgaWQsIG5hbWUsIGNvbnRlbnROYW1lKTtcbiAgICB0aGlzLnBhdHRlcm5zID0gcGF0dGVybnMucGF0dGVybnM7XG4gICAgdGhpcy5oYXNNaXNzaW5nUGF0dGVybnMgPSBwYXR0ZXJucy5oYXNNaXNzaW5nUGF0dGVybnM7XG4gICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyA9IG51bGw7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucykge1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgY29sbGVjdFBhdHRlcm5zKGdyYW1tYXIsIG91dCkge1xuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiB0aGlzLnBhdHRlcm5zKSB7XG4gICAgICBjb25zdCBydWxlID0gZ3JhbW1hci5nZXRSdWxlKHBhdHRlcm4pO1xuICAgICAgcnVsZS5jb2xsZWN0UGF0dGVybnMoZ3JhbW1hciwgb3V0KTtcbiAgICB9XG4gIH1cbiAgY29tcGlsZShncmFtbWFyLCBlbmRSZWdleFNvdXJjZSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZWRDb21waWxlZFBhdHRlcm5zKGdyYW1tYXIpLmNvbXBpbGUoZ3JhbW1hcik7XG4gIH1cbiAgY29tcGlsZUFHKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlLCBhbGxvd0EsIGFsbG93Rykge1xuICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZWRDb21waWxlZFBhdHRlcm5zKGdyYW1tYXIpLmNvbXBpbGVBRyhncmFtbWFyLCBhbGxvd0EsIGFsbG93Ryk7XG4gIH1cbiAgX2dldENhY2hlZENvbXBpbGVkUGF0dGVybnMoZ3JhbW1hcikge1xuICAgIGlmICghdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucykge1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyA9IG5ldyBSZWdFeHBTb3VyY2VMaXN0KCk7XG4gICAgICB0aGlzLmNvbGxlY3RQYXR0ZXJucyhncmFtbWFyLCB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnM7XG4gIH1cbn07XG52YXIgQmVnaW5FbmRSdWxlID0gY2xhc3MgZXh0ZW5kcyBSdWxlIHtcbiAgX2JlZ2luO1xuICBiZWdpbkNhcHR1cmVzO1xuICBfZW5kO1xuICBlbmRIYXNCYWNrUmVmZXJlbmNlcztcbiAgZW5kQ2FwdHVyZXM7XG4gIGFwcGx5RW5kUGF0dGVybkxhc3Q7XG4gIGhhc01pc3NpbmdQYXR0ZXJucztcbiAgcGF0dGVybnM7XG4gIF9jYWNoZWRDb21waWxlZFBhdHRlcm5zO1xuICBjb25zdHJ1Y3RvcigkbG9jYXRpb24sIGlkLCBuYW1lLCBjb250ZW50TmFtZSwgYmVnaW4sIGJlZ2luQ2FwdHVyZXMsIGVuZCwgZW5kQ2FwdHVyZXMsIGFwcGx5RW5kUGF0dGVybkxhc3QsIHBhdHRlcm5zKSB7XG4gICAgc3VwZXIoJGxvY2F0aW9uLCBpZCwgbmFtZSwgY29udGVudE5hbWUpO1xuICAgIHRoaXMuX2JlZ2luID0gbmV3IFJlZ0V4cFNvdXJjZShiZWdpbiwgdGhpcy5pZCk7XG4gICAgdGhpcy5iZWdpbkNhcHR1cmVzID0gYmVnaW5DYXB0dXJlcztcbiAgICB0aGlzLl9lbmQgPSBuZXcgUmVnRXhwU291cmNlKGVuZCA/IGVuZCA6IFwiXFx1RkZGRlwiLCAtMSk7XG4gICAgdGhpcy5lbmRIYXNCYWNrUmVmZXJlbmNlcyA9IHRoaXMuX2VuZC5oYXNCYWNrUmVmZXJlbmNlcztcbiAgICB0aGlzLmVuZENhcHR1cmVzID0gZW5kQ2FwdHVyZXM7XG4gICAgdGhpcy5hcHBseUVuZFBhdHRlcm5MYXN0ID0gYXBwbHlFbmRQYXR0ZXJuTGFzdCB8fCBmYWxzZTtcbiAgICB0aGlzLnBhdHRlcm5zID0gcGF0dGVybnMucGF0dGVybnM7XG4gICAgdGhpcy5oYXNNaXNzaW5nUGF0dGVybnMgPSBwYXR0ZXJucy5oYXNNaXNzaW5nUGF0dGVybnM7XG4gICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyA9IG51bGw7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucykge1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZ2V0IGRlYnVnQmVnaW5SZWdFeHAoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuX2JlZ2luLnNvdXJjZX1gO1xuICB9XG4gIGdldCBkZWJ1Z0VuZFJlZ0V4cCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5fZW5kLnNvdXJjZX1gO1xuICB9XG4gIGdldEVuZFdpdGhSZXNvbHZlZEJhY2tSZWZlcmVuY2VzKGxpbmVUZXh0LCBjYXB0dXJlSW5kaWNlcykge1xuICAgIHJldHVybiB0aGlzLl9lbmQucmVzb2x2ZUJhY2tSZWZlcmVuY2VzKGxpbmVUZXh0LCBjYXB0dXJlSW5kaWNlcyk7XG4gIH1cbiAgY29sbGVjdFBhdHRlcm5zKGdyYW1tYXIsIG91dCkge1xuICAgIG91dC5wdXNoKHRoaXMuX2JlZ2luKTtcbiAgfVxuICBjb21waWxlKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENhY2hlZENvbXBpbGVkUGF0dGVybnMoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpLmNvbXBpbGUoZ3JhbW1hcik7XG4gIH1cbiAgY29tcGlsZUFHKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlLCBhbGxvd0EsIGFsbG93Rykge1xuICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZWRDb21waWxlZFBhdHRlcm5zKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKS5jb21waWxlQUcoZ3JhbW1hciwgYWxsb3dBLCBhbGxvd0cpO1xuICB9XG4gIF9nZXRDYWNoZWRDb21waWxlZFBhdHRlcm5zKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zKSB7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zID0gbmV3IFJlZ0V4cFNvdXJjZUxpc3QoKTtcbiAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiB0aGlzLnBhdHRlcm5zKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBncmFtbWFyLmdldFJ1bGUocGF0dGVybik7XG4gICAgICAgIHJ1bGUuY29sbGVjdFBhdHRlcm5zKGdyYW1tYXIsIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYXBwbHlFbmRQYXR0ZXJuTGFzdCkge1xuICAgICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zLnB1c2godGhpcy5fZW5kLmhhc0JhY2tSZWZlcmVuY2VzID8gdGhpcy5fZW5kLmNsb25lKCkgOiB0aGlzLl9lbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucy51bnNoaWZ0KHRoaXMuX2VuZC5oYXNCYWNrUmVmZXJlbmNlcyA/IHRoaXMuX2VuZC5jbG9uZSgpIDogdGhpcy5fZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX2VuZC5oYXNCYWNrUmVmZXJlbmNlcykge1xuICAgICAgaWYgKHRoaXMuYXBwbHlFbmRQYXR0ZXJuTGFzdCkge1xuICAgICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zLnNldFNvdXJjZSh0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zLmxlbmd0aCgpIC0gMSwgZW5kUmVnZXhTb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucy5zZXRTb3VyY2UoMCwgZW5kUmVnZXhTb3VyY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucztcbiAgfVxufTtcbnZhciBCZWdpbldoaWxlUnVsZSA9IGNsYXNzIGV4dGVuZHMgUnVsZSB7XG4gIF9iZWdpbjtcbiAgYmVnaW5DYXB0dXJlcztcbiAgd2hpbGVDYXB0dXJlcztcbiAgX3doaWxlO1xuICB3aGlsZUhhc0JhY2tSZWZlcmVuY2VzO1xuICBoYXNNaXNzaW5nUGF0dGVybnM7XG4gIHBhdHRlcm5zO1xuICBfY2FjaGVkQ29tcGlsZWRQYXR0ZXJucztcbiAgX2NhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucztcbiAgY29uc3RydWN0b3IoJGxvY2F0aW9uLCBpZCwgbmFtZSwgY29udGVudE5hbWUsIGJlZ2luLCBiZWdpbkNhcHR1cmVzLCBfd2hpbGUsIHdoaWxlQ2FwdHVyZXMsIHBhdHRlcm5zKSB7XG4gICAgc3VwZXIoJGxvY2F0aW9uLCBpZCwgbmFtZSwgY29udGVudE5hbWUpO1xuICAgIHRoaXMuX2JlZ2luID0gbmV3IFJlZ0V4cFNvdXJjZShiZWdpbiwgdGhpcy5pZCk7XG4gICAgdGhpcy5iZWdpbkNhcHR1cmVzID0gYmVnaW5DYXB0dXJlcztcbiAgICB0aGlzLndoaWxlQ2FwdHVyZXMgPSB3aGlsZUNhcHR1cmVzO1xuICAgIHRoaXMuX3doaWxlID0gbmV3IFJlZ0V4cFNvdXJjZShfd2hpbGUsIHdoaWxlUnVsZUlkKTtcbiAgICB0aGlzLndoaWxlSGFzQmFja1JlZmVyZW5jZXMgPSB0aGlzLl93aGlsZS5oYXNCYWNrUmVmZXJlbmNlcztcbiAgICB0aGlzLnBhdHRlcm5zID0gcGF0dGVybnMucGF0dGVybnM7XG4gICAgdGhpcy5oYXNNaXNzaW5nUGF0dGVybnMgPSBwYXR0ZXJucy5oYXNNaXNzaW5nUGF0dGVybnM7XG4gICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyA9IG51bGw7XG4gICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRXaGlsZVBhdHRlcm5zID0gbnVsbDtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zKSB7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2FjaGVkQ29tcGlsZWRXaGlsZVBhdHRlcm5zKSB7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFdoaWxlUGF0dGVybnMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRXaGlsZVBhdHRlcm5zID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZ2V0IGRlYnVnQmVnaW5SZWdFeHAoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuX2JlZ2luLnNvdXJjZX1gO1xuICB9XG4gIGdldCBkZWJ1Z1doaWxlUmVnRXhwKCkge1xuICAgIHJldHVybiBgJHt0aGlzLl93aGlsZS5zb3VyY2V9YDtcbiAgfVxuICBnZXRXaGlsZVdpdGhSZXNvbHZlZEJhY2tSZWZlcmVuY2VzKGxpbmVUZXh0LCBjYXB0dXJlSW5kaWNlcykge1xuICAgIHJldHVybiB0aGlzLl93aGlsZS5yZXNvbHZlQmFja1JlZmVyZW5jZXMobGluZVRleHQsIGNhcHR1cmVJbmRpY2VzKTtcbiAgfVxuICBjb2xsZWN0UGF0dGVybnMoZ3JhbW1hciwgb3V0KSB7XG4gICAgb3V0LnB1c2godGhpcy5fYmVnaW4pO1xuICB9XG4gIGNvbXBpbGUoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyKS5jb21waWxlKGdyYW1tYXIpO1xuICB9XG4gIGNvbXBpbGVBRyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSwgYWxsb3dBLCBhbGxvd0cpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyKS5jb21waWxlQUcoZ3JhbW1hciwgYWxsb3dBLCBhbGxvd0cpO1xuICB9XG4gIF9nZXRDYWNoZWRDb21waWxlZFBhdHRlcm5zKGdyYW1tYXIpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpIHtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBuZXcgUmVnRXhwU291cmNlTGlzdCgpO1xuICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHRoaXMucGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IGdyYW1tYXIuZ2V0UnVsZShwYXR0ZXJuKTtcbiAgICAgICAgcnVsZS5jb2xsZWN0UGF0dGVybnMoZ3JhbW1hciwgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zO1xuICB9XG4gIGNvbXBpbGVXaGlsZShncmFtbWFyLCBlbmRSZWdleFNvdXJjZSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZWRDb21waWxlZFdoaWxlUGF0dGVybnMoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpLmNvbXBpbGUoZ3JhbW1hcik7XG4gIH1cbiAgY29tcGlsZVdoaWxlQUcoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UsIGFsbG93QSwgYWxsb3dHKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSkuY29tcGlsZUFHKGdyYW1tYXIsIGFsbG93QSwgYWxsb3dHKTtcbiAgfVxuICBfZ2V0Q2FjaGVkQ29tcGlsZWRXaGlsZVBhdHRlcm5zKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWRDb21waWxlZFdoaWxlUGF0dGVybnMpIHtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucyA9IG5ldyBSZWdFeHBTb3VyY2VMaXN0KCk7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFdoaWxlUGF0dGVybnMucHVzaCh0aGlzLl93aGlsZS5oYXNCYWNrUmVmZXJlbmNlcyA/IHRoaXMuX3doaWxlLmNsb25lKCkgOiB0aGlzLl93aGlsZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl93aGlsZS5oYXNCYWNrUmVmZXJlbmNlcykge1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRXaGlsZVBhdHRlcm5zLnNldFNvdXJjZSgwLCBlbmRSZWdleFNvdXJjZSA/IGVuZFJlZ2V4U291cmNlIDogXCJcXHVGRkZGXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkQ29tcGlsZWRXaGlsZVBhdHRlcm5zO1xuICB9XG59O1xudmFyIFJ1bGVGYWN0b3J5ID0gY2xhc3MgX1J1bGVGYWN0b3J5IHtcbiAgc3RhdGljIGNyZWF0ZUNhcHR1cmVSdWxlKGhlbHBlciwgJGxvY2F0aW9uLCBuYW1lLCBjb250ZW50TmFtZSwgcmV0b2tlbml6ZUNhcHR1cmVkV2l0aFJ1bGVJZCkge1xuICAgIHJldHVybiBoZWxwZXIucmVnaXN0ZXJSdWxlKChpZCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBDYXB0dXJlUnVsZSgkbG9jYXRpb24sIGlkLCBuYW1lLCBjb250ZW50TmFtZSwgcmV0b2tlbml6ZUNhcHR1cmVkV2l0aFJ1bGVJZCk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldENvbXBpbGVkUnVsZUlkKGRlc2MsIGhlbHBlciwgcmVwb3NpdG9yeSkge1xuICAgIGlmICghZGVzYy5pZCkge1xuICAgICAgaGVscGVyLnJlZ2lzdGVyUnVsZSgoaWQpID0+IHtcbiAgICAgICAgZGVzYy5pZCA9IGlkO1xuICAgICAgICBpZiAoZGVzYy5tYXRjaCkge1xuICAgICAgICAgIHJldHVybiBuZXcgTWF0Y2hSdWxlKFxuICAgICAgICAgICAgZGVzYy4kdnNjb2RlVGV4dG1hdGVMb2NhdGlvbixcbiAgICAgICAgICAgIGRlc2MuaWQsXG4gICAgICAgICAgICBkZXNjLm5hbWUsXG4gICAgICAgICAgICBkZXNjLm1hdGNoLFxuICAgICAgICAgICAgX1J1bGVGYWN0b3J5Ll9jb21waWxlQ2FwdHVyZXMoZGVzYy5jYXB0dXJlcywgaGVscGVyLCByZXBvc2l0b3J5KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkZXNjLmJlZ2luID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaWYgKGRlc2MucmVwb3NpdG9yeSkge1xuICAgICAgICAgICAgcmVwb3NpdG9yeSA9IG1lcmdlT2JqZWN0cyh7fSwgcmVwb3NpdG9yeSwgZGVzYy5yZXBvc2l0b3J5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHBhdHRlcm5zID0gZGVzYy5wYXR0ZXJucztcbiAgICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm5zID09PSBcInVuZGVmaW5lZFwiICYmIGRlc2MuaW5jbHVkZSkge1xuICAgICAgICAgICAgcGF0dGVybnMgPSBbeyBpbmNsdWRlOiBkZXNjLmluY2x1ZGUgfV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgSW5jbHVkZU9ubHlSdWxlKFxuICAgICAgICAgICAgZGVzYy4kdnNjb2RlVGV4dG1hdGVMb2NhdGlvbixcbiAgICAgICAgICAgIGRlc2MuaWQsXG4gICAgICAgICAgICBkZXNjLm5hbWUsXG4gICAgICAgICAgICBkZXNjLmNvbnRlbnROYW1lLFxuICAgICAgICAgICAgX1J1bGVGYWN0b3J5Ll9jb21waWxlUGF0dGVybnMocGF0dGVybnMsIGhlbHBlciwgcmVwb3NpdG9yeSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXNjLndoaWxlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCZWdpbldoaWxlUnVsZShcbiAgICAgICAgICAgIGRlc2MuJHZzY29kZVRleHRtYXRlTG9jYXRpb24sXG4gICAgICAgICAgICBkZXNjLmlkLFxuICAgICAgICAgICAgZGVzYy5uYW1lLFxuICAgICAgICAgICAgZGVzYy5jb250ZW50TmFtZSxcbiAgICAgICAgICAgIGRlc2MuYmVnaW4sXG4gICAgICAgICAgICBfUnVsZUZhY3RvcnkuX2NvbXBpbGVDYXB0dXJlcyhkZXNjLmJlZ2luQ2FwdHVyZXMgfHwgZGVzYy5jYXB0dXJlcywgaGVscGVyLCByZXBvc2l0b3J5KSxcbiAgICAgICAgICAgIGRlc2Mud2hpbGUsXG4gICAgICAgICAgICBfUnVsZUZhY3RvcnkuX2NvbXBpbGVDYXB0dXJlcyhkZXNjLndoaWxlQ2FwdHVyZXMgfHwgZGVzYy5jYXB0dXJlcywgaGVscGVyLCByZXBvc2l0b3J5KSxcbiAgICAgICAgICAgIF9SdWxlRmFjdG9yeS5fY29tcGlsZVBhdHRlcm5zKGRlc2MucGF0dGVybnMsIGhlbHBlciwgcmVwb3NpdG9yeSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQmVnaW5FbmRSdWxlKFxuICAgICAgICAgIGRlc2MuJHZzY29kZVRleHRtYXRlTG9jYXRpb24sXG4gICAgICAgICAgZGVzYy5pZCxcbiAgICAgICAgICBkZXNjLm5hbWUsXG4gICAgICAgICAgZGVzYy5jb250ZW50TmFtZSxcbiAgICAgICAgICBkZXNjLmJlZ2luLFxuICAgICAgICAgIF9SdWxlRmFjdG9yeS5fY29tcGlsZUNhcHR1cmVzKGRlc2MuYmVnaW5DYXB0dXJlcyB8fCBkZXNjLmNhcHR1cmVzLCBoZWxwZXIsIHJlcG9zaXRvcnkpLFxuICAgICAgICAgIGRlc2MuZW5kLFxuICAgICAgICAgIF9SdWxlRmFjdG9yeS5fY29tcGlsZUNhcHR1cmVzKGRlc2MuZW5kQ2FwdHVyZXMgfHwgZGVzYy5jYXB0dXJlcywgaGVscGVyLCByZXBvc2l0b3J5KSxcbiAgICAgICAgICBkZXNjLmFwcGx5RW5kUGF0dGVybkxhc3QsXG4gICAgICAgICAgX1J1bGVGYWN0b3J5Ll9jb21waWxlUGF0dGVybnMoZGVzYy5wYXR0ZXJucywgaGVscGVyLCByZXBvc2l0b3J5KVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjLmlkO1xuICB9XG4gIHN0YXRpYyBfY29tcGlsZUNhcHR1cmVzKGNhcHR1cmVzLCBoZWxwZXIsIHJlcG9zaXRvcnkpIHtcbiAgICBsZXQgciA9IFtdO1xuICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgbGV0IG1heGltdW1DYXB0dXJlSWQgPSAwO1xuICAgICAgZm9yIChjb25zdCBjYXB0dXJlSWQgaW4gY2FwdHVyZXMpIHtcbiAgICAgICAgaWYgKGNhcHR1cmVJZCA9PT0gXCIkdnNjb2RlVGV4dG1hdGVMb2NhdGlvblwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnVtZXJpY0NhcHR1cmVJZCA9IHBhcnNlSW50KGNhcHR1cmVJZCwgMTApO1xuICAgICAgICBpZiAobnVtZXJpY0NhcHR1cmVJZCA+IG1heGltdW1DYXB0dXJlSWQpIHtcbiAgICAgICAgICBtYXhpbXVtQ2FwdHVyZUlkID0gbnVtZXJpY0NhcHR1cmVJZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbWF4aW11bUNhcHR1cmVJZDsgaSsrKSB7XG4gICAgICAgIHJbaV0gPSBudWxsO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjYXB0dXJlSWQgaW4gY2FwdHVyZXMpIHtcbiAgICAgICAgaWYgKGNhcHR1cmVJZCA9PT0gXCIkdnNjb2RlVGV4dG1hdGVMb2NhdGlvblwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnVtZXJpY0NhcHR1cmVJZCA9IHBhcnNlSW50KGNhcHR1cmVJZCwgMTApO1xuICAgICAgICBsZXQgcmV0b2tlbml6ZUNhcHR1cmVkV2l0aFJ1bGVJZCA9IDA7XG4gICAgICAgIGlmIChjYXB0dXJlc1tjYXB0dXJlSWRdLnBhdHRlcm5zKSB7XG4gICAgICAgICAgcmV0b2tlbml6ZUNhcHR1cmVkV2l0aFJ1bGVJZCA9IF9SdWxlRmFjdG9yeS5nZXRDb21waWxlZFJ1bGVJZChjYXB0dXJlc1tjYXB0dXJlSWRdLCBoZWxwZXIsIHJlcG9zaXRvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJbbnVtZXJpY0NhcHR1cmVJZF0gPSBfUnVsZUZhY3RvcnkuY3JlYXRlQ2FwdHVyZVJ1bGUoaGVscGVyLCBjYXB0dXJlc1tjYXB0dXJlSWRdLiR2c2NvZGVUZXh0bWF0ZUxvY2F0aW9uLCBjYXB0dXJlc1tjYXB0dXJlSWRdLm5hbWUsIGNhcHR1cmVzW2NhcHR1cmVJZF0uY29udGVudE5hbWUsIHJldG9rZW5pemVDYXB0dXJlZFdpdGhSdWxlSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICBzdGF0aWMgX2NvbXBpbGVQYXR0ZXJucyhwYXR0ZXJucywgaGVscGVyLCByZXBvc2l0b3J5KSB7XG4gICAgbGV0IHIgPSBbXTtcbiAgICBpZiAocGF0dGVybnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYXR0ZXJucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gcGF0dGVybnNbaV07XG4gICAgICAgIGxldCBydWxlSWQgPSAtMTtcbiAgICAgICAgaWYgKHBhdHRlcm4uaW5jbHVkZSkge1xuICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZSA9IHBhcnNlSW5jbHVkZShwYXR0ZXJuLmluY2x1ZGUpO1xuICAgICAgICAgIHN3aXRjaCAocmVmZXJlbmNlLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBCYXNlICovOlxuICAgICAgICAgICAgY2FzZSAxIC8qIFNlbGYgKi86XG4gICAgICAgICAgICAgIHJ1bGVJZCA9IF9SdWxlRmFjdG9yeS5nZXRDb21waWxlZFJ1bGVJZChyZXBvc2l0b3J5W3BhdHRlcm4uaW5jbHVkZV0sIGhlbHBlciwgcmVwb3NpdG9yeSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIFJlbGF0aXZlUmVmZXJlbmNlICovOlxuICAgICAgICAgICAgICBsZXQgbG9jYWxJbmNsdWRlZFJ1bGUgPSByZXBvc2l0b3J5W3JlZmVyZW5jZS5ydWxlTmFtZV07XG4gICAgICAgICAgICAgIGlmIChsb2NhbEluY2x1ZGVkUnVsZSkge1xuICAgICAgICAgICAgICAgIHJ1bGVJZCA9IF9SdWxlRmFjdG9yeS5nZXRDb21waWxlZFJ1bGVJZChsb2NhbEluY2x1ZGVkUnVsZSwgaGVscGVyLCByZXBvc2l0b3J5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMyAvKiBUb3BMZXZlbFJlZmVyZW5jZSAqLzpcbiAgICAgICAgICAgIGNhc2UgNCAvKiBUb3BMZXZlbFJlcG9zaXRvcnlSZWZlcmVuY2UgKi86XG4gICAgICAgICAgICAgIGNvbnN0IGV4dGVybmFsR3JhbW1hck5hbWUgPSByZWZlcmVuY2Uuc2NvcGVOYW1lO1xuICAgICAgICAgICAgICBjb25zdCBleHRlcm5hbEdyYW1tYXJJbmNsdWRlID0gcmVmZXJlbmNlLmtpbmQgPT09IDQgLyogVG9wTGV2ZWxSZXBvc2l0b3J5UmVmZXJlbmNlICovID8gcmVmZXJlbmNlLnJ1bGVOYW1lIDogbnVsbDtcbiAgICAgICAgICAgICAgY29uc3QgZXh0ZXJuYWxHcmFtbWFyID0gaGVscGVyLmdldEV4dGVybmFsR3JhbW1hcihleHRlcm5hbEdyYW1tYXJOYW1lLCByZXBvc2l0b3J5KTtcbiAgICAgICAgICAgICAgaWYgKGV4dGVybmFsR3JhbW1hcikge1xuICAgICAgICAgICAgICAgIGlmIChleHRlcm5hbEdyYW1tYXJJbmNsdWRlKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgZXh0ZXJuYWxJbmNsdWRlZFJ1bGUgPSBleHRlcm5hbEdyYW1tYXIucmVwb3NpdG9yeVtleHRlcm5hbEdyYW1tYXJJbmNsdWRlXTtcbiAgICAgICAgICAgICAgICAgIGlmIChleHRlcm5hbEluY2x1ZGVkUnVsZSkge1xuICAgICAgICAgICAgICAgICAgICBydWxlSWQgPSBfUnVsZUZhY3RvcnkuZ2V0Q29tcGlsZWRSdWxlSWQoZXh0ZXJuYWxJbmNsdWRlZFJ1bGUsIGhlbHBlciwgZXh0ZXJuYWxHcmFtbWFyLnJlcG9zaXRvcnkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcnVsZUlkID0gX1J1bGVGYWN0b3J5LmdldENvbXBpbGVkUnVsZUlkKGV4dGVybmFsR3JhbW1hci5yZXBvc2l0b3J5LiRzZWxmLCBoZWxwZXIsIGV4dGVybmFsR3JhbW1hci5yZXBvc2l0b3J5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ1bGVJZCA9IF9SdWxlRmFjdG9yeS5nZXRDb21waWxlZFJ1bGVJZChwYXR0ZXJuLCBoZWxwZXIsIHJlcG9zaXRvcnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgY29uc3QgcnVsZSA9IGhlbHBlci5nZXRSdWxlKHJ1bGVJZCk7XG4gICAgICAgICAgbGV0IHNraXBSdWxlID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBJbmNsdWRlT25seVJ1bGUgfHwgcnVsZSBpbnN0YW5jZW9mIEJlZ2luRW5kUnVsZSB8fCBydWxlIGluc3RhbmNlb2YgQmVnaW5XaGlsZVJ1bGUpIHtcbiAgICAgICAgICAgIGlmIChydWxlLmhhc01pc3NpbmdQYXR0ZXJucyAmJiBydWxlLnBhdHRlcm5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBza2lwUnVsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChza2lwUnVsZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHIucHVzaChydWxlSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwYXR0ZXJuczogcixcbiAgICAgIGhhc01pc3NpbmdQYXR0ZXJuczogKHBhdHRlcm5zID8gcGF0dGVybnMubGVuZ3RoIDogMCkgIT09IHIubGVuZ3RoXG4gICAgfTtcbiAgfVxufTtcbnZhciBSZWdFeHBTb3VyY2UgPSBjbGFzcyBfUmVnRXhwU291cmNlIHtcbiAgc291cmNlO1xuICBydWxlSWQ7XG4gIGhhc0FuY2hvcjtcbiAgaGFzQmFja1JlZmVyZW5jZXM7XG4gIF9hbmNob3JDYWNoZTtcbiAgY29uc3RydWN0b3IocmVnRXhwU291cmNlLCBydWxlSWQpIHtcbiAgICBpZiAocmVnRXhwU291cmNlICYmIHR5cGVvZiByZWdFeHBTb3VyY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGxlbiA9IHJlZ0V4cFNvdXJjZS5sZW5ndGg7XG4gICAgICBsZXQgbGFzdFB1c2hlZFBvcyA9IDA7XG4gICAgICBsZXQgb3V0cHV0ID0gW107XG4gICAgICBsZXQgaGFzQW5jaG9yID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47IHBvcysrKSB7XG4gICAgICAgIGNvbnN0IGNoID0gcmVnRXhwU291cmNlLmNoYXJBdChwb3MpO1xuICAgICAgICBpZiAoY2ggPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgaWYgKHBvcyArIDEgPCBsZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaCA9IHJlZ0V4cFNvdXJjZS5jaGFyQXQocG9zICsgMSk7XG4gICAgICAgICAgICBpZiAobmV4dENoID09PSBcInpcIikge1xuICAgICAgICAgICAgICBvdXRwdXQucHVzaChyZWdFeHBTb3VyY2Uuc3Vic3RyaW5nKGxhc3RQdXNoZWRQb3MsIHBvcykpO1xuICAgICAgICAgICAgICBvdXRwdXQucHVzaChcIiQoPyFcXFxcbikoPzwhXFxcXG4pXCIpO1xuICAgICAgICAgICAgICBsYXN0UHVzaGVkUG9zID0gcG9zICsgMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoID09PSBcIkFcIiB8fCBuZXh0Q2ggPT09IFwiR1wiKSB7XG4gICAgICAgICAgICAgIGhhc0FuY2hvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuaGFzQW5jaG9yID0gaGFzQW5jaG9yO1xuICAgICAgaWYgKGxhc3RQdXNoZWRQb3MgPT09IDApIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSByZWdFeHBTb3VyY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaChyZWdFeHBTb3VyY2Uuc3Vic3RyaW5nKGxhc3RQdXNoZWRQb3MsIGxlbikpO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IG91dHB1dC5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhc0FuY2hvciA9IGZhbHNlO1xuICAgICAgdGhpcy5zb3VyY2UgPSByZWdFeHBTb3VyY2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc0FuY2hvcikge1xuICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUgPSB0aGlzLl9idWlsZEFuY2hvckNhY2hlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FuY2hvckNhY2hlID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5ydWxlSWQgPSBydWxlSWQ7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5oYXNCYWNrUmVmZXJlbmNlcyA9IEhBU19CQUNLX1JFRkVSRU5DRVMudGVzdCh0aGlzLnNvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFzQmFja1JlZmVyZW5jZXMgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfUmVnRXhwU291cmNlKHRoaXMuc291cmNlLCB0aGlzLnJ1bGVJZCk7XG4gIH1cbiAgc2V0U291cmNlKG5ld1NvdXJjZSkge1xuICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gbmV3U291cmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc291cmNlID0gbmV3U291cmNlO1xuICAgIGlmICh0aGlzLmhhc0FuY2hvcikge1xuICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUgPSB0aGlzLl9idWlsZEFuY2hvckNhY2hlKCk7XG4gICAgfVxuICB9XG4gIHJlc29sdmVCYWNrUmVmZXJlbmNlcyhsaW5lVGV4dCwgY2FwdHVyZUluZGljZXMpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuc291cmNlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgaWYgdGhlIHNvdXJjZSBpcyBhIHN0cmluZ1wiKTtcbiAgICB9XG4gICAgbGV0IGNhcHR1cmVkVmFsdWVzID0gY2FwdHVyZUluZGljZXMubWFwKChjYXB0dXJlKSA9PiB7XG4gICAgICByZXR1cm4gbGluZVRleHQuc3Vic3RyaW5nKGNhcHR1cmUuc3RhcnQsIGNhcHR1cmUuZW5kKTtcbiAgICB9KTtcbiAgICBCQUNLX1JFRkVSRU5DSU5HX0VORC5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5yZXBsYWNlKEJBQ0tfUkVGRVJFTkNJTkdfRU5ELCAobWF0Y2gsIGcxKSA9PiB7XG4gICAgICByZXR1cm4gZXNjYXBlUmVnRXhwQ2hhcmFjdGVycyhjYXB0dXJlZFZhbHVlc1twYXJzZUludChnMSwgMTApXSB8fCBcIlwiKTtcbiAgICB9KTtcbiAgfVxuICBfYnVpbGRBbmNob3JDYWNoZSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuc291cmNlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgaWYgdGhlIHNvdXJjZSBpcyBhIHN0cmluZ1wiKTtcbiAgICB9XG4gICAgbGV0IEEwX0cwX3Jlc3VsdCA9IFtdO1xuICAgIGxldCBBMF9HMV9yZXN1bHQgPSBbXTtcbiAgICBsZXQgQTFfRzBfcmVzdWx0ID0gW107XG4gICAgbGV0IEExX0cxX3Jlc3VsdCA9IFtdO1xuICAgIGxldCBwb3MsIGxlbiwgY2gsIG5leHRDaDtcbiAgICBmb3IgKHBvcyA9IDAsIGxlbiA9IHRoaXMuc291cmNlLmxlbmd0aDsgcG9zIDwgbGVuOyBwb3MrKykge1xuICAgICAgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQXQocG9zKTtcbiAgICAgIEEwX0cwX3Jlc3VsdFtwb3NdID0gY2g7XG4gICAgICBBMF9HMV9yZXN1bHRbcG9zXSA9IGNoO1xuICAgICAgQTFfRzBfcmVzdWx0W3Bvc10gPSBjaDtcbiAgICAgIEExX0cxX3Jlc3VsdFtwb3NdID0gY2g7XG4gICAgICBpZiAoY2ggPT09IFwiXFxcXFwiKSB7XG4gICAgICAgIGlmIChwb3MgKyAxIDwgbGVuKSB7XG4gICAgICAgICAgbmV4dENoID0gdGhpcy5zb3VyY2UuY2hhckF0KHBvcyArIDEpO1xuICAgICAgICAgIGlmIChuZXh0Q2ggPT09IFwiQVwiKSB7XG4gICAgICAgICAgICBBMF9HMF9yZXN1bHRbcG9zICsgMV0gPSBcIlxcdUZGRkZcIjtcbiAgICAgICAgICAgIEEwX0cxX3Jlc3VsdFtwb3MgKyAxXSA9IFwiXFx1RkZGRlwiO1xuICAgICAgICAgICAgQTFfRzBfcmVzdWx0W3BvcyArIDFdID0gXCJBXCI7XG4gICAgICAgICAgICBBMV9HMV9yZXN1bHRbcG9zICsgMV0gPSBcIkFcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaCA9PT0gXCJHXCIpIHtcbiAgICAgICAgICAgIEEwX0cwX3Jlc3VsdFtwb3MgKyAxXSA9IFwiXFx1RkZGRlwiO1xuICAgICAgICAgICAgQTBfRzFfcmVzdWx0W3BvcyArIDFdID0gXCJHXCI7XG4gICAgICAgICAgICBBMV9HMF9yZXN1bHRbcG9zICsgMV0gPSBcIlxcdUZGRkZcIjtcbiAgICAgICAgICAgIEExX0cxX3Jlc3VsdFtwb3MgKyAxXSA9IFwiR1wiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBMF9HMF9yZXN1bHRbcG9zICsgMV0gPSBuZXh0Q2g7XG4gICAgICAgICAgICBBMF9HMV9yZXN1bHRbcG9zICsgMV0gPSBuZXh0Q2g7XG4gICAgICAgICAgICBBMV9HMF9yZXN1bHRbcG9zICsgMV0gPSBuZXh0Q2g7XG4gICAgICAgICAgICBBMV9HMV9yZXN1bHRbcG9zICsgMV0gPSBuZXh0Q2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBBMF9HMDogQTBfRzBfcmVzdWx0LmpvaW4oXCJcIiksXG4gICAgICBBMF9HMTogQTBfRzFfcmVzdWx0LmpvaW4oXCJcIiksXG4gICAgICBBMV9HMDogQTFfRzBfcmVzdWx0LmpvaW4oXCJcIiksXG4gICAgICBBMV9HMTogQTFfRzFfcmVzdWx0LmpvaW4oXCJcIilcbiAgICB9O1xuICB9XG4gIHJlc29sdmVBbmNob3JzKGFsbG93QSwgYWxsb3dHKSB7XG4gICAgaWYgKCF0aGlzLmhhc0FuY2hvciB8fCAhdGhpcy5fYW5jaG9yQ2FjaGUgfHwgdHlwZW9mIHRoaXMuc291cmNlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2U7XG4gICAgfVxuICAgIGlmIChhbGxvd0EpIHtcbiAgICAgIGlmIChhbGxvd0cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FuY2hvckNhY2hlLkExX0cxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FuY2hvckNhY2hlLkExX0cwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYWxsb3dHKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JDYWNoZS5BMF9HMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JDYWNoZS5BMF9HMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgUmVnRXhwU291cmNlTGlzdCA9IGNsYXNzIHtcbiAgX2l0ZW1zO1xuICBfaGFzQW5jaG9ycztcbiAgX2NhY2hlZDtcbiAgX2FuY2hvckNhY2hlO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgIHRoaXMuX2hhc0FuY2hvcnMgPSBmYWxzZTtcbiAgICB0aGlzLl9jYWNoZWQgPSBudWxsO1xuICAgIHRoaXMuX2FuY2hvckNhY2hlID0ge1xuICAgICAgQTBfRzA6IG51bGwsXG4gICAgICBBMF9HMTogbnVsbCxcbiAgICAgIEExX0cwOiBudWxsLFxuICAgICAgQTFfRzE6IG51bGxcbiAgICB9O1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fZGlzcG9zZUNhY2hlcygpO1xuICB9XG4gIF9kaXNwb3NlQ2FjaGVzKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWQpIHtcbiAgICAgIHRoaXMuX2NhY2hlZC5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9jYWNoZWQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzApIHtcbiAgICAgIHRoaXMuX2FuY2hvckNhY2hlLkEwX0cwLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2FuY2hvckNhY2hlLkEwX0cwID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2FuY2hvckNhY2hlLkEwX0cxKSB7XG4gICAgICB0aGlzLl9hbmNob3JDYWNoZS5BMF9HMS5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9hbmNob3JDYWNoZS5BMF9HMSA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLl9hbmNob3JDYWNoZS5BMV9HMCkge1xuICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzAuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzAgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzEpIHtcbiAgICAgIHRoaXMuX2FuY2hvckNhY2hlLkExX0cxLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2FuY2hvckNhY2hlLkExX0cxID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcHVzaChpdGVtKSB7XG4gICAgdGhpcy5faXRlbXMucHVzaChpdGVtKTtcbiAgICB0aGlzLl9oYXNBbmNob3JzID0gdGhpcy5faGFzQW5jaG9ycyB8fCBpdGVtLmhhc0FuY2hvcjtcbiAgfVxuICB1bnNoaWZ0KGl0ZW0pIHtcbiAgICB0aGlzLl9pdGVtcy51bnNoaWZ0KGl0ZW0pO1xuICAgIHRoaXMuX2hhc0FuY2hvcnMgPSB0aGlzLl9oYXNBbmNob3JzIHx8IGl0ZW0uaGFzQW5jaG9yO1xuICB9XG4gIGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xuICB9XG4gIHNldFNvdXJjZShpbmRleCwgbmV3U291cmNlKSB7XG4gICAgaWYgKHRoaXMuX2l0ZW1zW2luZGV4XS5zb3VyY2UgIT09IG5ld1NvdXJjZSkge1xuICAgICAgdGhpcy5fZGlzcG9zZUNhY2hlcygpO1xuICAgICAgdGhpcy5faXRlbXNbaW5kZXhdLnNldFNvdXJjZShuZXdTb3VyY2UpO1xuICAgIH1cbiAgfVxuICBjb21waWxlKG9uaWdMaWIpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZCkge1xuICAgICAgbGV0IHJlZ0V4cHMgPSB0aGlzLl9pdGVtcy5tYXAoKGUpID0+IGUuc291cmNlKTtcbiAgICAgIHRoaXMuX2NhY2hlZCA9IG5ldyBDb21waWxlZFJ1bGUob25pZ0xpYiwgcmVnRXhwcywgdGhpcy5faXRlbXMubWFwKChlKSA9PiBlLnJ1bGVJZCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICB9XG4gIGNvbXBpbGVBRyhvbmlnTGliLCBhbGxvd0EsIGFsbG93Rykge1xuICAgIGlmICghdGhpcy5faGFzQW5jaG9ycykge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZShvbmlnTGliKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFsbG93QSkge1xuICAgICAgICBpZiAoYWxsb3dHKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9hbmNob3JDYWNoZS5BMV9HMSkge1xuICAgICAgICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzEgPSB0aGlzLl9yZXNvbHZlQW5jaG9ycyhvbmlnTGliLCBhbGxvd0EsIGFsbG93Ryk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JDYWNoZS5BMV9HMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2FuY2hvckNhY2hlLkExX0cwKSB7XG4gICAgICAgICAgICB0aGlzLl9hbmNob3JDYWNoZS5BMV9HMCA9IHRoaXMuX3Jlc29sdmVBbmNob3JzKG9uaWdMaWIsIGFsbG93QSwgYWxsb3dHKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FuY2hvckNhY2hlLkExX0cwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYWxsb3dHKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9hbmNob3JDYWNoZS5BMF9HMSkge1xuICAgICAgICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzEgPSB0aGlzLl9yZXNvbHZlQW5jaG9ycyhvbmlnTGliLCBhbGxvd0EsIGFsbG93Ryk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JDYWNoZS5BMF9HMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2FuY2hvckNhY2hlLkEwX0cwKSB7XG4gICAgICAgICAgICB0aGlzLl9hbmNob3JDYWNoZS5BMF9HMCA9IHRoaXMuX3Jlc29sdmVBbmNob3JzKG9uaWdMaWIsIGFsbG93QSwgYWxsb3dHKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FuY2hvckNhY2hlLkEwX0cwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9yZXNvbHZlQW5jaG9ycyhvbmlnTGliLCBhbGxvd0EsIGFsbG93Rykge1xuICAgIGxldCByZWdFeHBzID0gdGhpcy5faXRlbXMubWFwKChlKSA9PiBlLnJlc29sdmVBbmNob3JzKGFsbG93QSwgYWxsb3dHKSk7XG4gICAgcmV0dXJuIG5ldyBDb21waWxlZFJ1bGUob25pZ0xpYiwgcmVnRXhwcywgdGhpcy5faXRlbXMubWFwKChlKSA9PiBlLnJ1bGVJZCkpO1xuICB9XG59O1xudmFyIENvbXBpbGVkUnVsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob25pZ0xpYiwgcmVnRXhwcywgcnVsZXMpIHtcbiAgICB0aGlzLnJlZ0V4cHMgPSByZWdFeHBzO1xuICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICB0aGlzLnNjYW5uZXIgPSBvbmlnTGliLmNyZWF0ZU9uaWdTY2FubmVyKHJlZ0V4cHMpO1xuICB9XG4gIHNjYW5uZXI7XG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNjYW5uZXIuZGlzcG9zZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLnNjYW5uZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCByID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMucnVsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHIucHVzaChcIiAgIC0gXCIgKyB0aGlzLnJ1bGVzW2ldICsgXCI6IFwiICsgdGhpcy5yZWdFeHBzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHIuam9pbihcIlxcblwiKTtcbiAgfVxuICBmaW5kTmV4dE1hdGNoU3luYyhzdHJpbmcsIHN0YXJ0UG9zaXRpb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNjYW5uZXIuZmluZE5leHRNYXRjaFN5bmMoc3RyaW5nLCBzdGFydFBvc2l0aW9uLCBvcHRpb25zKTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBydWxlSWQ6IHRoaXMucnVsZXNbcmVzdWx0LmluZGV4XSxcbiAgICAgIGNhcHR1cmVJbmRpY2VzOiByZXN1bHQuY2FwdHVyZUluZGljZXNcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvZ3JhbW1hci9iYXNpY1Njb3Blc0F0dHJpYnV0ZVByb3ZpZGVyLnRzXG52YXIgQmFzaWNTY29wZUF0dHJpYnV0ZXMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGxhbmd1YWdlSWQsIHRva2VuVHlwZSkge1xuICAgIHRoaXMubGFuZ3VhZ2VJZCA9IGxhbmd1YWdlSWQ7XG4gICAgdGhpcy50b2tlblR5cGUgPSB0b2tlblR5cGU7XG4gIH1cbn07XG52YXIgQmFzaWNTY29wZUF0dHJpYnV0ZXNQcm92aWRlciA9IGNsYXNzIF9CYXNpY1Njb3BlQXR0cmlidXRlc1Byb3ZpZGVyIHtcbiAgX2RlZmF1bHRBdHRyaWJ1dGVzO1xuICBfZW1iZWRkZWRMYW5ndWFnZXNNYXRjaGVyO1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsTGFuZ3VhZ2VJZCwgZW1iZWRkZWRMYW5ndWFnZXMpIHtcbiAgICB0aGlzLl9kZWZhdWx0QXR0cmlidXRlcyA9IG5ldyBCYXNpY1Njb3BlQXR0cmlidXRlcyhpbml0aWFsTGFuZ3VhZ2VJZCwgOCAvKiBOb3RTZXQgKi8pO1xuICAgIHRoaXMuX2VtYmVkZGVkTGFuZ3VhZ2VzTWF0Y2hlciA9IG5ldyBTY29wZU1hdGNoZXIoT2JqZWN0LmVudHJpZXMoZW1iZWRkZWRMYW5ndWFnZXMgfHwge30pKTtcbiAgfVxuICBnZXREZWZhdWx0QXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmYXVsdEF0dHJpYnV0ZXM7XG4gIH1cbiAgZ2V0QmFzaWNTY29wZUF0dHJpYnV0ZXMoc2NvcGVOYW1lKSB7XG4gICAgaWYgKHNjb3BlTmFtZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIF9CYXNpY1Njb3BlQXR0cmlidXRlc1Byb3ZpZGVyLl9OVUxMX1NDT1BFX01FVEFEQVRBO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZ2V0QmFzaWNTY29wZUF0dHJpYnV0ZXMuZ2V0KHNjb3BlTmFtZSk7XG4gIH1cbiAgc3RhdGljIF9OVUxMX1NDT1BFX01FVEFEQVRBID0gbmV3IEJhc2ljU2NvcGVBdHRyaWJ1dGVzKDAsIDApO1xuICBfZ2V0QmFzaWNTY29wZUF0dHJpYnV0ZXMgPSBuZXcgQ2FjaGVkRm4oKHNjb3BlTmFtZSkgPT4ge1xuICAgIGNvbnN0IGxhbmd1YWdlSWQgPSB0aGlzLl9zY29wZVRvTGFuZ3VhZ2Uoc2NvcGVOYW1lKTtcbiAgICBjb25zdCBzdGFuZGFyZFRva2VuVHlwZSA9IHRoaXMuX3RvU3RhbmRhcmRUb2tlblR5cGUoc2NvcGVOYW1lKTtcbiAgICByZXR1cm4gbmV3IEJhc2ljU2NvcGVBdHRyaWJ1dGVzKGxhbmd1YWdlSWQsIHN0YW5kYXJkVG9rZW5UeXBlKTtcbiAgfSk7XG4gIC8qKlxuICAgKiBHaXZlbiBhIHByb2R1Y2VkIFRNIHNjb3BlLCByZXR1cm4gdGhlIGxhbmd1YWdlIHRoYXQgdG9rZW4gZGVzY3JpYmVzIG9yIG51bGwgaWYgdW5rbm93bi5cbiAgICogZS5nLiBzb3VyY2UuaHRtbCA9PiBodG1sLCBzb3VyY2UuY3NzLmVtYmVkZGVkLmh0bWwgPT4gY3NzLCBwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnRhZy5odG1sID0+IG51bGxcbiAgICovXG4gIF9zY29wZVRvTGFuZ3VhZ2Uoc2NvcGUpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1iZWRkZWRMYW5ndWFnZXNNYXRjaGVyLm1hdGNoKHNjb3BlKSB8fCAwO1xuICB9XG4gIF90b1N0YW5kYXJkVG9rZW5UeXBlKHNjb3BlTmFtZSkge1xuICAgIGNvbnN0IG0gPSBzY29wZU5hbWUubWF0Y2goX0Jhc2ljU2NvcGVBdHRyaWJ1dGVzUHJvdmlkZXIuU1RBTkRBUkRfVE9LRU5fVFlQRV9SRUdFWFApO1xuICAgIGlmICghbSkge1xuICAgICAgcmV0dXJuIDggLyogTm90U2V0ICovO1xuICAgIH1cbiAgICBzd2l0Y2ggKG1bMV0pIHtcbiAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgIHJldHVybiAxIC8qIENvbW1lbnQgKi87XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIHJldHVybiAyIC8qIFN0cmluZyAqLztcbiAgICAgIGNhc2UgXCJyZWdleFwiOlxuICAgICAgICByZXR1cm4gMyAvKiBSZWdFeCAqLztcbiAgICAgIGNhc2UgXCJtZXRhLmVtYmVkZGVkXCI6XG4gICAgICAgIHJldHVybiAwIC8qIE90aGVyICovO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1hdGNoIGZvciBzdGFuZGFyZCB0b2tlbiB0eXBlIVwiKTtcbiAgfVxuICBzdGF0aWMgU1RBTkRBUkRfVE9LRU5fVFlQRV9SRUdFWFAgPSAvXFxiKGNvbW1lbnR8c3RyaW5nfHJlZ2V4fG1ldGFcXC5lbWJlZGRlZClcXGIvO1xufTtcbnZhciBTY29wZU1hdGNoZXIgPSBjbGFzcyB7XG4gIHZhbHVlcztcbiAgc2NvcGVzUmVnRXhwO1xuICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy52YWx1ZXMgPSBudWxsO1xuICAgICAgdGhpcy5zY29wZXNSZWdFeHAgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbHVlcyA9IG5ldyBNYXAodmFsdWVzKTtcbiAgICAgIGNvbnN0IGVzY2FwZWRTY29wZXMgPSB2YWx1ZXMubWFwKFxuICAgICAgICAoW3Njb3BlTmFtZSwgdmFsdWVdKSA9PiBlc2NhcGVSZWdFeHBDaGFyYWN0ZXJzKHNjb3BlTmFtZSlcbiAgICAgICk7XG4gICAgICBlc2NhcGVkU2NvcGVzLnNvcnQoKTtcbiAgICAgIGVzY2FwZWRTY29wZXMucmV2ZXJzZSgpO1xuICAgICAgdGhpcy5zY29wZXNSZWdFeHAgPSBuZXcgUmVnRXhwKFxuICAgICAgICBgXigoJHtlc2NhcGVkU2NvcGVzLmpvaW4oXCIpfChcIil9KSkoJHxcXFxcLilgLFxuICAgICAgICBcIlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBtYXRjaChzY29wZSkge1xuICAgIGlmICghdGhpcy5zY29wZXNSZWdFeHApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IG0gPSBzY29wZS5tYXRjaCh0aGlzLnNjb3Blc1JlZ0V4cCk7XG4gICAgaWYgKCFtKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52YWx1ZXMuZ2V0KG1bMV0pO1xuICB9XG59O1xuXG4vLyBzcmMvZGVidWcudHNcbnZhciBEZWJ1Z0ZsYWdzID0ge1xuICBJbkRlYnVnTW9kZTogdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgISFwcm9jZXNzLmVudltcIlZTQ09ERV9URVhUTUFURV9ERUJVR1wiXVxufTtcbnZhciBVc2VPbmlndXJ1bWFGaW5kT3B0aW9ucyA9IGZhbHNlO1xuXG4vLyBzcmMvZ3JhbW1hci90b2tlbml6ZVN0cmluZy50c1xudmFyIFRva2VuaXplU3RyaW5nUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzdGFjaywgc3RvcHBlZEVhcmx5KSB7XG4gICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgIHRoaXMuc3RvcHBlZEVhcmx5ID0gc3RvcHBlZEVhcmx5O1xuICB9XG59O1xuZnVuY3Rpb24gX3Rva2VuaXplU3RyaW5nKGdyYW1tYXIsIGxpbmVUZXh0LCBpc0ZpcnN0TGluZSwgbGluZVBvcywgc3RhY2ssIGxpbmVUb2tlbnMsIGNoZWNrV2hpbGVDb25kaXRpb25zLCB0aW1lTGltaXQpIHtcbiAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVUZXh0LmNvbnRlbnQubGVuZ3RoO1xuICBsZXQgU1RPUCA9IGZhbHNlO1xuICBsZXQgYW5jaG9yUG9zaXRpb24gPSAtMTtcbiAgaWYgKGNoZWNrV2hpbGVDb25kaXRpb25zKSB7XG4gICAgY29uc3Qgd2hpbGVDaGVja1Jlc3VsdCA9IF9jaGVja1doaWxlQ29uZGl0aW9ucyhcbiAgICAgIGdyYW1tYXIsXG4gICAgICBsaW5lVGV4dCxcbiAgICAgIGlzRmlyc3RMaW5lLFxuICAgICAgbGluZVBvcyxcbiAgICAgIHN0YWNrLFxuICAgICAgbGluZVRva2Vuc1xuICAgICk7XG4gICAgc3RhY2sgPSB3aGlsZUNoZWNrUmVzdWx0LnN0YWNrO1xuICAgIGxpbmVQb3MgPSB3aGlsZUNoZWNrUmVzdWx0LmxpbmVQb3M7XG4gICAgaXNGaXJzdExpbmUgPSB3aGlsZUNoZWNrUmVzdWx0LmlzRmlyc3RMaW5lO1xuICAgIGFuY2hvclBvc2l0aW9uID0gd2hpbGVDaGVja1Jlc3VsdC5hbmNob3JQb3NpdGlvbjtcbiAgfVxuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICB3aGlsZSAoIVNUT1ApIHtcbiAgICBpZiAodGltZUxpbWl0ICE9PSAwKSB7XG4gICAgICBjb25zdCBlbGFwc2VkVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBpZiAoZWxhcHNlZFRpbWUgPiB0aW1lTGltaXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb2tlbml6ZVN0cmluZ1Jlc3VsdChzdGFjaywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNjYW5OZXh0KCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBUb2tlbml6ZVN0cmluZ1Jlc3VsdChzdGFjaywgZmFsc2UpO1xuICBmdW5jdGlvbiBzY2FuTmV4dCgpIHtcbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGBAQHNjYW5OZXh0ICR7bGluZVBvc306IHwke2xpbmVUZXh0LmNvbnRlbnQuc3Vic3RyKGxpbmVQb3MpLnJlcGxhY2UoL1xcbiQvLCBcIlxcXFxuXCIpfXxgXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByID0gbWF0Y2hSdWxlT3JJbmplY3Rpb25zKFxuICAgICAgZ3JhbW1hcixcbiAgICAgIGxpbmVUZXh0LFxuICAgICAgaXNGaXJzdExpbmUsXG4gICAgICBsaW5lUG9zLFxuICAgICAgc3RhY2ssXG4gICAgICBhbmNob3JQb3NpdGlvblxuICAgICk7XG4gICAgaWYgKCFyKSB7XG4gICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uoc3RhY2ssIGxpbmVMZW5ndGgpO1xuICAgICAgU1RPUCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNhcHR1cmVJbmRpY2VzID0gci5jYXB0dXJlSW5kaWNlcztcbiAgICBjb25zdCBtYXRjaGVkUnVsZUlkID0gci5tYXRjaGVkUnVsZUlkO1xuICAgIGNvbnN0IGhhc0FkdmFuY2VkID0gY2FwdHVyZUluZGljZXMgJiYgY2FwdHVyZUluZGljZXMubGVuZ3RoID4gMCA/IGNhcHR1cmVJbmRpY2VzWzBdLmVuZCA+IGxpbmVQb3MgOiBmYWxzZTtcbiAgICBpZiAobWF0Y2hlZFJ1bGVJZCA9PT0gZW5kUnVsZUlkKSB7XG4gICAgICBjb25zdCBwb3BwZWRSdWxlID0gc3RhY2suZ2V0UnVsZShncmFtbWFyKTtcbiAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcIiAgcG9wcGluZyBcIiArIHBvcHBlZFJ1bGUuZGVidWdOYW1lICsgXCIgLSBcIiArIHBvcHBlZFJ1bGUuZGVidWdFbmRSZWdFeHBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGxpbmVUb2tlbnMucHJvZHVjZShzdGFjaywgY2FwdHVyZUluZGljZXNbMF0uc3RhcnQpO1xuICAgICAgc3RhY2sgPSBzdGFjay53aXRoQ29udGVudE5hbWVTY29wZXNMaXN0KHN0YWNrLm5hbWVTY29wZXNMaXN0KTtcbiAgICAgIGhhbmRsZUNhcHR1cmVzKFxuICAgICAgICBncmFtbWFyLFxuICAgICAgICBsaW5lVGV4dCxcbiAgICAgICAgaXNGaXJzdExpbmUsXG4gICAgICAgIHN0YWNrLFxuICAgICAgICBsaW5lVG9rZW5zLFxuICAgICAgICBwb3BwZWRSdWxlLmVuZENhcHR1cmVzLFxuICAgICAgICBjYXB0dXJlSW5kaWNlc1xuICAgICAgKTtcbiAgICAgIGxpbmVUb2tlbnMucHJvZHVjZShzdGFjaywgY2FwdHVyZUluZGljZXNbMF0uZW5kKTtcbiAgICAgIGNvbnN0IHBvcHBlZCA9IHN0YWNrO1xuICAgICAgc3RhY2sgPSBzdGFjay5wYXJlbnQ7XG4gICAgICBhbmNob3JQb3NpdGlvbiA9IHBvcHBlZC5nZXRBbmNob3JQb3MoKTtcbiAgICAgIGlmICghaGFzQWR2YW5jZWQgJiYgcG9wcGVkLmdldEVudGVyUG9zKCkgPT09IGxpbmVQb3MpIHtcbiAgICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiWzFdIC0gR3JhbW1hciBpcyBpbiBhbiBlbmRsZXNzIGxvb3AgLSBHcmFtbWFyIHB1c2hlZCAmIHBvcHBlZCBhIHJ1bGUgd2l0aG91dCBhZHZhbmNpbmdcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sgPSBwb3BwZWQ7XG4gICAgICAgIGxpbmVUb2tlbnMucHJvZHVjZShzdGFjaywgbGluZUxlbmd0aCk7XG4gICAgICAgIFNUT1AgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IF9ydWxlID0gZ3JhbW1hci5nZXRSdWxlKG1hdGNoZWRSdWxlSWQpO1xuICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHN0YWNrLCBjYXB0dXJlSW5kaWNlc1swXS5zdGFydCk7XG4gICAgICBjb25zdCBiZWZvcmVQdXNoID0gc3RhY2s7XG4gICAgICBjb25zdCBzY29wZU5hbWUgPSBfcnVsZS5nZXROYW1lKGxpbmVUZXh0LmNvbnRlbnQsIGNhcHR1cmVJbmRpY2VzKTtcbiAgICAgIGNvbnN0IG5hbWVTY29wZXNMaXN0ID0gc3RhY2suY29udGVudE5hbWVTY29wZXNMaXN0LnB1c2hBdHRyaWJ1dGVkKFxuICAgICAgICBzY29wZU5hbWUsXG4gICAgICAgIGdyYW1tYXJcbiAgICAgICk7XG4gICAgICBzdGFjayA9IHN0YWNrLnB1c2goXG4gICAgICAgIG1hdGNoZWRSdWxlSWQsXG4gICAgICAgIGxpbmVQb3MsXG4gICAgICAgIGFuY2hvclBvc2l0aW9uLFxuICAgICAgICBjYXB0dXJlSW5kaWNlc1swXS5lbmQgPT09IGxpbmVMZW5ndGgsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG5hbWVTY29wZXNMaXN0LFxuICAgICAgICBuYW1lU2NvcGVzTGlzdFxuICAgICAgKTtcbiAgICAgIGlmIChfcnVsZSBpbnN0YW5jZW9mIEJlZ2luRW5kUnVsZSkge1xuICAgICAgICBjb25zdCBwdXNoZWRSdWxlID0gX3J1bGU7XG4gICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgXCIgIHB1c2hpbmcgXCIgKyBwdXNoZWRSdWxlLmRlYnVnTmFtZSArIFwiIC0gXCIgKyBwdXNoZWRSdWxlLmRlYnVnQmVnaW5SZWdFeHBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZUNhcHR1cmVzKFxuICAgICAgICAgIGdyYW1tYXIsXG4gICAgICAgICAgbGluZVRleHQsXG4gICAgICAgICAgaXNGaXJzdExpbmUsXG4gICAgICAgICAgc3RhY2ssXG4gICAgICAgICAgbGluZVRva2VucyxcbiAgICAgICAgICBwdXNoZWRSdWxlLmJlZ2luQ2FwdHVyZXMsXG4gICAgICAgICAgY2FwdHVyZUluZGljZXNcbiAgICAgICAgKTtcbiAgICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHN0YWNrLCBjYXB0dXJlSW5kaWNlc1swXS5lbmQpO1xuICAgICAgICBhbmNob3JQb3NpdGlvbiA9IGNhcHR1cmVJbmRpY2VzWzBdLmVuZDtcbiAgICAgICAgY29uc3QgY29udGVudE5hbWUgPSBwdXNoZWRSdWxlLmdldENvbnRlbnROYW1lKFxuICAgICAgICAgIGxpbmVUZXh0LmNvbnRlbnQsXG4gICAgICAgICAgY2FwdHVyZUluZGljZXNcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY29udGVudE5hbWVTY29wZXNMaXN0ID0gbmFtZVNjb3Blc0xpc3QucHVzaEF0dHJpYnV0ZWQoXG4gICAgICAgICAgY29udGVudE5hbWUsXG4gICAgICAgICAgZ3JhbW1hclxuICAgICAgICApO1xuICAgICAgICBzdGFjayA9IHN0YWNrLndpdGhDb250ZW50TmFtZVNjb3Blc0xpc3QoY29udGVudE5hbWVTY29wZXNMaXN0KTtcbiAgICAgICAgaWYgKHB1c2hlZFJ1bGUuZW5kSGFzQmFja1JlZmVyZW5jZXMpIHtcbiAgICAgICAgICBzdGFjayA9IHN0YWNrLndpdGhFbmRSdWxlKFxuICAgICAgICAgICAgcHVzaGVkUnVsZS5nZXRFbmRXaXRoUmVzb2x2ZWRCYWNrUmVmZXJlbmNlcyhcbiAgICAgICAgICAgICAgbGluZVRleHQuY29udGVudCxcbiAgICAgICAgICAgICAgY2FwdHVyZUluZGljZXNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzQWR2YW5jZWQgJiYgYmVmb3JlUHVzaC5oYXNTYW1lUnVsZUFzKHN0YWNrKSkge1xuICAgICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJbMl0gLSBHcmFtbWFyIGlzIGluIGFuIGVuZGxlc3MgbG9vcCAtIEdyYW1tYXIgcHVzaGVkIHRoZSBzYW1lIHJ1bGUgd2l0aG91dCBhZHZhbmNpbmdcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhY2sgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uoc3RhY2ssIGxpbmVMZW5ndGgpO1xuICAgICAgICAgIFNUT1AgPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfcnVsZSBpbnN0YW5jZW9mIEJlZ2luV2hpbGVSdWxlKSB7XG4gICAgICAgIGNvbnN0IHB1c2hlZFJ1bGUgPSBfcnVsZTtcbiAgICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCIgIHB1c2hpbmcgXCIgKyBwdXNoZWRSdWxlLmRlYnVnTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlQ2FwdHVyZXMoXG4gICAgICAgICAgZ3JhbW1hcixcbiAgICAgICAgICBsaW5lVGV4dCxcbiAgICAgICAgICBpc0ZpcnN0TGluZSxcbiAgICAgICAgICBzdGFjayxcbiAgICAgICAgICBsaW5lVG9rZW5zLFxuICAgICAgICAgIHB1c2hlZFJ1bGUuYmVnaW5DYXB0dXJlcyxcbiAgICAgICAgICBjYXB0dXJlSW5kaWNlc1xuICAgICAgICApO1xuICAgICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uoc3RhY2ssIGNhcHR1cmVJbmRpY2VzWzBdLmVuZCk7XG4gICAgICAgIGFuY2hvclBvc2l0aW9uID0gY2FwdHVyZUluZGljZXNbMF0uZW5kO1xuICAgICAgICBjb25zdCBjb250ZW50TmFtZSA9IHB1c2hlZFJ1bGUuZ2V0Q29udGVudE5hbWUoXG4gICAgICAgICAgbGluZVRleHQuY29udGVudCxcbiAgICAgICAgICBjYXB0dXJlSW5kaWNlc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBjb250ZW50TmFtZVNjb3Blc0xpc3QgPSBuYW1lU2NvcGVzTGlzdC5wdXNoQXR0cmlidXRlZChcbiAgICAgICAgICBjb250ZW50TmFtZSxcbiAgICAgICAgICBncmFtbWFyXG4gICAgICAgICk7XG4gICAgICAgIHN0YWNrID0gc3RhY2sud2l0aENvbnRlbnROYW1lU2NvcGVzTGlzdChjb250ZW50TmFtZVNjb3Blc0xpc3QpO1xuICAgICAgICBpZiAocHVzaGVkUnVsZS53aGlsZUhhc0JhY2tSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgc3RhY2sgPSBzdGFjay53aXRoRW5kUnVsZShcbiAgICAgICAgICAgIHB1c2hlZFJ1bGUuZ2V0V2hpbGVXaXRoUmVzb2x2ZWRCYWNrUmVmZXJlbmNlcyhcbiAgICAgICAgICAgICAgbGluZVRleHQuY29udGVudCxcbiAgICAgICAgICAgICAgY2FwdHVyZUluZGljZXNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzQWR2YW5jZWQgJiYgYmVmb3JlUHVzaC5oYXNTYW1lUnVsZUFzKHN0YWNrKSkge1xuICAgICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJbM10gLSBHcmFtbWFyIGlzIGluIGFuIGVuZGxlc3MgbG9vcCAtIEdyYW1tYXIgcHVzaGVkIHRoZSBzYW1lIHJ1bGUgd2l0aG91dCBhZHZhbmNpbmdcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhY2sgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uoc3RhY2ssIGxpbmVMZW5ndGgpO1xuICAgICAgICAgIFNUT1AgPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdSdWxlID0gX3J1bGU7XG4gICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgXCIgIG1hdGNoZWQgXCIgKyBtYXRjaGluZ1J1bGUuZGVidWdOYW1lICsgXCIgLSBcIiArIG1hdGNoaW5nUnVsZS5kZWJ1Z01hdGNoUmVnRXhwXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVDYXB0dXJlcyhcbiAgICAgICAgICBncmFtbWFyLFxuICAgICAgICAgIGxpbmVUZXh0LFxuICAgICAgICAgIGlzRmlyc3RMaW5lLFxuICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgIGxpbmVUb2tlbnMsXG4gICAgICAgICAgbWF0Y2hpbmdSdWxlLmNhcHR1cmVzLFxuICAgICAgICAgIGNhcHR1cmVJbmRpY2VzXG4gICAgICAgICk7XG4gICAgICAgIGxpbmVUb2tlbnMucHJvZHVjZShzdGFjaywgY2FwdHVyZUluZGljZXNbMF0uZW5kKTtcbiAgICAgICAgc3RhY2sgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKCFoYXNBZHZhbmNlZCkge1xuICAgICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJbNF0gLSBHcmFtbWFyIGlzIGluIGFuIGVuZGxlc3MgbG9vcCAtIEdyYW1tYXIgaXMgbm90IGFkdmFuY2luZywgbm9yIGlzIGl0IHB1c2hpbmcvcG9wcGluZ1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjayA9IHN0YWNrLnNhZmVQb3AoKTtcbiAgICAgICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uoc3RhY2ssIGxpbmVMZW5ndGgpO1xuICAgICAgICAgIFNUT1AgPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2FwdHVyZUluZGljZXNbMF0uZW5kID4gbGluZVBvcykge1xuICAgICAgbGluZVBvcyA9IGNhcHR1cmVJbmRpY2VzWzBdLmVuZDtcbiAgICAgIGlzRmlyc3RMaW5lID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfY2hlY2tXaGlsZUNvbmRpdGlvbnMoZ3JhbW1hciwgbGluZVRleHQsIGlzRmlyc3RMaW5lLCBsaW5lUG9zLCBzdGFjaywgbGluZVRva2Vucykge1xuICBsZXQgYW5jaG9yUG9zaXRpb24gPSBzdGFjay5iZWdpblJ1bGVDYXB0dXJlZEVPTCA/IDAgOiAtMTtcbiAgY29uc3Qgd2hpbGVSdWxlcyA9IFtdO1xuICBmb3IgKGxldCBub2RlID0gc3RhY2s7IG5vZGU7IG5vZGUgPSBub2RlLnBvcCgpKSB7XG4gICAgY29uc3Qgbm9kZVJ1bGUgPSBub2RlLmdldFJ1bGUoZ3JhbW1hcik7XG4gICAgaWYgKG5vZGVSdWxlIGluc3RhbmNlb2YgQmVnaW5XaGlsZVJ1bGUpIHtcbiAgICAgIHdoaWxlUnVsZXMucHVzaCh7XG4gICAgICAgIHJ1bGU6IG5vZGVSdWxlLFxuICAgICAgICBzdGFjazogbm9kZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IHdoaWxlUnVsZSA9IHdoaWxlUnVsZXMucG9wKCk7IHdoaWxlUnVsZTsgd2hpbGVSdWxlID0gd2hpbGVSdWxlcy5wb3AoKSkge1xuICAgIGNvbnN0IHsgcnVsZVNjYW5uZXIsIGZpbmRPcHRpb25zIH0gPSBwcmVwYXJlUnVsZVdoaWxlU2VhcmNoKHdoaWxlUnVsZS5ydWxlLCBncmFtbWFyLCB3aGlsZVJ1bGUuc3RhY2suZW5kUnVsZSwgaXNGaXJzdExpbmUsIGxpbmVQb3MgPT09IGFuY2hvclBvc2l0aW9uKTtcbiAgICBjb25zdCByID0gcnVsZVNjYW5uZXIuZmluZE5leHRNYXRjaFN5bmMobGluZVRleHQsIGxpbmVQb3MsIGZpbmRPcHRpb25zKTtcbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiICBzY2FubmluZyBmb3Igd2hpbGUgcnVsZVwiKTtcbiAgICAgIGNvbnNvbGUubG9nKHJ1bGVTY2FubmVyLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAocikge1xuICAgICAgY29uc3QgbWF0Y2hlZFJ1bGVJZCA9IHIucnVsZUlkO1xuICAgICAgaWYgKG1hdGNoZWRSdWxlSWQgIT09IHdoaWxlUnVsZUlkKSB7XG4gICAgICAgIHN0YWNrID0gd2hpbGVSdWxlLnN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChyLmNhcHR1cmVJbmRpY2VzICYmIHIuY2FwdHVyZUluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgIGxpbmVUb2tlbnMucHJvZHVjZSh3aGlsZVJ1bGUuc3RhY2ssIHIuY2FwdHVyZUluZGljZXNbMF0uc3RhcnQpO1xuICAgICAgICBoYW5kbGVDYXB0dXJlcyhncmFtbWFyLCBsaW5lVGV4dCwgaXNGaXJzdExpbmUsIHdoaWxlUnVsZS5zdGFjaywgbGluZVRva2Vucywgd2hpbGVSdWxlLnJ1bGUud2hpbGVDYXB0dXJlcywgci5jYXB0dXJlSW5kaWNlcyk7XG4gICAgICAgIGxpbmVUb2tlbnMucHJvZHVjZSh3aGlsZVJ1bGUuc3RhY2ssIHIuY2FwdHVyZUluZGljZXNbMF0uZW5kKTtcbiAgICAgICAgYW5jaG9yUG9zaXRpb24gPSByLmNhcHR1cmVJbmRpY2VzWzBdLmVuZDtcbiAgICAgICAgaWYgKHIuY2FwdHVyZUluZGljZXNbMF0uZW5kID4gbGluZVBvcykge1xuICAgICAgICAgIGxpbmVQb3MgPSByLmNhcHR1cmVJbmRpY2VzWzBdLmVuZDtcbiAgICAgICAgICBpc0ZpcnN0TGluZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIiAgcG9wcGluZyBcIiArIHdoaWxlUnVsZS5ydWxlLmRlYnVnTmFtZSArIFwiIC0gXCIgKyB3aGlsZVJ1bGUucnVsZS5kZWJ1Z1doaWxlUmVnRXhwKTtcbiAgICAgIH1cbiAgICAgIHN0YWNrID0gd2hpbGVSdWxlLnN0YWNrLnBvcCgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHN0YWNrLCBsaW5lUG9zLCBhbmNob3JQb3NpdGlvbiwgaXNGaXJzdExpbmUgfTtcbn1cbmZ1bmN0aW9uIG1hdGNoUnVsZU9ySW5qZWN0aW9ucyhncmFtbWFyLCBsaW5lVGV4dCwgaXNGaXJzdExpbmUsIGxpbmVQb3MsIHN0YWNrLCBhbmNob3JQb3NpdGlvbikge1xuICBjb25zdCBtYXRjaFJlc3VsdCA9IG1hdGNoUnVsZShncmFtbWFyLCBsaW5lVGV4dCwgaXNGaXJzdExpbmUsIGxpbmVQb3MsIHN0YWNrLCBhbmNob3JQb3NpdGlvbik7XG4gIGNvbnN0IGluamVjdGlvbnMgPSBncmFtbWFyLmdldEluamVjdGlvbnMoKTtcbiAgaWYgKGluamVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG1hdGNoUmVzdWx0O1xuICB9XG4gIGNvbnN0IGluamVjdGlvblJlc3VsdCA9IG1hdGNoSW5qZWN0aW9ucyhpbmplY3Rpb25zLCBncmFtbWFyLCBsaW5lVGV4dCwgaXNGaXJzdExpbmUsIGxpbmVQb3MsIHN0YWNrLCBhbmNob3JQb3NpdGlvbik7XG4gIGlmICghaW5qZWN0aW9uUmVzdWx0KSB7XG4gICAgcmV0dXJuIG1hdGNoUmVzdWx0O1xuICB9XG4gIGlmICghbWF0Y2hSZXN1bHQpIHtcbiAgICByZXR1cm4gaW5qZWN0aW9uUmVzdWx0O1xuICB9XG4gIGNvbnN0IG1hdGNoUmVzdWx0U2NvcmUgPSBtYXRjaFJlc3VsdC5jYXB0dXJlSW5kaWNlc1swXS5zdGFydDtcbiAgY29uc3QgaW5qZWN0aW9uUmVzdWx0U2NvcmUgPSBpbmplY3Rpb25SZXN1bHQuY2FwdHVyZUluZGljZXNbMF0uc3RhcnQ7XG4gIGlmIChpbmplY3Rpb25SZXN1bHRTY29yZSA8IG1hdGNoUmVzdWx0U2NvcmUgfHwgaW5qZWN0aW9uUmVzdWx0LnByaW9yaXR5TWF0Y2ggJiYgaW5qZWN0aW9uUmVzdWx0U2NvcmUgPT09IG1hdGNoUmVzdWx0U2NvcmUpIHtcbiAgICByZXR1cm4gaW5qZWN0aW9uUmVzdWx0O1xuICB9XG4gIHJldHVybiBtYXRjaFJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hdGNoUnVsZShncmFtbWFyLCBsaW5lVGV4dCwgaXNGaXJzdExpbmUsIGxpbmVQb3MsIHN0YWNrLCBhbmNob3JQb3NpdGlvbikge1xuICBjb25zdCBydWxlID0gc3RhY2suZ2V0UnVsZShncmFtbWFyKTtcbiAgY29uc3QgeyBydWxlU2Nhbm5lciwgZmluZE9wdGlvbnMgfSA9IHByZXBhcmVSdWxlU2VhcmNoKHJ1bGUsIGdyYW1tYXIsIHN0YWNrLmVuZFJ1bGUsIGlzRmlyc3RMaW5lLCBsaW5lUG9zID09PSBhbmNob3JQb3NpdGlvbik7XG4gIGNvbnN0IHIgPSBydWxlU2Nhbm5lci5maW5kTmV4dE1hdGNoU3luYyhsaW5lVGV4dCwgbGluZVBvcywgZmluZE9wdGlvbnMpO1xuICBpZiAocikge1xuICAgIHJldHVybiB7XG4gICAgICBjYXB0dXJlSW5kaWNlczogci5jYXB0dXJlSW5kaWNlcyxcbiAgICAgIG1hdGNoZWRSdWxlSWQ6IHIucnVsZUlkXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG1hdGNoSW5qZWN0aW9ucyhpbmplY3Rpb25zLCBncmFtbWFyLCBsaW5lVGV4dCwgaXNGaXJzdExpbmUsIGxpbmVQb3MsIHN0YWNrLCBhbmNob3JQb3NpdGlvbikge1xuICBsZXQgYmVzdE1hdGNoUmF0aW5nID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgbGV0IGJlc3RNYXRjaENhcHR1cmVJbmRpY2VzID0gbnVsbDtcbiAgbGV0IGJlc3RNYXRjaFJ1bGVJZDtcbiAgbGV0IGJlc3RNYXRjaFJlc3VsdFByaW9yaXR5ID0gMDtcbiAgY29uc3Qgc2NvcGVzID0gc3RhY2suY29udGVudE5hbWVTY29wZXNMaXN0LmdldFNjb3BlTmFtZXMoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGluamVjdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBpbmplY3Rpb24gPSBpbmplY3Rpb25zW2ldO1xuICAgIGlmICghaW5qZWN0aW9uLm1hdGNoZXIoc2NvcGVzKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHJ1bGUgPSBncmFtbWFyLmdldFJ1bGUoaW5qZWN0aW9uLnJ1bGVJZCk7XG4gICAgY29uc3QgeyBydWxlU2Nhbm5lciwgZmluZE9wdGlvbnMgfSA9IHByZXBhcmVSdWxlU2VhcmNoKHJ1bGUsIGdyYW1tYXIsIG51bGwsIGlzRmlyc3RMaW5lLCBsaW5lUG9zID09PSBhbmNob3JQb3NpdGlvbik7XG4gICAgY29uc3QgbWF0Y2hSZXN1bHQgPSBydWxlU2Nhbm5lci5maW5kTmV4dE1hdGNoU3luYyhsaW5lVGV4dCwgbGluZVBvcywgZmluZE9wdGlvbnMpO1xuICAgIGlmICghbWF0Y2hSZXN1bHQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKGAgIG1hdGNoZWQgaW5qZWN0aW9uOiAke2luamVjdGlvbi5kZWJ1Z1NlbGVjdG9yfWApO1xuICAgICAgY29uc29sZS5sb2cocnVsZVNjYW5uZXIudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoUmF0aW5nID0gbWF0Y2hSZXN1bHQuY2FwdHVyZUluZGljZXNbMF0uc3RhcnQ7XG4gICAgaWYgKG1hdGNoUmF0aW5nID49IGJlc3RNYXRjaFJhdGluZykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGJlc3RNYXRjaFJhdGluZyA9IG1hdGNoUmF0aW5nO1xuICAgIGJlc3RNYXRjaENhcHR1cmVJbmRpY2VzID0gbWF0Y2hSZXN1bHQuY2FwdHVyZUluZGljZXM7XG4gICAgYmVzdE1hdGNoUnVsZUlkID0gbWF0Y2hSZXN1bHQucnVsZUlkO1xuICAgIGJlc3RNYXRjaFJlc3VsdFByaW9yaXR5ID0gaW5qZWN0aW9uLnByaW9yaXR5O1xuICAgIGlmIChiZXN0TWF0Y2hSYXRpbmcgPT09IGxpbmVQb3MpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoYmVzdE1hdGNoQ2FwdHVyZUluZGljZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJpb3JpdHlNYXRjaDogYmVzdE1hdGNoUmVzdWx0UHJpb3JpdHkgPT09IC0xLFxuICAgICAgY2FwdHVyZUluZGljZXM6IGJlc3RNYXRjaENhcHR1cmVJbmRpY2VzLFxuICAgICAgbWF0Y2hlZFJ1bGVJZDogYmVzdE1hdGNoUnVsZUlkXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHByZXBhcmVSdWxlU2VhcmNoKHJ1bGUsIGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlLCBhbGxvd0EsIGFsbG93Rykge1xuICBpZiAoVXNlT25pZ3VydW1hRmluZE9wdGlvbnMpIHtcbiAgICBjb25zdCBydWxlU2Nhbm5lcjIgPSBydWxlLmNvbXBpbGUoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpO1xuICAgIGNvbnN0IGZpbmRPcHRpb25zID0gZ2V0RmluZE9wdGlvbnMoYWxsb3dBLCBhbGxvd0cpO1xuICAgIHJldHVybiB7IHJ1bGVTY2FubmVyOiBydWxlU2Nhbm5lcjIsIGZpbmRPcHRpb25zIH07XG4gIH1cbiAgY29uc3QgcnVsZVNjYW5uZXIgPSBydWxlLmNvbXBpbGVBRyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSwgYWxsb3dBLCBhbGxvd0cpO1xuICByZXR1cm4geyBydWxlU2Nhbm5lciwgZmluZE9wdGlvbnM6IDAgLyogTm9uZSAqLyB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZVJ1bGVXaGlsZVNlYXJjaChydWxlLCBncmFtbWFyLCBlbmRSZWdleFNvdXJjZSwgYWxsb3dBLCBhbGxvd0cpIHtcbiAgaWYgKFVzZU9uaWd1cnVtYUZpbmRPcHRpb25zKSB7XG4gICAgY29uc3QgcnVsZVNjYW5uZXIyID0gcnVsZS5jb21waWxlV2hpbGUoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpO1xuICAgIGNvbnN0IGZpbmRPcHRpb25zID0gZ2V0RmluZE9wdGlvbnMoYWxsb3dBLCBhbGxvd0cpO1xuICAgIHJldHVybiB7IHJ1bGVTY2FubmVyOiBydWxlU2Nhbm5lcjIsIGZpbmRPcHRpb25zIH07XG4gIH1cbiAgY29uc3QgcnVsZVNjYW5uZXIgPSBydWxlLmNvbXBpbGVXaGlsZUFHKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlLCBhbGxvd0EsIGFsbG93Ryk7XG4gIHJldHVybiB7IHJ1bGVTY2FubmVyLCBmaW5kT3B0aW9uczogMCAvKiBOb25lICovIH07XG59XG5mdW5jdGlvbiBnZXRGaW5kT3B0aW9ucyhhbGxvd0EsIGFsbG93Rykge1xuICBsZXQgb3B0aW9ucyA9IDAgLyogTm9uZSAqLztcbiAgaWYgKCFhbGxvd0EpIHtcbiAgICBvcHRpb25zIHw9IDEgLyogTm90QmVnaW5TdHJpbmcgKi87XG4gIH1cbiAgaWYgKCFhbGxvd0cpIHtcbiAgICBvcHRpb25zIHw9IDQgLyogTm90QmVnaW5Qb3NpdGlvbiAqLztcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGhhbmRsZUNhcHR1cmVzKGdyYW1tYXIsIGxpbmVUZXh0LCBpc0ZpcnN0TGluZSwgc3RhY2ssIGxpbmVUb2tlbnMsIGNhcHR1cmVzLCBjYXB0dXJlSW5kaWNlcykge1xuICBpZiAoY2FwdHVyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGxpbmVUZXh0Q29udGVudCA9IGxpbmVUZXh0LmNvbnRlbnQ7XG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKGNhcHR1cmVzLmxlbmd0aCwgY2FwdHVyZUluZGljZXMubGVuZ3RoKTtcbiAgY29uc3QgbG9jYWxTdGFjayA9IFtdO1xuICBjb25zdCBtYXhFbmQgPSBjYXB0dXJlSW5kaWNlc1swXS5lbmQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjYXB0dXJlUnVsZSA9IGNhcHR1cmVzW2ldO1xuICAgIGlmIChjYXB0dXJlUnVsZSA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGNhcHR1cmVJbmRleCA9IGNhcHR1cmVJbmRpY2VzW2ldO1xuICAgIGlmIChjYXB0dXJlSW5kZXgubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNhcHR1cmVJbmRleC5zdGFydCA+IG1heEVuZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHdoaWxlIChsb2NhbFN0YWNrLmxlbmd0aCA+IDAgJiYgbG9jYWxTdGFja1tsb2NhbFN0YWNrLmxlbmd0aCAtIDFdLmVuZFBvcyA8PSBjYXB0dXJlSW5kZXguc3RhcnQpIHtcbiAgICAgIGxpbmVUb2tlbnMucHJvZHVjZUZyb21TY29wZXMobG9jYWxTdGFja1tsb2NhbFN0YWNrLmxlbmd0aCAtIDFdLnNjb3BlcywgbG9jYWxTdGFja1tsb2NhbFN0YWNrLmxlbmd0aCAtIDFdLmVuZFBvcyk7XG4gICAgICBsb2NhbFN0YWNrLnBvcCgpO1xuICAgIH1cbiAgICBpZiAobG9jYWxTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBsaW5lVG9rZW5zLnByb2R1Y2VGcm9tU2NvcGVzKGxvY2FsU3RhY2tbbG9jYWxTdGFjay5sZW5ndGggLSAxXS5zY29wZXMsIGNhcHR1cmVJbmRleC5zdGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVUb2tlbnMucHJvZHVjZShzdGFjaywgY2FwdHVyZUluZGV4LnN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKGNhcHR1cmVSdWxlLnJldG9rZW5pemVDYXB0dXJlZFdpdGhSdWxlSWQpIHtcbiAgICAgIGNvbnN0IHNjb3BlTmFtZSA9IGNhcHR1cmVSdWxlLmdldE5hbWUobGluZVRleHRDb250ZW50LCBjYXB0dXJlSW5kaWNlcyk7XG4gICAgICBjb25zdCBuYW1lU2NvcGVzTGlzdCA9IHN0YWNrLmNvbnRlbnROYW1lU2NvcGVzTGlzdC5wdXNoQXR0cmlidXRlZChzY29wZU5hbWUsIGdyYW1tYXIpO1xuICAgICAgY29uc3QgY29udGVudE5hbWUgPSBjYXB0dXJlUnVsZS5nZXRDb250ZW50TmFtZShsaW5lVGV4dENvbnRlbnQsIGNhcHR1cmVJbmRpY2VzKTtcbiAgICAgIGNvbnN0IGNvbnRlbnROYW1lU2NvcGVzTGlzdCA9IG5hbWVTY29wZXNMaXN0LnB1c2hBdHRyaWJ1dGVkKGNvbnRlbnROYW1lLCBncmFtbWFyKTtcbiAgICAgIGNvbnN0IHN0YWNrQ2xvbmUgPSBzdGFjay5wdXNoKGNhcHR1cmVSdWxlLnJldG9rZW5pemVDYXB0dXJlZFdpdGhSdWxlSWQsIGNhcHR1cmVJbmRleC5zdGFydCwgLTEsIGZhbHNlLCBudWxsLCBuYW1lU2NvcGVzTGlzdCwgY29udGVudE5hbWVTY29wZXNMaXN0KTtcbiAgICAgIGNvbnN0IG9uaWdTdWJTdHIgPSBncmFtbWFyLmNyZWF0ZU9uaWdTdHJpbmcobGluZVRleHRDb250ZW50LnN1YnN0cmluZygwLCBjYXB0dXJlSW5kZXguZW5kKSk7XG4gICAgICBfdG9rZW5pemVTdHJpbmcoXG4gICAgICAgIGdyYW1tYXIsXG4gICAgICAgIG9uaWdTdWJTdHIsXG4gICAgICAgIGlzRmlyc3RMaW5lICYmIGNhcHR1cmVJbmRleC5zdGFydCA9PT0gMCxcbiAgICAgICAgY2FwdHVyZUluZGV4LnN0YXJ0LFxuICAgICAgICBzdGFja0Nsb25lLFxuICAgICAgICBsaW5lVG9rZW5zLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgLyogbm8gdGltZSBsaW1pdCAqL1xuICAgICAgICAwXG4gICAgICApO1xuICAgICAgZGlzcG9zZU9uaWdTdHJpbmcob25pZ1N1YlN0cik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgY2FwdHVyZVJ1bGVTY29wZU5hbWUgPSBjYXB0dXJlUnVsZS5nZXROYW1lKGxpbmVUZXh0Q29udGVudCwgY2FwdHVyZUluZGljZXMpO1xuICAgIGlmIChjYXB0dXJlUnVsZVNjb3BlTmFtZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgYmFzZSA9IGxvY2FsU3RhY2subGVuZ3RoID4gMCA/IGxvY2FsU3RhY2tbbG9jYWxTdGFjay5sZW5ndGggLSAxXS5zY29wZXMgOiBzdGFjay5jb250ZW50TmFtZVNjb3Blc0xpc3Q7XG4gICAgICBjb25zdCBjYXB0dXJlUnVsZVNjb3Blc0xpc3QgPSBiYXNlLnB1c2hBdHRyaWJ1dGVkKGNhcHR1cmVSdWxlU2NvcGVOYW1lLCBncmFtbWFyKTtcbiAgICAgIGxvY2FsU3RhY2sucHVzaChuZXcgTG9jYWxTdGFja0VsZW1lbnQoY2FwdHVyZVJ1bGVTY29wZXNMaXN0LCBjYXB0dXJlSW5kZXguZW5kKSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChsb2NhbFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICBsaW5lVG9rZW5zLnByb2R1Y2VGcm9tU2NvcGVzKGxvY2FsU3RhY2tbbG9jYWxTdGFjay5sZW5ndGggLSAxXS5zY29wZXMsIGxvY2FsU3RhY2tbbG9jYWxTdGFjay5sZW5ndGggLSAxXS5lbmRQb3MpO1xuICAgIGxvY2FsU3RhY2sucG9wKCk7XG4gIH1cbn1cbnZhciBMb2NhbFN0YWNrRWxlbWVudCA9IGNsYXNzIHtcbiAgc2NvcGVzO1xuICBlbmRQb3M7XG4gIGNvbnN0cnVjdG9yKHNjb3BlcywgZW5kUG9zKSB7XG4gICAgdGhpcy5zY29wZXMgPSBzY29wZXM7XG4gICAgdGhpcy5lbmRQb3MgPSBlbmRQb3M7XG4gIH1cbn07XG5cbi8vIHNyYy9ncmFtbWFyL2dyYW1tYXIudHNcbmZ1bmN0aW9uIGNyZWF0ZUdyYW1tYXIoc2NvcGVOYW1lLCBncmFtbWFyLCBpbml0aWFsTGFuZ3VhZ2UsIGVtYmVkZGVkTGFuZ3VhZ2VzLCB0b2tlblR5cGVzLCBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMsIGdyYW1tYXJSZXBvc2l0b3J5LCBvbmlnTGliKSB7XG4gIHJldHVybiBuZXcgR3JhbW1hcihcbiAgICBzY29wZU5hbWUsXG4gICAgZ3JhbW1hcixcbiAgICBpbml0aWFsTGFuZ3VhZ2UsXG4gICAgZW1iZWRkZWRMYW5ndWFnZXMsXG4gICAgdG9rZW5UeXBlcyxcbiAgICBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMsXG4gICAgZ3JhbW1hclJlcG9zaXRvcnksXG4gICAgb25pZ0xpYlxuICApO1xufVxuZnVuY3Rpb24gY29sbGVjdEluamVjdGlvbnMocmVzdWx0LCBzZWxlY3RvciwgcnVsZSwgcnVsZUZhY3RvcnlIZWxwZXIsIGdyYW1tYXIpIHtcbiAgY29uc3QgbWF0Y2hlcnMgPSBjcmVhdGVNYXRjaGVycyhzZWxlY3RvciwgbmFtZU1hdGNoZXIpO1xuICBjb25zdCBydWxlSWQgPSBSdWxlRmFjdG9yeS5nZXRDb21waWxlZFJ1bGVJZChydWxlLCBydWxlRmFjdG9yeUhlbHBlciwgZ3JhbW1hci5yZXBvc2l0b3J5KTtcbiAgZm9yIChjb25zdCBtYXRjaGVyIG9mIG1hdGNoZXJzKSB7XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgZGVidWdTZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICBtYXRjaGVyOiBtYXRjaGVyLm1hdGNoZXIsXG4gICAgICBydWxlSWQsXG4gICAgICBncmFtbWFyLFxuICAgICAgcHJpb3JpdHk6IG1hdGNoZXIucHJpb3JpdHlcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbmFtZU1hdGNoZXIoaWRlbnRpZmVycywgc2NvcGVzKSB7XG4gIGlmIChzY29wZXMubGVuZ3RoIDwgaWRlbnRpZmVycy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IGxhc3RJbmRleCA9IDA7XG4gIHJldHVybiBpZGVudGlmZXJzLmV2ZXJ5KChpZGVudGlmaWVyKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IGxhc3RJbmRleDsgaSA8IHNjb3Blcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHNjb3Blc0FyZU1hdGNoaW5nKHNjb3Blc1tpXSwgaWRlbnRpZmllcikpIHtcbiAgICAgICAgbGFzdEluZGV4ID0gaSArIDE7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2NvcGVzQXJlTWF0Y2hpbmcodGhpc1Njb3BlTmFtZSwgc2NvcGVOYW1lKSB7XG4gIGlmICghdGhpc1Njb3BlTmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGhpc1Njb3BlTmFtZSA9PT0gc2NvcGVOYW1lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgbGVuID0gc2NvcGVOYW1lLmxlbmd0aDtcbiAgcmV0dXJuIHRoaXNTY29wZU5hbWUubGVuZ3RoID4gbGVuICYmIHRoaXNTY29wZU5hbWUuc3Vic3RyKDAsIGxlbikgPT09IHNjb3BlTmFtZSAmJiB0aGlzU2NvcGVOYW1lW2xlbl0gPT09IFwiLlwiO1xufVxudmFyIEdyYW1tYXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9yb290U2NvcGVOYW1lLCBncmFtbWFyLCBpbml0aWFsTGFuZ3VhZ2UsIGVtYmVkZGVkTGFuZ3VhZ2VzLCB0b2tlblR5cGVzLCBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMsIGdyYW1tYXJSZXBvc2l0b3J5LCBfb25pZ0xpYikge1xuICAgIHRoaXMuX3Jvb3RTY29wZU5hbWUgPSBfcm9vdFNjb3BlTmFtZTtcbiAgICB0aGlzLmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycyA9IGJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycztcbiAgICB0aGlzLl9vbmlnTGliID0gX29uaWdMaWI7XG4gICAgdGhpcy5fYmFzaWNTY29wZUF0dHJpYnV0ZXNQcm92aWRlciA9IG5ldyBCYXNpY1Njb3BlQXR0cmlidXRlc1Byb3ZpZGVyKFxuICAgICAgaW5pdGlhbExhbmd1YWdlLFxuICAgICAgZW1iZWRkZWRMYW5ndWFnZXNcbiAgICApO1xuICAgIHRoaXMuX3Jvb3RJZCA9IC0xO1xuICAgIHRoaXMuX2xhc3RSdWxlSWQgPSAwO1xuICAgIHRoaXMuX3J1bGVJZDJkZXNjID0gW251bGxdO1xuICAgIHRoaXMuX2luY2x1ZGVkR3JhbW1hcnMgPSB7fTtcbiAgICB0aGlzLl9ncmFtbWFyUmVwb3NpdG9yeSA9IGdyYW1tYXJSZXBvc2l0b3J5O1xuICAgIHRoaXMuX2dyYW1tYXIgPSBpbml0R3JhbW1hcihncmFtbWFyLCBudWxsKTtcbiAgICB0aGlzLl9pbmplY3Rpb25zID0gbnVsbDtcbiAgICB0aGlzLl90b2tlblR5cGVNYXRjaGVycyA9IFtdO1xuICAgIGlmICh0b2tlblR5cGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IHNlbGVjdG9yIG9mIE9iamVjdC5rZXlzKHRva2VuVHlwZXMpKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXJzID0gY3JlYXRlTWF0Y2hlcnMoc2VsZWN0b3IsIG5hbWVNYXRjaGVyKTtcbiAgICAgICAgZm9yIChjb25zdCBtYXRjaGVyIG9mIG1hdGNoZXJzKSB7XG4gICAgICAgICAgdGhpcy5fdG9rZW5UeXBlTWF0Y2hlcnMucHVzaCh7XG4gICAgICAgICAgICBtYXRjaGVyOiBtYXRjaGVyLm1hdGNoZXIsXG4gICAgICAgICAgICB0eXBlOiB0b2tlblR5cGVzW3NlbGVjdG9yXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9yb290SWQ7XG4gIF9sYXN0UnVsZUlkO1xuICBfcnVsZUlkMmRlc2M7XG4gIF9pbmNsdWRlZEdyYW1tYXJzO1xuICBfZ3JhbW1hclJlcG9zaXRvcnk7XG4gIF9ncmFtbWFyO1xuICBfaW5qZWN0aW9ucztcbiAgX2Jhc2ljU2NvcGVBdHRyaWJ1dGVzUHJvdmlkZXI7XG4gIF90b2tlblR5cGVNYXRjaGVycztcbiAgZ2V0IHRoZW1lUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyYW1tYXJSZXBvc2l0b3J5O1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgZm9yIChjb25zdCBydWxlIG9mIHRoaXMuX3J1bGVJZDJkZXNjKSB7XG4gICAgICBpZiAocnVsZSkge1xuICAgICAgICBydWxlLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3JlYXRlT25pZ1NjYW5uZXIoc291cmNlcykge1xuICAgIHJldHVybiB0aGlzLl9vbmlnTGliLmNyZWF0ZU9uaWdTY2FubmVyKHNvdXJjZXMpO1xuICB9XG4gIGNyZWF0ZU9uaWdTdHJpbmcoc291cmNlcykge1xuICAgIHJldHVybiB0aGlzLl9vbmlnTGliLmNyZWF0ZU9uaWdTdHJpbmcoc291cmNlcyk7XG4gIH1cbiAgZ2V0TWV0YWRhdGFGb3JTY29wZShzY29wZSkge1xuICAgIHJldHVybiB0aGlzLl9iYXNpY1Njb3BlQXR0cmlidXRlc1Byb3ZpZGVyLmdldEJhc2ljU2NvcGVBdHRyaWJ1dGVzKHNjb3BlKTtcbiAgfVxuICBfY29sbGVjdEluamVjdGlvbnMoKSB7XG4gICAgY29uc3QgZ3JhbW1hclJlcG9zaXRvcnkgPSB7XG4gICAgICBsb29rdXA6IChzY29wZU5hbWUyKSA9PiB7XG4gICAgICAgIGlmIChzY29wZU5hbWUyID09PSB0aGlzLl9yb290U2NvcGVOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dyYW1tYXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXh0ZXJuYWxHcmFtbWFyKHNjb3BlTmFtZTIpO1xuICAgICAgfSxcbiAgICAgIGluamVjdGlvbnM6IChzY29wZU5hbWUyKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncmFtbWFyUmVwb3NpdG9yeS5pbmplY3Rpb25zKHNjb3BlTmFtZTIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3Qgc2NvcGVOYW1lID0gdGhpcy5fcm9vdFNjb3BlTmFtZTtcbiAgICBjb25zdCBncmFtbWFyID0gZ3JhbW1hclJlcG9zaXRvcnkubG9va3VwKHNjb3BlTmFtZSk7XG4gICAgaWYgKGdyYW1tYXIpIHtcbiAgICAgIGNvbnN0IHJhd0luamVjdGlvbnMgPSBncmFtbWFyLmluamVjdGlvbnM7XG4gICAgICBpZiAocmF3SW5qZWN0aW9ucykge1xuICAgICAgICBmb3IgKGxldCBleHByZXNzaW9uIGluIHJhd0luamVjdGlvbnMpIHtcbiAgICAgICAgICBjb2xsZWN0SW5qZWN0aW9ucyhcbiAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICByYXdJbmplY3Rpb25zW2V4cHJlc3Npb25dLFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGdyYW1tYXJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBpbmplY3Rpb25TY29wZU5hbWVzID0gdGhpcy5fZ3JhbW1hclJlcG9zaXRvcnkuaW5qZWN0aW9ucyhzY29wZU5hbWUpO1xuICAgICAgaWYgKGluamVjdGlvblNjb3BlTmFtZXMpIHtcbiAgICAgICAgaW5qZWN0aW9uU2NvcGVOYW1lcy5mb3JFYWNoKChpbmplY3Rpb25TY29wZU5hbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBpbmplY3Rpb25HcmFtbWFyID0gdGhpcy5nZXRFeHRlcm5hbEdyYW1tYXIoaW5qZWN0aW9uU2NvcGVOYW1lKTtcbiAgICAgICAgICBpZiAoaW5qZWN0aW9uR3JhbW1hcikge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBpbmplY3Rpb25HcmFtbWFyLmluamVjdGlvblNlbGVjdG9yO1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgIGNvbGxlY3RJbmplY3Rpb25zKFxuICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcixcbiAgICAgICAgICAgICAgICBpbmplY3Rpb25HcmFtbWFyLFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgaW5qZWN0aW9uR3JhbW1hclxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zb3J0KChpMSwgaTIpID0+IGkxLnByaW9yaXR5IC0gaTIucHJpb3JpdHkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0SW5qZWN0aW9ucygpIHtcbiAgICBpZiAodGhpcy5faW5qZWN0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5faW5qZWN0aW9ucyA9IHRoaXMuX2NvbGxlY3RJbmplY3Rpb25zKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbmplY3Rpb25zO1xuICB9XG4gIHJlZ2lzdGVyUnVsZShmYWN0b3J5KSB7XG4gICAgY29uc3QgaWQgPSArK3RoaXMuX2xhc3RSdWxlSWQ7XG4gICAgY29uc3QgcmVzdWx0ID0gZmFjdG9yeShydWxlSWRGcm9tTnVtYmVyKGlkKSk7XG4gICAgdGhpcy5fcnVsZUlkMmRlc2NbaWRdID0gcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0UnVsZShydWxlSWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcnVsZUlkMmRlc2NbcnVsZUlkVG9OdW1iZXIocnVsZUlkKV07XG4gIH1cbiAgZ2V0RXh0ZXJuYWxHcmFtbWFyKHNjb3BlTmFtZSwgcmVwb3NpdG9yeSkge1xuICAgIGlmICh0aGlzLl9pbmNsdWRlZEdyYW1tYXJzW3Njb3BlTmFtZV0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbmNsdWRlZEdyYW1tYXJzW3Njb3BlTmFtZV07XG4gICAgfSBlbHNlIGlmICh0aGlzLl9ncmFtbWFyUmVwb3NpdG9yeSkge1xuICAgICAgY29uc3QgcmF3SW5jbHVkZWRHcmFtbWFyID0gdGhpcy5fZ3JhbW1hclJlcG9zaXRvcnkubG9va3VwKHNjb3BlTmFtZSk7XG4gICAgICBpZiAocmF3SW5jbHVkZWRHcmFtbWFyKSB7XG4gICAgICAgIHRoaXMuX2luY2x1ZGVkR3JhbW1hcnNbc2NvcGVOYW1lXSA9IGluaXRHcmFtbWFyKFxuICAgICAgICAgIHJhd0luY2x1ZGVkR3JhbW1hcixcbiAgICAgICAgICByZXBvc2l0b3J5ICYmIHJlcG9zaXRvcnkuJGJhc2VcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luY2x1ZGVkR3JhbW1hcnNbc2NvcGVOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICB0b2tlbml6ZUxpbmUobGluZVRleHQsIHByZXZTdGF0ZSwgdGltZUxpbWl0ID0gMCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLl90b2tlbml6ZShsaW5lVGV4dCwgcHJldlN0YXRlLCBmYWxzZSwgdGltZUxpbWl0KTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5zOiByLmxpbmVUb2tlbnMuZ2V0UmVzdWx0KHIucnVsZVN0YWNrLCByLmxpbmVMZW5ndGgpLFxuICAgICAgcnVsZVN0YWNrOiByLnJ1bGVTdGFjayxcbiAgICAgIHN0b3BwZWRFYXJseTogci5zdG9wcGVkRWFybHlcbiAgICB9O1xuICB9XG4gIHRva2VuaXplTGluZTIobGluZVRleHQsIHByZXZTdGF0ZSwgdGltZUxpbWl0ID0gMCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLl90b2tlbml6ZShsaW5lVGV4dCwgcHJldlN0YXRlLCB0cnVlLCB0aW1lTGltaXQpO1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbnM6IHIubGluZVRva2Vucy5nZXRCaW5hcnlSZXN1bHQoci5ydWxlU3RhY2ssIHIubGluZUxlbmd0aCksXG4gICAgICBydWxlU3RhY2s6IHIucnVsZVN0YWNrLFxuICAgICAgc3RvcHBlZEVhcmx5OiByLnN0b3BwZWRFYXJseVxuICAgIH07XG4gIH1cbiAgX3Rva2VuaXplKGxpbmVUZXh0LCBwcmV2U3RhdGUsIGVtaXRCaW5hcnlUb2tlbnMsIHRpbWVMaW1pdCkge1xuICAgIGlmICh0aGlzLl9yb290SWQgPT09IC0xKSB7XG4gICAgICB0aGlzLl9yb290SWQgPSBSdWxlRmFjdG9yeS5nZXRDb21waWxlZFJ1bGVJZChcbiAgICAgICAgdGhpcy5fZ3JhbW1hci5yZXBvc2l0b3J5LiRzZWxmLFxuICAgICAgICB0aGlzLFxuICAgICAgICB0aGlzLl9ncmFtbWFyLnJlcG9zaXRvcnlcbiAgICAgICk7XG4gICAgICB0aGlzLmdldEluamVjdGlvbnMoKTtcbiAgICB9XG4gICAgbGV0IGlzRmlyc3RMaW5lO1xuICAgIGlmICghcHJldlN0YXRlIHx8IHByZXZTdGF0ZSA9PT0gU3RhdGVTdGFja0ltcGwuTlVMTCkge1xuICAgICAgaXNGaXJzdExpbmUgPSB0cnVlO1xuICAgICAgY29uc3QgcmF3RGVmYXVsdE1ldGFkYXRhID0gdGhpcy5fYmFzaWNTY29wZUF0dHJpYnV0ZXNQcm92aWRlci5nZXREZWZhdWx0QXR0cmlidXRlcygpO1xuICAgICAgY29uc3QgZGVmYXVsdFN0eWxlID0gdGhpcy50aGVtZVByb3ZpZGVyLmdldERlZmF1bHRzKCk7XG4gICAgICBjb25zdCBkZWZhdWx0TWV0YWRhdGEgPSBFbmNvZGVkVG9rZW5NZXRhZGF0YS5zZXQoXG4gICAgICAgIDAsXG4gICAgICAgIHJhd0RlZmF1bHRNZXRhZGF0YS5sYW5ndWFnZUlkLFxuICAgICAgICByYXdEZWZhdWx0TWV0YWRhdGEudG9rZW5UeXBlLFxuICAgICAgICBudWxsLFxuICAgICAgICBkZWZhdWx0U3R5bGUuZm9udFN0eWxlLFxuICAgICAgICBkZWZhdWx0U3R5bGUuZm9yZWdyb3VuZElkLFxuICAgICAgICBkZWZhdWx0U3R5bGUuYmFja2dyb3VuZElkXG4gICAgICApO1xuICAgICAgY29uc3Qgcm9vdFNjb3BlTmFtZSA9IHRoaXMuZ2V0UnVsZSh0aGlzLl9yb290SWQpLmdldE5hbWUoXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgICBsZXQgc2NvcGVMaXN0O1xuICAgICAgaWYgKHJvb3RTY29wZU5hbWUpIHtcbiAgICAgICAgc2NvcGVMaXN0ID0gQXR0cmlidXRlZFNjb3BlU3RhY2suY3JlYXRlUm9vdEFuZExvb2tVcFNjb3BlTmFtZShcbiAgICAgICAgICByb290U2NvcGVOYW1lLFxuICAgICAgICAgIGRlZmF1bHRNZXRhZGF0YSxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY29wZUxpc3QgPSBBdHRyaWJ1dGVkU2NvcGVTdGFjay5jcmVhdGVSb290KFxuICAgICAgICAgIFwidW5rbm93blwiLFxuICAgICAgICAgIGRlZmF1bHRNZXRhZGF0YVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcHJldlN0YXRlID0gbmV3IFN0YXRlU3RhY2tJbXBsKFxuICAgICAgICBudWxsLFxuICAgICAgICB0aGlzLl9yb290SWQsXG4gICAgICAgIC0xLFxuICAgICAgICAtMSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHNjb3BlTGlzdCxcbiAgICAgICAgc2NvcGVMaXN0XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0ZpcnN0TGluZSA9IGZhbHNlO1xuICAgICAgcHJldlN0YXRlLnJlc2V0KCk7XG4gICAgfVxuICAgIGxpbmVUZXh0ID0gbGluZVRleHQgKyBcIlxcblwiO1xuICAgIGNvbnN0IG9uaWdMaW5lVGV4dCA9IHRoaXMuY3JlYXRlT25pZ1N0cmluZyhsaW5lVGV4dCk7XG4gICAgY29uc3QgbGluZUxlbmd0aCA9IG9uaWdMaW5lVGV4dC5jb250ZW50Lmxlbmd0aDtcbiAgICBjb25zdCBsaW5lVG9rZW5zID0gbmV3IExpbmVUb2tlbnMoXG4gICAgICBlbWl0QmluYXJ5VG9rZW5zLFxuICAgICAgbGluZVRleHQsXG4gICAgICB0aGlzLl90b2tlblR5cGVNYXRjaGVycyxcbiAgICAgIHRoaXMuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzXG4gICAgKTtcbiAgICBjb25zdCByID0gX3Rva2VuaXplU3RyaW5nKFxuICAgICAgdGhpcyxcbiAgICAgIG9uaWdMaW5lVGV4dCxcbiAgICAgIGlzRmlyc3RMaW5lLFxuICAgICAgMCxcbiAgICAgIHByZXZTdGF0ZSxcbiAgICAgIGxpbmVUb2tlbnMsXG4gICAgICB0cnVlLFxuICAgICAgdGltZUxpbWl0XG4gICAgKTtcbiAgICBkaXNwb3NlT25pZ1N0cmluZyhvbmlnTGluZVRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lTGVuZ3RoLFxuICAgICAgbGluZVRva2VucyxcbiAgICAgIHJ1bGVTdGFjazogci5zdGFjayxcbiAgICAgIHN0b3BwZWRFYXJseTogci5zdG9wcGVkRWFybHlcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gaW5pdEdyYW1tYXIoZ3JhbW1hciwgYmFzZSkge1xuICBncmFtbWFyID0gY2xvbmUoZ3JhbW1hcik7XG4gIGdyYW1tYXIucmVwb3NpdG9yeSA9IGdyYW1tYXIucmVwb3NpdG9yeSB8fCB7fTtcbiAgZ3JhbW1hci5yZXBvc2l0b3J5LiRzZWxmID0ge1xuICAgICR2c2NvZGVUZXh0bWF0ZUxvY2F0aW9uOiBncmFtbWFyLiR2c2NvZGVUZXh0bWF0ZUxvY2F0aW9uLFxuICAgIHBhdHRlcm5zOiBncmFtbWFyLnBhdHRlcm5zLFxuICAgIG5hbWU6IGdyYW1tYXIuc2NvcGVOYW1lXG4gIH07XG4gIGdyYW1tYXIucmVwb3NpdG9yeS4kYmFzZSA9IGJhc2UgfHwgZ3JhbW1hci5yZXBvc2l0b3J5LiRzZWxmO1xuICByZXR1cm4gZ3JhbW1hcjtcbn1cbnZhciBBdHRyaWJ1dGVkU2NvcGVTdGFjayA9IGNsYXNzIF9BdHRyaWJ1dGVkU2NvcGVTdGFjayB7XG4gIC8qKlxuICAgKiBJbnZhcmlhbnQ6XG4gICAqIGBgYFxuICAgKiBpZiAocGFyZW50ICYmICFzY29wZVBhdGguZXh0ZW5kcyhwYXJlbnQuc2NvcGVQYXRoKSkge1xuICAgKiBcdHRocm93IG5ldyBFcnJvcigpO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyZW50LCBzY29wZVBhdGgsIHRva2VuQXR0cmlidXRlcykge1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuc2NvcGVQYXRoID0gc2NvcGVQYXRoO1xuICAgIHRoaXMudG9rZW5BdHRyaWJ1dGVzID0gdG9rZW5BdHRyaWJ1dGVzO1xuICB9XG4gIHN0YXRpYyBmcm9tRXh0ZW5zaW9uKG5hbWVzU2NvcGVMaXN0LCBjb250ZW50TmFtZVNjb3Blc0xpc3QpIHtcbiAgICBsZXQgY3VycmVudCA9IG5hbWVzU2NvcGVMaXN0O1xuICAgIGxldCBzY29wZU5hbWVzID0gbmFtZXNTY29wZUxpc3Q/LnNjb3BlUGF0aCA/PyBudWxsO1xuICAgIGZvciAoY29uc3QgZnJhbWUgb2YgY29udGVudE5hbWVTY29wZXNMaXN0KSB7XG4gICAgICBzY29wZU5hbWVzID0gU2NvcGVTdGFjay5wdXNoKHNjb3BlTmFtZXMsIGZyYW1lLnNjb3BlTmFtZXMpO1xuICAgICAgY3VycmVudCA9IG5ldyBfQXR0cmlidXRlZFNjb3BlU3RhY2soY3VycmVudCwgc2NvcGVOYW1lcywgZnJhbWUuZW5jb2RlZFRva2VuQXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG4gIHN0YXRpYyBjcmVhdGVSb290KHNjb3BlTmFtZSwgdG9rZW5BdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIG5ldyBfQXR0cmlidXRlZFNjb3BlU3RhY2sobnVsbCwgbmV3IFNjb3BlU3RhY2sobnVsbCwgc2NvcGVOYW1lKSwgdG9rZW5BdHRyaWJ1dGVzKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlUm9vdEFuZExvb2tVcFNjb3BlTmFtZShzY29wZU5hbWUsIHRva2VuQXR0cmlidXRlcywgZ3JhbW1hcikge1xuICAgIGNvbnN0IHJhd1Jvb3RNZXRhZGF0YSA9IGdyYW1tYXIuZ2V0TWV0YWRhdGFGb3JTY29wZShzY29wZU5hbWUpO1xuICAgIGNvbnN0IHNjb3BlUGF0aCA9IG5ldyBTY29wZVN0YWNrKG51bGwsIHNjb3BlTmFtZSk7XG4gICAgY29uc3Qgcm9vdFN0eWxlID0gZ3JhbW1hci50aGVtZVByb3ZpZGVyLnRoZW1lTWF0Y2goc2NvcGVQYXRoKTtcbiAgICBjb25zdCByZXNvbHZlZFRva2VuQXR0cmlidXRlcyA9IF9BdHRyaWJ1dGVkU2NvcGVTdGFjay5tZXJnZUF0dHJpYnV0ZXMoXG4gICAgICB0b2tlbkF0dHJpYnV0ZXMsXG4gICAgICByYXdSb290TWV0YWRhdGEsXG4gICAgICByb290U3R5bGVcbiAgICApO1xuICAgIHJldHVybiBuZXcgX0F0dHJpYnV0ZWRTY29wZVN0YWNrKG51bGwsIHNjb3BlUGF0aCwgcmVzb2x2ZWRUb2tlbkF0dHJpYnV0ZXMpO1xuICB9XG4gIGdldCBzY29wZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NvcGVQYXRoLnNjb3BlTmFtZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTY29wZU5hbWVzKCkuam9pbihcIiBcIik7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIF9BdHRyaWJ1dGVkU2NvcGVTdGFjay5lcXVhbHModGhpcywgb3RoZXIpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIGRvIHtcbiAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFhICYmICFiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFhIHx8ICFiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChhLnNjb3BlTmFtZSAhPT0gYi5zY29wZU5hbWUgfHwgYS50b2tlbkF0dHJpYnV0ZXMgIT09IGIudG9rZW5BdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGEgPSBhLnBhcmVudDtcbiAgICAgIGIgPSBiLnBhcmVudDtcbiAgICB9IHdoaWxlICh0cnVlKTtcbiAgfVxuICBzdGF0aWMgbWVyZ2VBdHRyaWJ1dGVzKGV4aXN0aW5nVG9rZW5BdHRyaWJ1dGVzLCBiYXNpY1Njb3BlQXR0cmlidXRlcywgc3R5bGVBdHRyaWJ1dGVzKSB7XG4gICAgbGV0IGZvbnRTdHlsZSA9IC0xIC8qIE5vdFNldCAqLztcbiAgICBsZXQgZm9yZWdyb3VuZCA9IDA7XG4gICAgbGV0IGJhY2tncm91bmQgPSAwO1xuICAgIGlmIChzdHlsZUF0dHJpYnV0ZXMgIT09IG51bGwpIHtcbiAgICAgIGZvbnRTdHlsZSA9IHN0eWxlQXR0cmlidXRlcy5mb250U3R5bGU7XG4gICAgICBmb3JlZ3JvdW5kID0gc3R5bGVBdHRyaWJ1dGVzLmZvcmVncm91bmRJZDtcbiAgICAgIGJhY2tncm91bmQgPSBzdHlsZUF0dHJpYnV0ZXMuYmFja2dyb3VuZElkO1xuICAgIH1cbiAgICByZXR1cm4gRW5jb2RlZFRva2VuTWV0YWRhdGEuc2V0KFxuICAgICAgZXhpc3RpbmdUb2tlbkF0dHJpYnV0ZXMsXG4gICAgICBiYXNpY1Njb3BlQXR0cmlidXRlcy5sYW5ndWFnZUlkLFxuICAgICAgYmFzaWNTY29wZUF0dHJpYnV0ZXMudG9rZW5UeXBlLFxuICAgICAgbnVsbCxcbiAgICAgIGZvbnRTdHlsZSxcbiAgICAgIGZvcmVncm91bmQsXG4gICAgICBiYWNrZ3JvdW5kXG4gICAgKTtcbiAgfVxuICBwdXNoQXR0cmlidXRlZChzY29wZVBhdGgsIGdyYW1tYXIpIHtcbiAgICBpZiAoc2NvcGVQYXRoID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHNjb3BlUGF0aC5pbmRleE9mKFwiIFwiKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBfQXR0cmlidXRlZFNjb3BlU3RhY2suX3B1c2hBdHRyaWJ1dGVkKHRoaXMsIHNjb3BlUGF0aCwgZ3JhbW1hcik7XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlcyA9IHNjb3BlUGF0aC5zcGxpdCgvIC9nKTtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcztcbiAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgICAgcmVzdWx0ID0gX0F0dHJpYnV0ZWRTY29wZVN0YWNrLl9wdXNoQXR0cmlidXRlZChyZXN1bHQsIHNjb3BlLCBncmFtbWFyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgX3B1c2hBdHRyaWJ1dGVkKHRhcmdldCwgc2NvcGVOYW1lLCBncmFtbWFyKSB7XG4gICAgY29uc3QgcmF3TWV0YWRhdGEgPSBncmFtbWFyLmdldE1ldGFkYXRhRm9yU2NvcGUoc2NvcGVOYW1lKTtcbiAgICBjb25zdCBuZXdQYXRoID0gdGFyZ2V0LnNjb3BlUGF0aC5wdXNoKHNjb3BlTmFtZSk7XG4gICAgY29uc3Qgc2NvcGVUaGVtZU1hdGNoUmVzdWx0ID0gZ3JhbW1hci50aGVtZVByb3ZpZGVyLnRoZW1lTWF0Y2gobmV3UGF0aCk7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBfQXR0cmlidXRlZFNjb3BlU3RhY2subWVyZ2VBdHRyaWJ1dGVzKFxuICAgICAgdGFyZ2V0LnRva2VuQXR0cmlidXRlcyxcbiAgICAgIHJhd01ldGFkYXRhLFxuICAgICAgc2NvcGVUaGVtZU1hdGNoUmVzdWx0XG4gICAgKTtcbiAgICByZXR1cm4gbmV3IF9BdHRyaWJ1dGVkU2NvcGVTdGFjayh0YXJnZXQsIG5ld1BhdGgsIG1ldGFkYXRhKTtcbiAgfVxuICBnZXRTY29wZU5hbWVzKCkge1xuICAgIHJldHVybiB0aGlzLnNjb3BlUGF0aC5nZXRTZWdtZW50cygpO1xuICB9XG4gIGdldEV4dGVuc2lvbklmRGVmaW5lZChiYXNlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIHdoaWxlIChzZWxmICYmIHNlbGYgIT09IGJhc2UpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgZW5jb2RlZFRva2VuQXR0cmlidXRlczogc2VsZi50b2tlbkF0dHJpYnV0ZXMsXG4gICAgICAgIHNjb3BlTmFtZXM6IHNlbGYuc2NvcGVQYXRoLmdldEV4dGVuc2lvbklmRGVmaW5lZChzZWxmLnBhcmVudD8uc2NvcGVQYXRoID8/IG51bGwpXG4gICAgICB9KTtcbiAgICAgIHNlbGYgPSBzZWxmLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGYgPT09IGJhc2UgPyByZXN1bHQucmV2ZXJzZSgpIDogdm9pZCAwO1xuICB9XG59O1xudmFyIFN0YXRlU3RhY2tJbXBsID0gY2xhc3MgX1N0YXRlU3RhY2tJbXBsIHtcbiAgLyoqXG4gICAqIEludmFyaWFudDpcbiAgICogYGBgXG4gICAqIGlmIChjb250ZW50TmFtZVNjb3Blc0xpc3QgIT09IG5hbWVTY29wZXNMaXN0ICYmIGNvbnRlbnROYW1lU2NvcGVzTGlzdD8ucGFyZW50ICE9PSBuYW1lU2NvcGVzTGlzdCkge1xuICAgKiBcdHRocm93IG5ldyBFcnJvcigpO1xuICAgKiB9XG4gICAqIGlmICh0aGlzLnBhcmVudCAmJiAhbmFtZVNjb3Blc0xpc3QuZXh0ZW5kcyh0aGlzLnBhcmVudC5jb250ZW50TmFtZVNjb3Blc0xpc3QpKSB7XG4gICAqIFx0dGhyb3cgbmV3IEVycm9yKCk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJlbnQsIHJ1bGVJZCwgZW50ZXJQb3MsIGFuY2hvclBvcywgYmVnaW5SdWxlQ2FwdHVyZWRFT0wsIGVuZFJ1bGUsIG5hbWVTY29wZXNMaXN0LCBjb250ZW50TmFtZVNjb3Blc0xpc3QpIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnJ1bGVJZCA9IHJ1bGVJZDtcbiAgICB0aGlzLmJlZ2luUnVsZUNhcHR1cmVkRU9MID0gYmVnaW5SdWxlQ2FwdHVyZWRFT0w7XG4gICAgdGhpcy5lbmRSdWxlID0gZW5kUnVsZTtcbiAgICB0aGlzLm5hbWVTY29wZXNMaXN0ID0gbmFtZVNjb3Blc0xpc3Q7XG4gICAgdGhpcy5jb250ZW50TmFtZVNjb3Blc0xpc3QgPSBjb250ZW50TmFtZVNjb3Blc0xpc3Q7XG4gICAgdGhpcy5kZXB0aCA9IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuZGVwdGggKyAxIDogMTtcbiAgICB0aGlzLl9lbnRlclBvcyA9IGVudGVyUG9zO1xuICAgIHRoaXMuX2FuY2hvclBvcyA9IGFuY2hvclBvcztcbiAgfVxuICBfc3RhY2tFbGVtZW50QnJhbmQgPSB2b2lkIDA7XG4gIC8vIFRPRE8gcmVtb3ZlIG1lXG4gIHN0YXRpYyBOVUxMID0gbmV3IF9TdGF0ZVN0YWNrSW1wbChcbiAgICBudWxsLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIGZhbHNlLFxuICAgIG51bGwsXG4gICAgbnVsbCxcbiAgICBudWxsXG4gICk7XG4gIC8qKlxuICAgKiBUaGUgcG9zaXRpb24gb24gdGhlIGN1cnJlbnQgbGluZSB3aGVyZSB0aGlzIHN0YXRlIHdhcyBwdXNoZWQuXG4gICAqIFRoaXMgaXMgcmVsZXZhbnQgb25seSB3aGlsZSB0b2tlbml6aW5nIGEgbGluZSwgdG8gZGV0ZWN0IGVuZGxlc3MgbG9vcHMuXG4gICAqIEl0cyB2YWx1ZSBpcyBtZWFuaW5nbGVzcyBhY3Jvc3MgbGluZXMuXG4gICAqL1xuICBfZW50ZXJQb3M7XG4gIC8qKlxuICAgKiBUaGUgY2FwdHVyZWQgYW5jaG9yIHBvc2l0aW9uIHdoZW4gdGhpcyBzdGFjayBlbGVtZW50IHdhcyBwdXNoZWQuXG4gICAqIFRoaXMgaXMgcmVsZXZhbnQgb25seSB3aGlsZSB0b2tlbml6aW5nIGEgbGluZSwgdG8gcmVzdG9yZSB0aGUgYW5jaG9yIHBvc2l0aW9uIHdoZW4gcG9wcGluZy5cbiAgICogSXRzIHZhbHVlIGlzIG1lYW5pbmdsZXNzIGFjcm9zcyBsaW5lcy5cbiAgICovXG4gIF9hbmNob3JQb3M7XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggb2YgdGhlIHN0YWNrLlxuICAgKi9cbiAgZGVwdGg7XG4gIGVxdWFscyhvdGhlcikge1xuICAgIGlmIChvdGhlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gX1N0YXRlU3RhY2tJbXBsLl9lcXVhbHModGhpcywgb3RoZXIpO1xuICB9XG4gIHN0YXRpYyBfZXF1YWxzKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghdGhpcy5fc3RydWN0dXJhbEVxdWFscyhhLCBiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gQXR0cmlidXRlZFNjb3BlU3RhY2suZXF1YWxzKGEuY29udGVudE5hbWVTY29wZXNMaXN0LCBiLmNvbnRlbnROYW1lU2NvcGVzTGlzdCk7XG4gIH1cbiAgLyoqXG4gICAqIEEgc3RydWN0dXJhbCBlcXVhbHMgY2hlY2suIERvZXMgbm90IHRha2UgaW50byBhY2NvdW50IGBzY29wZXNgLlxuICAgKi9cbiAgc3RhdGljIF9zdHJ1Y3R1cmFsRXF1YWxzKGEsIGIpIHtcbiAgICBkbyB7XG4gICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghYSB8fCAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoYS5kZXB0aCAhPT0gYi5kZXB0aCB8fCBhLnJ1bGVJZCAhPT0gYi5ydWxlSWQgfHwgYS5lbmRSdWxlICE9PSBiLmVuZFJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYSA9IGEucGFyZW50O1xuICAgICAgYiA9IGIucGFyZW50O1xuICAgIH0gd2hpbGUgKHRydWUpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0YXRpYyBfcmVzZXQoZWwpIHtcbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIGVsLl9lbnRlclBvcyA9IC0xO1xuICAgICAgZWwuX2FuY2hvclBvcyA9IC0xO1xuICAgICAgZWwgPSBlbC5wYXJlbnQ7XG4gICAgfVxuICB9XG4gIHJlc2V0KCkge1xuICAgIF9TdGF0ZVN0YWNrSW1wbC5fcmVzZXQodGhpcyk7XG4gIH1cbiAgcG9wKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgfVxuICBzYWZlUG9wKCkge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwdXNoKHJ1bGVJZCwgZW50ZXJQb3MsIGFuY2hvclBvcywgYmVnaW5SdWxlQ2FwdHVyZWRFT0wsIGVuZFJ1bGUsIG5hbWVTY29wZXNMaXN0LCBjb250ZW50TmFtZVNjb3Blc0xpc3QpIHtcbiAgICByZXR1cm4gbmV3IF9TdGF0ZVN0YWNrSW1wbChcbiAgICAgIHRoaXMsXG4gICAgICBydWxlSWQsXG4gICAgICBlbnRlclBvcyxcbiAgICAgIGFuY2hvclBvcyxcbiAgICAgIGJlZ2luUnVsZUNhcHR1cmVkRU9MLFxuICAgICAgZW5kUnVsZSxcbiAgICAgIG5hbWVTY29wZXNMaXN0LFxuICAgICAgY29udGVudE5hbWVTY29wZXNMaXN0XG4gICAgKTtcbiAgfVxuICBnZXRFbnRlclBvcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50ZXJQb3M7XG4gIH1cbiAgZ2V0QW5jaG9yUG9zKCkge1xuICAgIHJldHVybiB0aGlzLl9hbmNob3JQb3M7XG4gIH1cbiAgZ2V0UnVsZShncmFtbWFyKSB7XG4gICAgcmV0dXJuIGdyYW1tYXIuZ2V0UnVsZSh0aGlzLnJ1bGVJZCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgciA9IFtdO1xuICAgIHRoaXMuX3dyaXRlU3RyaW5nKHIsIDApO1xuICAgIHJldHVybiBcIltcIiArIHIuam9pbihcIixcIikgKyBcIl1cIjtcbiAgfVxuICBfd3JpdGVTdHJpbmcocmVzLCBvdXRJbmRleCkge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgb3V0SW5kZXggPSB0aGlzLnBhcmVudC5fd3JpdGVTdHJpbmcocmVzLCBvdXRJbmRleCk7XG4gICAgfVxuICAgIHJlc1tvdXRJbmRleCsrXSA9IGAoJHt0aGlzLnJ1bGVJZH0sICR7dGhpcy5uYW1lU2NvcGVzTGlzdD8udG9TdHJpbmcoKX0sICR7dGhpcy5jb250ZW50TmFtZVNjb3Blc0xpc3Q/LnRvU3RyaW5nKCl9KWA7XG4gICAgcmV0dXJuIG91dEluZGV4O1xuICB9XG4gIHdpdGhDb250ZW50TmFtZVNjb3Blc0xpc3QoY29udGVudE5hbWVTY29wZVN0YWNrKSB7XG4gICAgaWYgKHRoaXMuY29udGVudE5hbWVTY29wZXNMaXN0ID09PSBjb250ZW50TmFtZVNjb3BlU3RhY2spIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJlbnQucHVzaChcbiAgICAgIHRoaXMucnVsZUlkLFxuICAgICAgdGhpcy5fZW50ZXJQb3MsXG4gICAgICB0aGlzLl9hbmNob3JQb3MsXG4gICAgICB0aGlzLmJlZ2luUnVsZUNhcHR1cmVkRU9MLFxuICAgICAgdGhpcy5lbmRSdWxlLFxuICAgICAgdGhpcy5uYW1lU2NvcGVzTGlzdCxcbiAgICAgIGNvbnRlbnROYW1lU2NvcGVTdGFja1xuICAgICk7XG4gIH1cbiAgd2l0aEVuZFJ1bGUoZW5kUnVsZSkge1xuICAgIGlmICh0aGlzLmVuZFJ1bGUgPT09IGVuZFJ1bGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9TdGF0ZVN0YWNrSW1wbChcbiAgICAgIHRoaXMucGFyZW50LFxuICAgICAgdGhpcy5ydWxlSWQsXG4gICAgICB0aGlzLl9lbnRlclBvcyxcbiAgICAgIHRoaXMuX2FuY2hvclBvcyxcbiAgICAgIHRoaXMuYmVnaW5SdWxlQ2FwdHVyZWRFT0wsXG4gICAgICBlbmRSdWxlLFxuICAgICAgdGhpcy5uYW1lU2NvcGVzTGlzdCxcbiAgICAgIHRoaXMuY29udGVudE5hbWVTY29wZXNMaXN0XG4gICAgKTtcbiAgfVxuICAvLyBVc2VkIHRvIHdhcm4gb2YgZW5kbGVzcyBsb29wc1xuICBoYXNTYW1lUnVsZUFzKG90aGVyKSB7XG4gICAgbGV0IGVsID0gdGhpcztcbiAgICB3aGlsZSAoZWwgJiYgZWwuX2VudGVyUG9zID09PSBvdGhlci5fZW50ZXJQb3MpIHtcbiAgICAgIGlmIChlbC5ydWxlSWQgPT09IG90aGVyLnJ1bGVJZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsID0gZWwucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdG9TdGF0ZVN0YWNrRnJhbWUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJ1bGVJZDogcnVsZUlkVG9OdW1iZXIodGhpcy5ydWxlSWQpLFxuICAgICAgYmVnaW5SdWxlQ2FwdHVyZWRFT0w6IHRoaXMuYmVnaW5SdWxlQ2FwdHVyZWRFT0wsXG4gICAgICBlbmRSdWxlOiB0aGlzLmVuZFJ1bGUsXG4gICAgICBuYW1lU2NvcGVzTGlzdDogdGhpcy5uYW1lU2NvcGVzTGlzdD8uZ2V0RXh0ZW5zaW9uSWZEZWZpbmVkKHRoaXMucGFyZW50Py5uYW1lU2NvcGVzTGlzdCA/PyBudWxsKSA/PyBbXSxcbiAgICAgIGNvbnRlbnROYW1lU2NvcGVzTGlzdDogdGhpcy5jb250ZW50TmFtZVNjb3Blc0xpc3Q/LmdldEV4dGVuc2lvbklmRGVmaW5lZCh0aGlzLm5hbWVTY29wZXNMaXN0KSA/PyBbXVxuICAgIH07XG4gIH1cbiAgc3RhdGljIHB1c2hGcmFtZShzZWxmLCBmcmFtZSkge1xuICAgIGNvbnN0IG5hbWVzU2NvcGVMaXN0ID0gQXR0cmlidXRlZFNjb3BlU3RhY2suZnJvbUV4dGVuc2lvbihzZWxmPy5uYW1lU2NvcGVzTGlzdCA/PyBudWxsLCBmcmFtZS5uYW1lU2NvcGVzTGlzdCk7XG4gICAgcmV0dXJuIG5ldyBfU3RhdGVTdGFja0ltcGwoXG4gICAgICBzZWxmLFxuICAgICAgcnVsZUlkRnJvbU51bWJlcihmcmFtZS5ydWxlSWQpLFxuICAgICAgZnJhbWUuZW50ZXJQb3MgPz8gLTEsXG4gICAgICBmcmFtZS5hbmNob3JQb3MgPz8gLTEsXG4gICAgICBmcmFtZS5iZWdpblJ1bGVDYXB0dXJlZEVPTCxcbiAgICAgIGZyYW1lLmVuZFJ1bGUsXG4gICAgICBuYW1lc1Njb3BlTGlzdCxcbiAgICAgIEF0dHJpYnV0ZWRTY29wZVN0YWNrLmZyb21FeHRlbnNpb24obmFtZXNTY29wZUxpc3QsIGZyYW1lLmNvbnRlbnROYW1lU2NvcGVzTGlzdClcbiAgICApO1xuICB9XG59O1xudmFyIEJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycyA9IGNsYXNzIHtcbiAgYmFsYW5jZWRCcmFja2V0U2NvcGVzO1xuICB1bmJhbGFuY2VkQnJhY2tldFNjb3BlcztcbiAgYWxsb3dBbnkgPSBmYWxzZTtcbiAgY29uc3RydWN0b3IoYmFsYW5jZWRCcmFja2V0U2NvcGVzLCB1bmJhbGFuY2VkQnJhY2tldFNjb3Blcykge1xuICAgIHRoaXMuYmFsYW5jZWRCcmFja2V0U2NvcGVzID0gYmFsYW5jZWRCcmFja2V0U2NvcGVzLmZsYXRNYXAoXG4gICAgICAoc2VsZWN0b3IpID0+IHtcbiAgICAgICAgaWYgKHNlbGVjdG9yID09PSBcIipcIikge1xuICAgICAgICAgIHRoaXMuYWxsb3dBbnkgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlTWF0Y2hlcnMoc2VsZWN0b3IsIG5hbWVNYXRjaGVyKS5tYXAoKG0pID0+IG0ubWF0Y2hlcik7XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLnVuYmFsYW5jZWRCcmFja2V0U2NvcGVzID0gdW5iYWxhbmNlZEJyYWNrZXRTY29wZXMuZmxhdE1hcChcbiAgICAgIChzZWxlY3RvcikgPT4gY3JlYXRlTWF0Y2hlcnMoc2VsZWN0b3IsIG5hbWVNYXRjaGVyKS5tYXAoKG0pID0+IG0ubWF0Y2hlcilcbiAgICApO1xuICB9XG4gIGdldCBtYXRjaGVzQWx3YXlzKCkge1xuICAgIHJldHVybiB0aGlzLmFsbG93QW55ICYmIHRoaXMudW5iYWxhbmNlZEJyYWNrZXRTY29wZXMubGVuZ3RoID09PSAwO1xuICB9XG4gIGdldCBtYXRjaGVzTmV2ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFsYW5jZWRCcmFja2V0U2NvcGVzLmxlbmd0aCA9PT0gMCAmJiAhdGhpcy5hbGxvd0FueTtcbiAgfVxuICBtYXRjaChzY29wZXMpIHtcbiAgICBmb3IgKGNvbnN0IGV4Y2x1ZGVyIG9mIHRoaXMudW5iYWxhbmNlZEJyYWNrZXRTY29wZXMpIHtcbiAgICAgIGlmIChleGNsdWRlcihzY29wZXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBpbmNsdWRlciBvZiB0aGlzLmJhbGFuY2VkQnJhY2tldFNjb3Blcykge1xuICAgICAgaWYgKGluY2x1ZGVyKHNjb3BlcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFsbG93QW55O1xuICB9XG59O1xudmFyIExpbmVUb2tlbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGVtaXRCaW5hcnlUb2tlbnMsIGxpbmVUZXh0LCB0b2tlblR5cGVPdmVycmlkZXMsIGJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycykge1xuICAgIHRoaXMuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzID0gYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzO1xuICAgIHRoaXMuX2VtaXRCaW5hcnlUb2tlbnMgPSBlbWl0QmluYXJ5VG9rZW5zO1xuICAgIHRoaXMuX3Rva2VuVHlwZU92ZXJyaWRlcyA9IHRva2VuVHlwZU92ZXJyaWRlcztcbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIHRoaXMuX2xpbmVUZXh0ID0gbGluZVRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xpbmVUZXh0ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fdG9rZW5zID0gW107XG4gICAgdGhpcy5fYmluYXJ5VG9rZW5zID0gW107XG4gICAgdGhpcy5fbGFzdFRva2VuRW5kSW5kZXggPSAwO1xuICB9XG4gIF9lbWl0QmluYXJ5VG9rZW5zO1xuICAvKipcbiAgICogZGVmaW5lZCBvbmx5IGlmIGBmYWxzZWAuXG4gICAqL1xuICBfbGluZVRleHQ7XG4gIC8qKlxuICAgKiB1c2VkIG9ubHkgaWYgYF9lbWl0QmluYXJ5VG9rZW5zYCBpcyBmYWxzZS5cbiAgICovXG4gIF90b2tlbnM7XG4gIC8qKlxuICAgKiB1c2VkIG9ubHkgaWYgYF9lbWl0QmluYXJ5VG9rZW5zYCBpcyB0cnVlLlxuICAgKi9cbiAgX2JpbmFyeVRva2VucztcbiAgX2xhc3RUb2tlbkVuZEluZGV4O1xuICBfdG9rZW5UeXBlT3ZlcnJpZGVzO1xuICBwcm9kdWNlKHN0YWNrLCBlbmRJbmRleCkge1xuICAgIHRoaXMucHJvZHVjZUZyb21TY29wZXMoc3RhY2suY29udGVudE5hbWVTY29wZXNMaXN0LCBlbmRJbmRleCk7XG4gIH1cbiAgcHJvZHVjZUZyb21TY29wZXMoc2NvcGVzTGlzdCwgZW5kSW5kZXgpIHtcbiAgICBpZiAodGhpcy5fbGFzdFRva2VuRW5kSW5kZXggPj0gZW5kSW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2VtaXRCaW5hcnlUb2tlbnMpIHtcbiAgICAgIGxldCBtZXRhZGF0YSA9IHNjb3Blc0xpc3Q/LnRva2VuQXR0cmlidXRlcyA/PyAwO1xuICAgICAgbGV0IGNvbnRhaW5zQmFsYW5jZWRCcmFja2V0cyA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzPy5tYXRjaGVzQWx3YXlzKSB7XG4gICAgICAgIGNvbnRhaW5zQmFsYW5jZWRCcmFja2V0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fdG9rZW5UeXBlT3ZlcnJpZGVzLmxlbmd0aCA+IDAgfHwgdGhpcy5iYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMgJiYgIXRoaXMuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzLm1hdGNoZXNBbHdheXMgJiYgIXRoaXMuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzLm1hdGNoZXNOZXZlcikge1xuICAgICAgICBjb25zdCBzY29wZXMyID0gc2NvcGVzTGlzdD8uZ2V0U2NvcGVOYW1lcygpID8/IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuVHlwZSBvZiB0aGlzLl90b2tlblR5cGVPdmVycmlkZXMpIHtcbiAgICAgICAgICBpZiAodG9rZW5UeXBlLm1hdGNoZXIoc2NvcGVzMikpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gRW5jb2RlZFRva2VuTWV0YWRhdGEuc2V0KFxuICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgdG9PcHRpb25hbFRva2VuVHlwZSh0b2tlblR5cGUudHlwZSksXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIC0xIC8qIE5vdFNldCAqLyxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzKSB7XG4gICAgICAgICAgY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzID0gdGhpcy5iYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMubWF0Y2goc2NvcGVzMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb250YWluc0JhbGFuY2VkQnJhY2tldHMpIHtcbiAgICAgICAgbWV0YWRhdGEgPSBFbmNvZGVkVG9rZW5NZXRhZGF0YS5zZXQoXG4gICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgMCxcbiAgICAgICAgICA4IC8qIE5vdFNldCAqLyxcbiAgICAgICAgICBjb250YWluc0JhbGFuY2VkQnJhY2tldHMsXG4gICAgICAgICAgLTEgLyogTm90U2V0ICovLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2JpbmFyeVRva2Vucy5sZW5ndGggPiAwICYmIHRoaXMuX2JpbmFyeVRva2Vuc1t0aGlzLl9iaW5hcnlUb2tlbnMubGVuZ3RoIC0gMV0gPT09IG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuX2xhc3RUb2tlbkVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2JpbmFyeVRva2Vucy5wdXNoKHRoaXMuX2xhc3RUb2tlbkVuZEluZGV4KTtcbiAgICAgIHRoaXMuX2JpbmFyeVRva2Vucy5wdXNoKG1ldGFkYXRhKTtcbiAgICAgIHRoaXMuX2xhc3RUb2tlbkVuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlcyA9IHNjb3Blc0xpc3Q/LmdldFNjb3BlTmFtZXMoKSA/PyBbXTtcbiAgICB0aGlzLl90b2tlbnMucHVzaCh7XG4gICAgICBzdGFydEluZGV4OiB0aGlzLl9sYXN0VG9rZW5FbmRJbmRleCxcbiAgICAgIGVuZEluZGV4LFxuICAgICAgLy8gdmFsdWU6IGxpbmVUZXh0LnN1YnN0cmluZyhsYXN0VG9rZW5FbmRJbmRleCwgZW5kSW5kZXgpLFxuICAgICAgc2NvcGVzXG4gICAgfSk7XG4gICAgdGhpcy5fbGFzdFRva2VuRW5kSW5kZXggPSBlbmRJbmRleDtcbiAgfVxuICBnZXRSZXN1bHQoc3RhY2ssIGxpbmVMZW5ndGgpIHtcbiAgICBpZiAodGhpcy5fdG9rZW5zLmxlbmd0aCA+IDAgJiYgdGhpcy5fdG9rZW5zW3RoaXMuX3Rva2Vucy5sZW5ndGggLSAxXS5zdGFydEluZGV4ID09PSBsaW5lTGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5fdG9rZW5zLnBvcCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fbGFzdFRva2VuRW5kSW5kZXggPSAtMTtcbiAgICAgIHRoaXMucHJvZHVjZShzdGFjaywgbGluZUxlbmd0aCk7XG4gICAgICB0aGlzLl90b2tlbnNbdGhpcy5fdG9rZW5zLmxlbmd0aCAtIDFdLnN0YXJ0SW5kZXggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdG9rZW5zO1xuICB9XG4gIGdldEJpbmFyeVJlc3VsdChzdGFjaywgbGluZUxlbmd0aCkge1xuICAgIGlmICh0aGlzLl9iaW5hcnlUb2tlbnMubGVuZ3RoID4gMCAmJiB0aGlzLl9iaW5hcnlUb2tlbnNbdGhpcy5fYmluYXJ5VG9rZW5zLmxlbmd0aCAtIDJdID09PSBsaW5lTGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5fYmluYXJ5VG9rZW5zLnBvcCgpO1xuICAgICAgdGhpcy5fYmluYXJ5VG9rZW5zLnBvcCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYmluYXJ5VG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fbGFzdFRva2VuRW5kSW5kZXggPSAtMTtcbiAgICAgIHRoaXMucHJvZHVjZShzdGFjaywgbGluZUxlbmd0aCk7XG4gICAgICB0aGlzLl9iaW5hcnlUb2tlbnNbdGhpcy5fYmluYXJ5VG9rZW5zLmxlbmd0aCAtIDJdID0gMDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuX2JpbmFyeVRva2Vucy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9iaW5hcnlUb2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IHRoaXMuX2JpbmFyeVRva2Vuc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLy8gc3JjL3JlZ2lzdHJ5LnRzXG52YXIgU3luY1JlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0aGVtZSwgX29uaWdMaWIpIHtcbiAgICB0aGlzLl9vbmlnTGliID0gX29uaWdMaWI7XG4gICAgdGhpcy5fdGhlbWUgPSB0aGVtZTtcbiAgfVxuICBfZ3JhbW1hcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfcmF3R3JhbW1hcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfaW5qZWN0aW9uR3JhbW1hcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfdGhlbWU7XG4gIGRpc3Bvc2UoKSB7XG4gICAgZm9yIChjb25zdCBncmFtbWFyIG9mIHRoaXMuX2dyYW1tYXJzLnZhbHVlcygpKSB7XG4gICAgICBncmFtbWFyLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cbiAgc2V0VGhlbWUodGhlbWUpIHtcbiAgICB0aGlzLl90aGVtZSA9IHRoZW1lO1xuICB9XG4gIGdldENvbG9yTWFwKCkge1xuICAgIHJldHVybiB0aGlzLl90aGVtZS5nZXRDb2xvck1hcCgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYGdyYW1tYXJgIHRvIHJlZ2lzdHJ5IGFuZCByZXR1cm4gYSBsaXN0IG9mIHJlZmVyZW5jZWQgc2NvcGUgbmFtZXNcbiAgICovXG4gIGFkZEdyYW1tYXIoZ3JhbW1hciwgaW5qZWN0aW9uU2NvcGVOYW1lcykge1xuICAgIHRoaXMuX3Jhd0dyYW1tYXJzLnNldChncmFtbWFyLnNjb3BlTmFtZSwgZ3JhbW1hcik7XG4gICAgaWYgKGluamVjdGlvblNjb3BlTmFtZXMpIHtcbiAgICAgIHRoaXMuX2luamVjdGlvbkdyYW1tYXJzLnNldChncmFtbWFyLnNjb3BlTmFtZSwgaW5qZWN0aW9uU2NvcGVOYW1lcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBMb29rdXAgYSByYXcgZ3JhbW1hci5cbiAgICovXG4gIGxvb2t1cChzY29wZU5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmF3R3JhbW1hcnMuZ2V0KHNjb3BlTmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluamVjdGlvbnMgZm9yIHRoZSBnaXZlbiBncmFtbWFyXG4gICAqL1xuICBpbmplY3Rpb25zKHRhcmdldFNjb3BlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luamVjdGlvbkdyYW1tYXJzLmdldCh0YXJnZXRTY29wZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCB0aGVtZSBzZXR0aW5nc1xuICAgKi9cbiAgZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW1lLmdldERlZmF1bHRzKCk7XG4gIH1cbiAgLyoqXG4gICAqIE1hdGNoIGEgc2NvcGUgaW4gdGhlIHRoZW1lLlxuICAgKi9cbiAgdGhlbWVNYXRjaChzY29wZVBhdGgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGhlbWUubWF0Y2goc2NvcGVQYXRoKTtcbiAgfVxuICAvKipcbiAgICogTG9va3VwIGEgZ3JhbW1hci5cbiAgICovXG4gIGdyYW1tYXJGb3JTY29wZU5hbWUoc2NvcGVOYW1lLCBpbml0aWFsTGFuZ3VhZ2UsIGVtYmVkZGVkTGFuZ3VhZ2VzLCB0b2tlblR5cGVzLCBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMpIHtcbiAgICBpZiAoIXRoaXMuX2dyYW1tYXJzLmhhcyhzY29wZU5hbWUpKSB7XG4gICAgICBsZXQgcmF3R3JhbW1hciA9IHRoaXMuX3Jhd0dyYW1tYXJzLmdldChzY29wZU5hbWUpO1xuICAgICAgaWYgKCFyYXdHcmFtbWFyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5fZ3JhbW1hcnMuc2V0KHNjb3BlTmFtZSwgY3JlYXRlR3JhbW1hcihcbiAgICAgICAgc2NvcGVOYW1lLFxuICAgICAgICByYXdHcmFtbWFyLFxuICAgICAgICBpbml0aWFsTGFuZ3VhZ2UsXG4gICAgICAgIGVtYmVkZGVkTGFuZ3VhZ2VzLFxuICAgICAgICB0b2tlblR5cGVzLFxuICAgICAgICBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMsXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMuX29uaWdMaWJcbiAgICAgICkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZ3JhbW1hcnMuZ2V0KHNjb3BlTmFtZSk7XG4gIH1cbn07XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIFJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBfb3B0aW9ucztcbiAgX3N5bmNSZWdpc3RyeTtcbiAgX2Vuc3VyZUdyYW1tYXJDYWNoZTtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX3N5bmNSZWdpc3RyeSA9IG5ldyBTeW5jUmVnaXN0cnkoXG4gICAgICBUaGVtZS5jcmVhdGVGcm9tUmF3VGhlbWUob3B0aW9ucy50aGVtZSwgb3B0aW9ucy5jb2xvck1hcCksXG4gICAgICBvcHRpb25zLm9uaWdMaWJcbiAgICApO1xuICAgIHRoaXMuX2Vuc3VyZUdyYW1tYXJDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9zeW5jUmVnaXN0cnkuZGlzcG9zZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIHRoZW1lLiBPbmNlIGNhbGxlZCwgbm8gcHJldmlvdXMgYHJ1bGVTdGFja2Agc2hvdWxkIGJlIHVzZWQgYW55bW9yZS5cbiAgICovXG4gIHNldFRoZW1lKHRoZW1lLCBjb2xvck1hcCkge1xuICAgIHRoaXMuX3N5bmNSZWdpc3RyeS5zZXRUaGVtZShUaGVtZS5jcmVhdGVGcm9tUmF3VGhlbWUodGhlbWUsIGNvbG9yTWFwKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb29rdXAgYXJyYXkgZm9yIGNvbG9yIGlkcy5cbiAgICovXG4gIGdldENvbG9yTWFwKCkge1xuICAgIHJldHVybiB0aGlzLl9zeW5jUmVnaXN0cnkuZ2V0Q29sb3JNYXAoKTtcbiAgfVxuICAvKipcbiAgICogTG9hZCB0aGUgZ3JhbW1hciBmb3IgYHNjb3BlTmFtZWAgYW5kIGFsbCByZWZlcmVuY2VkIGluY2x1ZGVkIGdyYW1tYXJzIGFzeW5jaHJvbm91c2x5LlxuICAgKiBQbGVhc2UgZG8gbm90IHVzZSBsYW5ndWFnZSBpZCAwLlxuICAgKi9cbiAgbG9hZEdyYW1tYXJXaXRoRW1iZWRkZWRMYW5ndWFnZXMoaW5pdGlhbFNjb3BlTmFtZSwgaW5pdGlhbExhbmd1YWdlLCBlbWJlZGRlZExhbmd1YWdlcykge1xuICAgIHJldHVybiB0aGlzLmxvYWRHcmFtbWFyV2l0aENvbmZpZ3VyYXRpb24oaW5pdGlhbFNjb3BlTmFtZSwgaW5pdGlhbExhbmd1YWdlLCB7IGVtYmVkZGVkTGFuZ3VhZ2VzIH0pO1xuICB9XG4gIC8qKlxuICAgKiBMb2FkIHRoZSBncmFtbWFyIGZvciBgc2NvcGVOYW1lYCBhbmQgYWxsIHJlZmVyZW5jZWQgaW5jbHVkZWQgZ3JhbW1hcnMgYXN5bmNocm9ub3VzbHkuXG4gICAqIFBsZWFzZSBkbyBub3QgdXNlIGxhbmd1YWdlIGlkIDAuXG4gICAqL1xuICBsb2FkR3JhbW1hcldpdGhDb25maWd1cmF0aW9uKGluaXRpYWxTY29wZU5hbWUsIGluaXRpYWxMYW5ndWFnZSwgY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9sb2FkR3JhbW1hcihcbiAgICAgIGluaXRpYWxTY29wZU5hbWUsXG4gICAgICBpbml0aWFsTGFuZ3VhZ2UsXG4gICAgICBjb25maWd1cmF0aW9uLmVtYmVkZGVkTGFuZ3VhZ2VzLFxuICAgICAgY29uZmlndXJhdGlvbi50b2tlblR5cGVzLFxuICAgICAgbmV3IEJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycyhcbiAgICAgICAgY29uZmlndXJhdGlvbi5iYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMgfHwgW10sXG4gICAgICAgIGNvbmZpZ3VyYXRpb24udW5iYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMgfHwgW11cbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBMb2FkIHRoZSBncmFtbWFyIGZvciBgc2NvcGVOYW1lYCBhbmQgYWxsIHJlZmVyZW5jZWQgaW5jbHVkZWQgZ3JhbW1hcnMgYXN5bmNocm9ub3VzbHkuXG4gICAqL1xuICBsb2FkR3JhbW1hcihpbml0aWFsU2NvcGVOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRHcmFtbWFyKGluaXRpYWxTY29wZU5hbWUsIDAsIG51bGwsIG51bGwsIG51bGwpO1xuICB9XG4gIF9sb2FkR3JhbW1hcihpbml0aWFsU2NvcGVOYW1lLCBpbml0aWFsTGFuZ3VhZ2UsIGVtYmVkZGVkTGFuZ3VhZ2VzLCB0b2tlblR5cGVzLCBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMpIHtcbiAgICBjb25zdCBkZXBlbmRlbmN5UHJvY2Vzc29yID0gbmV3IFNjb3BlRGVwZW5kZW5jeVByb2Nlc3Nvcih0aGlzLl9zeW5jUmVnaXN0cnksIGluaXRpYWxTY29wZU5hbWUpO1xuICAgIHdoaWxlIChkZXBlbmRlbmN5UHJvY2Vzc29yLlEubGVuZ3RoID4gMCkge1xuICAgICAgZGVwZW5kZW5jeVByb2Nlc3Nvci5RLm1hcCgocmVxdWVzdCkgPT4gdGhpcy5fbG9hZFNpbmdsZUdyYW1tYXIocmVxdWVzdC5zY29wZU5hbWUpKTtcbiAgICAgIGRlcGVuZGVuY3lQcm9jZXNzb3IucHJvY2Vzc1F1ZXVlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ncmFtbWFyRm9yU2NvcGVOYW1lKFxuICAgICAgaW5pdGlhbFNjb3BlTmFtZSxcbiAgICAgIGluaXRpYWxMYW5ndWFnZSxcbiAgICAgIGVtYmVkZGVkTGFuZ3VhZ2VzLFxuICAgICAgdG9rZW5UeXBlcyxcbiAgICAgIGJhbGFuY2VkQnJhY2tldFNlbGVjdG9yc1xuICAgICk7XG4gIH1cbiAgX2xvYWRTaW5nbGVHcmFtbWFyKHNjb3BlTmFtZSkge1xuICAgIGlmICghdGhpcy5fZW5zdXJlR3JhbW1hckNhY2hlLmhhcyhzY29wZU5hbWUpKSB7XG4gICAgICB0aGlzLl9kb0xvYWRTaW5nbGVHcmFtbWFyKHNjb3BlTmFtZSk7XG4gICAgICB0aGlzLl9lbnN1cmVHcmFtbWFyQ2FjaGUuc2V0KHNjb3BlTmFtZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIF9kb0xvYWRTaW5nbGVHcmFtbWFyKHNjb3BlTmFtZSkge1xuICAgIGNvbnN0IGdyYW1tYXIgPSB0aGlzLl9vcHRpb25zLmxvYWRHcmFtbWFyKHNjb3BlTmFtZSk7XG4gICAgaWYgKGdyYW1tYXIpIHtcbiAgICAgIGNvbnN0IGluamVjdGlvbnMgPSB0eXBlb2YgdGhpcy5fb3B0aW9ucy5nZXRJbmplY3Rpb25zID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9vcHRpb25zLmdldEluamVjdGlvbnMoc2NvcGVOYW1lKSA6IHZvaWQgMDtcbiAgICAgIHRoaXMuX3N5bmNSZWdpc3RyeS5hZGRHcmFtbWFyKGdyYW1tYXIsIGluamVjdGlvbnMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHJhd0dyYW1tYXIuXG4gICAqL1xuICBhZGRHcmFtbWFyKHJhd0dyYW1tYXIsIGluamVjdGlvbnMgPSBbXSwgaW5pdGlhbExhbmd1YWdlID0gMCwgZW1iZWRkZWRMYW5ndWFnZXMgPSBudWxsKSB7XG4gICAgdGhpcy5fc3luY1JlZ2lzdHJ5LmFkZEdyYW1tYXIocmF3R3JhbW1hciwgaW5qZWN0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuX2dyYW1tYXJGb3JTY29wZU5hbWUocmF3R3JhbW1hci5zY29wZU5hbWUsIGluaXRpYWxMYW5ndWFnZSwgZW1iZWRkZWRMYW5ndWFnZXMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGdyYW1tYXIgZm9yIGBzY29wZU5hbWVgLiBUaGUgZ3JhbW1hciBtdXN0IGZpcnN0IGJlIGNyZWF0ZWQgdmlhIGBsb2FkR3JhbW1hcmAgb3IgYGFkZEdyYW1tYXJgLlxuICAgKi9cbiAgX2dyYW1tYXJGb3JTY29wZU5hbWUoc2NvcGVOYW1lLCBpbml0aWFsTGFuZ3VhZ2UgPSAwLCBlbWJlZGRlZExhbmd1YWdlcyA9IG51bGwsIHRva2VuVHlwZXMgPSBudWxsLCBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N5bmNSZWdpc3RyeS5ncmFtbWFyRm9yU2NvcGVOYW1lKFxuICAgICAgc2NvcGVOYW1lLFxuICAgICAgaW5pdGlhbExhbmd1YWdlLFxuICAgICAgZW1iZWRkZWRMYW5ndWFnZXMsXG4gICAgICB0b2tlblR5cGVzLFxuICAgICAgYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzXG4gICAgKTtcbiAgfVxufTtcbnZhciBJTklUSUFMID0gU3RhdGVTdGFja0ltcGwuTlVMTDtcbmV4cG9ydCB7XG4gIEVuY29kZWRUb2tlbk1ldGFkYXRhLFxuICBGaW5kT3B0aW9uLFxuICBGb250U3R5bGUsXG4gIElOSVRJQUwsXG4gIFJlZ2lzdHJ5LFxuICBUaGVtZSxcbiAgZGlzcG9zZU9uaWdTdHJpbmdcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/@shikijs+vscode-textmate@10.0.2/node_modules/@shikijs/vscode-textmate/dist/index.js\n");

/***/ })

};
;