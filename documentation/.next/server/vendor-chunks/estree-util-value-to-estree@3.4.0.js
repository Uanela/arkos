"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/estree-util-value-to-estree@3.4.0";
exports.ids = ["vendor-chunks/estree-util-value-to-estree@3.4.0"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/estree-util-value-to-estree@3.4.0/node_modules/estree-util-value-to-estree/dist/estree-util-value-to-estree.js":
/*!********************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/estree-util-value-to-estree@3.4.0/node_modules/estree-util-value-to-estree/dist/estree-util-value-to-estree.js ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   valueToEstree: () => (/* binding */ valueToEstree)\n/* harmony export */ });\n/**\n * Create an ESTree identifier node for a given name.\n *\n * @param name\n *   The name of the identifier.\n * @returns\n *   The identifier node.\n */\nfunction identifier(name) {\n    return { type: 'Identifier', name };\n}\n/**\n * Create an ESTree literal node for a given value.\n *\n * @param value\n *   The value for which to create a literal.\n * @returns\n *   The literal node.\n */\nfunction literal(value) {\n    return { type: 'Literal', value };\n}\n/**\n * Create an ESTree call expression on an object member.\n *\n * @param object\n *   The object to call the method on.\n * @param name\n *   The name of the method to call.\n * @param args\n *   Arguments to pass to the function call\n * @returns\n *   The call expression node.\n */\nfunction methodCall(object, name, args) {\n    return {\n        type: 'CallExpression',\n        optional: false,\n        callee: {\n            type: 'MemberExpression',\n            computed: false,\n            optional: false,\n            object,\n            property: identifier(name)\n        },\n        arguments: args\n    };\n}\n/**\n * Turn a number or bigint into an ESTree expression. This handles positive and negative numbers and\n * bigints as well as special numbers.\n *\n * @param number\n *   The value to turn into an ESTree expression.\n * @returns\n *   An expression that represents the given value.\n */\nfunction processNumber(number) {\n    if (number < 0 || Object.is(number, -0)) {\n        return {\n            type: 'UnaryExpression',\n            operator: '-',\n            prefix: true,\n            argument: processNumber(-number)\n        };\n    }\n    if (typeof number === 'bigint') {\n        return { type: 'Literal', bigint: String(number) };\n    }\n    if (number === Number.POSITIVE_INFINITY || Number.isNaN(number)) {\n        return identifier(String(number));\n    }\n    return literal(number);\n}\n/**\n * Process an array of numbers. This is a shortcut for iterables whose constructor takes an array of\n * numbers as input.\n *\n * @param numbers\n *   The numbers to add to the array expression.\n * @returns\n *   An ESTree array expression whose elements match the input numbers.\n */\nfunction processNumberArray(numbers) {\n    const elements = [];\n    for (const value of numbers) {\n        elements.push(processNumber(value));\n    }\n    return { type: 'ArrayExpression', elements };\n}\n/**\n * Check whether a value can be constructed from its string representation.\n *\n * @param value\n *   The value to check\n * @returns\n *   Whether or not the value can be constructed from its string representation.\n */\nfunction isStringReconstructable(value) {\n    return value instanceof URL || value instanceof URLSearchParams;\n}\n/**\n * Check whether a value can be constructed from its `valueOf()` result.\n *\n * @param value\n *   The value to check\n * @returns\n *   Whether or not the value can be constructed from its `valueOf()` result.\n */\nfunction isValueReconstructable(value) {\n    return (value instanceof Boolean ||\n        value instanceof Date ||\n        value instanceof Number ||\n        value instanceof String);\n}\nconst wellKnownSymbols = new Map();\nfor (const name of Reflect.ownKeys(Symbol)) {\n    const value = Symbol[name];\n    if (typeof value === 'symbol') {\n        wellKnownSymbols.set(value, name);\n    }\n}\n/**\n * Check whether a value is a typed array.\n *\n * @param value\n *   The value to check\n * @returns\n *   Whether or not the value is a typed array.\n */\nfunction isTypedArray(value) {\n    return (value instanceof BigInt64Array ||\n        value instanceof BigUint64Array ||\n        (typeof Float16Array !== 'undefined' && value instanceof Float16Array) ||\n        value instanceof Float32Array ||\n        value instanceof Float64Array ||\n        value instanceof Int8Array ||\n        value instanceof Int16Array ||\n        value instanceof Int32Array ||\n        value instanceof Uint8Array ||\n        value instanceof Uint8ClampedArray ||\n        value instanceof Uint16Array ||\n        value instanceof Uint32Array);\n}\n/**\n * Compare two value contexts for sorting them based on reference count.\n *\n * @param a\n *   The first context to compare.\n * @param b\n *   The second context to compare.\n * @returns\n *   The count of context a minus the count of context b.\n */\nfunction compareContexts(a, b) {\n    const aReferencedByB = a.referencedBy.has(b.value);\n    const bReferencedByA = b.referencedBy.has(a.value);\n    if (aReferencedByB) {\n        if (bReferencedByA) {\n            return a.count - b.count;\n        }\n        return -1;\n    }\n    if (bReferencedByA) {\n        return 1;\n    }\n    return a.count - b.count;\n}\n/**\n * Replace the assigned right hand expression with the new expression.\n *\n * If there is no assignment expression, the original expression is returned. Otherwise the\n * assignment is modified and returned,\n *\n * @param expression\n *   The expression to use for the assignment.\n * @param assignment\n *   The existing assignmentexpression\n * @returns\n *   The new expression.\n */\nfunction replaceAssignment(expression, assignment) {\n    if (!assignment || assignment.type !== 'AssignmentExpression') {\n        return expression;\n    }\n    let node = assignment;\n    while (node.right.type === 'AssignmentExpression') {\n        node = node.right;\n    }\n    node.right = expression;\n    return assignment;\n}\n/**\n * Create an ESTree epxression to represent a symbol. Global and well-known symbols are supported.\n *\n * @param symbol\n *   THe symbol to represent.\n * @returns\n *   An ESTree expression to represent the symbol.\n */\nfunction symbolToEstree(symbol) {\n    const name = wellKnownSymbols.get(symbol);\n    if (name) {\n        return {\n            type: 'MemberExpression',\n            computed: false,\n            optional: false,\n            object: identifier('Symbol'),\n            property: identifier(name)\n        };\n    }\n    if (symbol.description && symbol === Symbol.for(symbol.description)) {\n        return methodCall(identifier('Symbol'), 'for', [literal(symbol.description)]);\n    }\n    throw new TypeError(`Only global symbols are supported, got: ${String(symbol)}`, {\n        cause: symbol\n    });\n}\n/**\n * Create an ESTree property from a key and a value expression.\n *\n * @param key\n *   The property key value\n * @param value\n *   The property value as an ESTree expression.\n * @returns\n *   The ESTree properry node.\n */\nfunction property(key, value) {\n    const isString = typeof key === 'string';\n    return {\n        type: 'Property',\n        method: false,\n        shorthand: false,\n        computed: key === '__proto__' || !isString,\n        kind: 'init',\n        key: isString ? literal(key) : symbolToEstree(key),\n        value\n    };\n}\n/**\n * Convert a Temporal value to a constructor call.\n *\n * @param name\n *   The name of the constructor.\n * @param values\n *   The numeric values to pass to the constructor.\n * @param calendar\n *   The calendar name to pass to the constructor.\n * @param defaultReferenceValue\n *   The default reference value of the temporal object.\n * @param referenceValue\n *   The reference value of the temporal object.\n * @returns\n *   An ESTree expression which represents the constructor call.\n */\nfunction temporalConstructor(name, values, calendar = 'iso8601', defaultReferenceValue, referenceValue) {\n    if (calendar && typeof calendar !== 'string') {\n        throw new Error(`Unsupported calendar: ${calendar}`, { cause: calendar });\n    }\n    const args = [];\n    if (referenceValue != null &&\n        (calendar !== 'iso8601' || referenceValue !== defaultReferenceValue)) {\n        args.push(literal(referenceValue));\n    }\n    if (calendar !== 'iso8601' || args.length !== 0) {\n        args.unshift(literal(calendar));\n    }\n    for (let index = values.length - 1; index >= 0; index -= 1) {\n        const value = values[index];\n        if ((value !== 0 && value !== 0n) || args.length !== 0) {\n            args.unshift(typeof value === 'string' ? literal(value) : processNumber(value));\n        }\n    }\n    return {\n        type: 'NewExpression',\n        callee: {\n            type: 'MemberExpression',\n            computed: false,\n            optional: false,\n            object: identifier('Temporal'),\n            property: identifier(name)\n        },\n        arguments: args\n    };\n}\n/**\n * Convert a value to an ESTree node.\n *\n * @param value\n *   The value to convert.\n * @param options\n *   Additional options to configure the output.\n * @returns\n *   The ESTree node.\n */\nfunction valueToEstree(value, options = {}) {\n    const stack = [];\n    const collectedContexts = new Map();\n    const namedContexts = [];\n    /**\n     * Analyze a value and collect all reference contexts.\n     *\n     * @param val\n     *   The value to analyze.\n     */\n    function analyze(val) {\n        if (typeof val === 'function') {\n            throw new TypeError(`Unsupported value: ${val}`, { cause: val });\n        }\n        if (typeof val !== 'object') {\n            return;\n        }\n        if (val == null) {\n            return;\n        }\n        const context = collectedContexts.get(val);\n        if (context) {\n            if (options.preserveReferences) {\n                context.count += 1;\n            }\n            for (const ancestor of stack) {\n                context.referencedBy.add(ancestor);\n            }\n            if (stack.includes(val)) {\n                if (!options.preserveReferences) {\n                    throw new Error(`Found circular reference: ${val}`, { cause: val });\n                }\n                const parent = stack.at(-1);\n                const parentContext = collectedContexts.get(parent);\n                parentContext.recursive = true;\n                context.recursive = true;\n            }\n            return;\n        }\n        collectedContexts.set(val, {\n            count: 1,\n            recursive: false,\n            referencedBy: new Set(stack),\n            value: val\n        });\n        if (isTypedArray(val)) {\n            return;\n        }\n        if (isStringReconstructable(val)) {\n            return;\n        }\n        if (isValueReconstructable(val)) {\n            return;\n        }\n        if (value instanceof RegExp) {\n            return;\n        }\n        if (typeof Temporal !== 'undefined' &&\n            (value instanceof Temporal.Duration ||\n                value instanceof Temporal.Instant ||\n                value instanceof Temporal.PlainDate ||\n                value instanceof Temporal.PlainDateTime ||\n                value instanceof Temporal.PlainYearMonth ||\n                value instanceof Temporal.PlainMonthDay ||\n                value instanceof Temporal.PlainTime ||\n                value instanceof Temporal.ZonedDateTime)) {\n            return;\n        }\n        stack.push(val);\n        if (val instanceof Map) {\n            for (const pair of val) {\n                analyze(pair[0]);\n                analyze(pair[1]);\n            }\n        }\n        else if (Array.isArray(val) || val instanceof Set) {\n            for (const entry of val) {\n                analyze(entry);\n            }\n        }\n        else {\n            const proto = Object.getPrototypeOf(val);\n            if (proto != null && proto !== Object.prototype && !options.instanceAsObject) {\n                throw new TypeError(`Unsupported value: ${val}`, { cause: val });\n            }\n            for (const key of Reflect.ownKeys(val)) {\n                analyze(val[key]);\n            }\n        }\n        stack.pop();\n    }\n    /**\n     * Recursively generate the ESTree expression needed to reconstruct the value.\n     *\n     * @param val\n     *   The value to process.\n     * @param isDeclaration\n     *   Whether or not this is for a variable declaration.\n     * @returns\n     *   The ESTree expression to reconstruct the value.\n     */\n    function generate(val, isDeclaration) {\n        if (val === undefined) {\n            return identifier(String(val));\n        }\n        if (val == null || typeof val === 'string' || typeof val === 'boolean') {\n            return literal(val);\n        }\n        if (typeof val === 'bigint' || typeof val === 'number') {\n            return processNumber(val);\n        }\n        if (typeof val === 'symbol') {\n            return symbolToEstree(val);\n        }\n        const context = collectedContexts.get(val);\n        if (!isDeclaration && context?.name) {\n            return identifier(context.name);\n        }\n        if (isValueReconstructable(val)) {\n            return {\n                type: 'NewExpression',\n                callee: identifier(val.constructor.name),\n                arguments: [generate(val.valueOf())]\n            };\n        }\n        if (val instanceof RegExp) {\n            return {\n                type: 'Literal',\n                regex: { pattern: val.source, flags: val.flags }\n            };\n        }\n        if (typeof Buffer !== 'undefined' && Buffer.isBuffer(val)) {\n            return methodCall(identifier('Buffer'), 'from', [processNumberArray(val)]);\n        }\n        if (isTypedArray(val)) {\n            return {\n                type: 'NewExpression',\n                callee: identifier(val.constructor.name),\n                arguments: [processNumberArray(val)]\n            };\n        }\n        if (isStringReconstructable(val)) {\n            return {\n                type: 'NewExpression',\n                callee: identifier(val.constructor.name),\n                arguments: [literal(String(val))]\n            };\n        }\n        if (typeof Temporal !== 'undefined') {\n            if (val instanceof Temporal.Duration) {\n                return temporalConstructor('Duration', [\n                    val.years,\n                    val.months,\n                    val.weeks,\n                    val.days,\n                    val.hours,\n                    val.minutes,\n                    val.seconds,\n                    val.milliseconds,\n                    val.microseconds,\n                    val.nanoseconds\n                ]);\n            }\n            if (val instanceof Temporal.Instant) {\n                return temporalConstructor('Instant', [val.epochNanoseconds]);\n            }\n            if (val instanceof Temporal.PlainDate) {\n                const iso = val.getISOFields();\n                return temporalConstructor('PlainDate', [iso.isoYear, iso.isoMonth, iso.isoDay], iso.calendar);\n            }\n            if (val instanceof Temporal.PlainDateTime) {\n                const iso = val.getISOFields();\n                return temporalConstructor('PlainDateTime', [\n                    iso.isoYear,\n                    iso.isoMonth,\n                    iso.isoDay,\n                    iso.isoHour,\n                    iso.isoMinute,\n                    iso.isoSecond,\n                    iso.isoMillisecond,\n                    iso.isoMicrosecond,\n                    iso.isoNanosecond\n                ], iso.calendar);\n            }\n            if (val instanceof Temporal.PlainMonthDay) {\n                const iso = val.getISOFields();\n                return temporalConstructor('PlainMonthDay', [iso.isoMonth, iso.isoDay], iso.calendar, 1972, iso.isoYear);\n            }\n            if (val instanceof Temporal.PlainTime) {\n                const iso = val.getISOFields();\n                return temporalConstructor('PlainTime', [\n                    iso.isoHour,\n                    iso.isoMinute,\n                    iso.isoSecond,\n                    iso.isoMillisecond,\n                    iso.isoMicrosecond,\n                    iso.isoNanosecond\n                ]);\n            }\n            if (val instanceof Temporal.PlainYearMonth) {\n                const iso = val.getISOFields();\n                return temporalConstructor('PlainYearMonth', [iso.isoYear, iso.isoMonth], iso.calendar, 1, iso.isoDay);\n            }\n            if (val instanceof Temporal.ZonedDateTime) {\n                const iso = val.getISOFields();\n                return temporalConstructor('ZonedDateTime', [val.epochNanoseconds, val.timeZoneId], iso.calendar);\n            }\n        }\n        if (Array.isArray(val)) {\n            const elements = Array.from({ length: val.length });\n            let trimmable;\n            for (let index = 0; index < val.length; index += 1) {\n                if (!(index in val)) {\n                    elements[index] = null;\n                    trimmable = undefined;\n                    continue;\n                }\n                const child = val[index];\n                const childContext = collectedContexts.get(child);\n                if (context &&\n                    childContext &&\n                    namedContexts.indexOf(childContext) >= namedContexts.indexOf(context)) {\n                    elements[index] = null;\n                    trimmable ||= index;\n                    childContext.assignment = {\n                        type: 'AssignmentExpression',\n                        operator: '=',\n                        left: {\n                            type: 'MemberExpression',\n                            computed: true,\n                            optional: false,\n                            object: identifier(context.name),\n                            property: literal(index)\n                        },\n                        right: childContext.assignment || identifier(childContext.name)\n                    };\n                }\n                else {\n                    elements[index] = generate(child);\n                    trimmable = undefined;\n                }\n            }\n            if (trimmable != null) {\n                elements.splice(trimmable);\n            }\n            return {\n                type: 'ArrayExpression',\n                elements\n            };\n        }\n        if (val instanceof Set) {\n            const elements = [];\n            let finalizer;\n            for (const child of val) {\n                if (finalizer) {\n                    finalizer = methodCall(finalizer, 'add', [generate(child)]);\n                }\n                else {\n                    const childContext = collectedContexts.get(child);\n                    if (context &&\n                        childContext &&\n                        namedContexts.indexOf(childContext) >= namedContexts.indexOf(context)) {\n                        finalizer = methodCall(identifier(context.name), 'add', [generate(child)]);\n                    }\n                    else {\n                        elements.push(generate(child));\n                    }\n                }\n            }\n            if (context && finalizer) {\n                context.assignment = replaceAssignment(finalizer, context.assignment);\n            }\n            return {\n                type: 'NewExpression',\n                callee: identifier('Set'),\n                arguments: elements.length ? [{ type: 'ArrayExpression', elements }] : []\n            };\n        }\n        if (val instanceof Map) {\n            const elements = [];\n            let finalizer;\n            for (const [key, item] of val) {\n                if (finalizer) {\n                    finalizer = methodCall(finalizer, 'set', [generate(key), generate(item)]);\n                }\n                else {\n                    const keyContext = collectedContexts.get(key);\n                    const itemContext = collectedContexts.get(item);\n                    if (context &&\n                        ((keyContext && namedContexts.indexOf(keyContext) >= namedContexts.indexOf(context)) ||\n                            (itemContext && namedContexts.indexOf(itemContext) >= namedContexts.indexOf(context)))) {\n                        finalizer = methodCall(identifier(context.name), 'set', [\n                            generate(key),\n                            generate(item)\n                        ]);\n                    }\n                    else {\n                        elements.push({\n                            type: 'ArrayExpression',\n                            elements: [generate(key), generate(item)]\n                        });\n                    }\n                }\n            }\n            if (context && finalizer) {\n                context.assignment = replaceAssignment(finalizer, context.assignment);\n            }\n            return {\n                type: 'NewExpression',\n                callee: identifier('Map'),\n                arguments: elements.length ? [{ type: 'ArrayExpression', elements }] : []\n            };\n        }\n        const properties = [];\n        if (Object.getPrototypeOf(val) == null) {\n            properties.push({\n                type: 'Property',\n                method: false,\n                shorthand: false,\n                computed: false,\n                kind: 'init',\n                key: identifier('__proto__'),\n                value: literal(null)\n            });\n        }\n        const object = val;\n        const propertyDescriptors = [];\n        for (const key of Reflect.ownKeys(val)) {\n            // TODO [>=4] Throw an error for getters.\n            const child = object[key];\n            const { configurable, enumerable, writable } = Object.getOwnPropertyDescriptor(val, key);\n            const childContext = collectedContexts.get(child);\n            if (!configurable || !enumerable || !writable) {\n                const propertyDescriptor = [property('value', generate(child))];\n                if (configurable) {\n                    propertyDescriptor.push(property('configurable', literal(true)));\n                }\n                if (enumerable) {\n                    propertyDescriptor.push(property('enumerable', literal(true)));\n                }\n                if (writable) {\n                    propertyDescriptor.push(property('writable', literal(true)));\n                }\n                propertyDescriptors.push([\n                    key,\n                    { type: 'ObjectExpression', properties: propertyDescriptor }\n                ]);\n            }\n            else if (context &&\n                childContext &&\n                namedContexts.indexOf(childContext) >= namedContexts.indexOf(context)) {\n                if (key === '__proto__') {\n                    propertyDescriptors.push([\n                        key,\n                        {\n                            type: 'ObjectExpression',\n                            properties: [\n                                property('value', generate(child)),\n                                property('configurable', literal(true)),\n                                property('enumerable', literal(true)),\n                                property('writable', literal(true))\n                            ]\n                        }\n                    ]);\n                }\n                else {\n                    childContext.assignment = {\n                        type: 'AssignmentExpression',\n                        operator: '=',\n                        left: {\n                            type: 'MemberExpression',\n                            computed: true,\n                            optional: false,\n                            object: identifier(context.name),\n                            property: generate(key)\n                        },\n                        right: childContext.assignment || generate(child)\n                    };\n                }\n            }\n            else {\n                properties.push(property(key, generate(child)));\n            }\n        }\n        const objectExpression = {\n            type: 'ObjectExpression',\n            properties\n        };\n        if (propertyDescriptors.length) {\n            let name;\n            let args;\n            if (propertyDescriptors.length === 1) {\n                const [[key, expression]] = propertyDescriptors;\n                name = 'defineProperty';\n                args = [typeof key === 'string' ? literal(key) : symbolToEstree(key), expression];\n            }\n            else {\n                name = 'defineProperties';\n                args = [\n                    {\n                        type: 'ObjectExpression',\n                        properties: propertyDescriptors.map(([key, expression]) => property(key, expression))\n                    }\n                ];\n            }\n            if (!context) {\n                return methodCall(identifier('Object'), name, [objectExpression, ...args]);\n            }\n            context.assignment = replaceAssignment(methodCall(identifier('Object'), name, [identifier(context.name), ...args]), context.assignment);\n        }\n        return objectExpression;\n    }\n    analyze(value);\n    for (const [val, context] of collectedContexts) {\n        if (context.recursive || context.count > 1) {\n            // Assign reused or recursive references to a variable.\n            context.name = `$${namedContexts.length}`;\n            namedContexts.push(context);\n        }\n        else {\n            // Otherwise donâ€™t treat it as a reference.\n            collectedContexts.delete(val);\n        }\n    }\n    if (!namedContexts.length) {\n        return generate(value);\n    }\n    const params = namedContexts.sort(compareContexts).map((context) => ({\n        type: 'AssignmentPattern',\n        left: identifier(context.name),\n        right: generate(context.value, true)\n    }));\n    const rootContext = collectedContexts.get(value);\n    const finalizers = [];\n    for (const context of collectedContexts.values()) {\n        if (context !== rootContext && context.assignment) {\n            finalizers.push(context.assignment);\n        }\n    }\n    finalizers.push(rootContext ? rootContext.assignment || identifier(rootContext.name) : generate(value));\n    return {\n        type: 'CallExpression',\n        optional: false,\n        arguments: [],\n        callee: {\n            type: 'ArrowFunctionExpression',\n            expression: false,\n            params,\n            body: {\n                type: 'SequenceExpression',\n                expressions: finalizers\n            }\n        }\n    };\n}\n//# sourceMappingURL=estree-util-value-to-estree.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2VzdHJlZS11dGlsLXZhbHVlLXRvLWVzdHJlZUAzLjQuMC9ub2RlX21vZHVsZXMvZXN0cmVlLXV0aWwtdmFsdWUtdG8tZXN0cmVlL2Rpc3QvZXN0cmVlLXV0aWwtdmFsdWUtdG8tZXN0cmVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsZUFBZTtBQUNsRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVMsS0FBSyxpQkFBaUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQ0FBMEM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxJQUFJLEtBQUssWUFBWTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLElBQUksS0FBSyxZQUFZO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsSUFBSSxLQUFLLFlBQVk7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG9CQUFvQjtBQUM5RDtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsbUNBQW1DO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsbUNBQW1DO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUNBQXFDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy91YW5lbGFfY29tby9Eb2N1bWVudHMvZGV2ZWxvcG1lbnQvbm9kZWpzL2Fya29zL25vZGVfbW9kdWxlcy8ucG5wbS9lc3RyZWUtdXRpbC12YWx1ZS10by1lc3RyZWVAMy40LjAvbm9kZV9tb2R1bGVzL2VzdHJlZS11dGlsLXZhbHVlLXRvLWVzdHJlZS9kaXN0L2VzdHJlZS11dGlsLXZhbHVlLXRvLWVzdHJlZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZSBhbiBFU1RyZWUgaWRlbnRpZmllciBub2RlIGZvciBhIGdpdmVuIG5hbWUuXG4gKlxuICogQHBhcmFtIG5hbWVcbiAqICAgVGhlIG5hbWUgb2YgdGhlIGlkZW50aWZpZXIuXG4gKiBAcmV0dXJuc1xuICogICBUaGUgaWRlbnRpZmllciBub2RlLlxuICovXG5mdW5jdGlvbiBpZGVudGlmaWVyKG5hbWUpIHtcbiAgICByZXR1cm4geyB0eXBlOiAnSWRlbnRpZmllcicsIG5hbWUgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIEVTVHJlZSBsaXRlcmFsIG5vZGUgZm9yIGEgZ2l2ZW4gdmFsdWUuXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKiAgIFRoZSB2YWx1ZSBmb3Igd2hpY2ggdG8gY3JlYXRlIGEgbGl0ZXJhbC5cbiAqIEByZXR1cm5zXG4gKiAgIFRoZSBsaXRlcmFsIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGxpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4geyB0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlIH07XG59XG4vKipcbiAqIENyZWF0ZSBhbiBFU1RyZWUgY2FsbCBleHByZXNzaW9uIG9uIGFuIG9iamVjdCBtZW1iZXIuXG4gKlxuICogQHBhcmFtIG9iamVjdFxuICogICBUaGUgb2JqZWN0IHRvIGNhbGwgdGhlIG1ldGhvZCBvbi5cbiAqIEBwYXJhbSBuYW1lXG4gKiAgIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gY2FsbC5cbiAqIEBwYXJhbSBhcmdzXG4gKiAgIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBjYWxsXG4gKiBAcmV0dXJuc1xuICogICBUaGUgY2FsbCBleHByZXNzaW9uIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIG1ldGhvZENhbGwob2JqZWN0LCBuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0NhbGxFeHByZXNzaW9uJyxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICBjYWxsZWU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIHByb3BlcnR5OiBpZGVudGlmaWVyKG5hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIGFyZ3VtZW50czogYXJnc1xuICAgIH07XG59XG4vKipcbiAqIFR1cm4gYSBudW1iZXIgb3IgYmlnaW50IGludG8gYW4gRVNUcmVlIGV4cHJlc3Npb24uIFRoaXMgaGFuZGxlcyBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgbnVtYmVycyBhbmRcbiAqIGJpZ2ludHMgYXMgd2VsbCBhcyBzcGVjaWFsIG51bWJlcnMuXG4gKlxuICogQHBhcmFtIG51bWJlclxuICogICBUaGUgdmFsdWUgdG8gdHVybiBpbnRvIGFuIEVTVHJlZSBleHByZXNzaW9uLlxuICogQHJldHVybnNcbiAqICAgQW4gZXhwcmVzc2lvbiB0aGF0IHJlcHJlc2VudHMgdGhlIGdpdmVuIHZhbHVlLlxuICovXG5mdW5jdGlvbiBwcm9jZXNzTnVtYmVyKG51bWJlcikge1xuICAgIGlmIChudW1iZXIgPCAwIHx8IE9iamVjdC5pcyhudW1iZXIsIC0wKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1VuYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgICAgICBvcGVyYXRvcjogJy0nLFxuICAgICAgICAgICAgcHJlZml4OiB0cnVlLFxuICAgICAgICAgICAgYXJndW1lbnQ6IHByb2Nlc3NOdW1iZXIoLW51bWJlcilcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdMaXRlcmFsJywgYmlnaW50OiBTdHJpbmcobnVtYmVyKSB9O1xuICAgIH1cbiAgICBpZiAobnVtYmVyID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHwgTnVtYmVyLmlzTmFOKG51bWJlcikpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXIoU3RyaW5nKG51bWJlcikpO1xuICAgIH1cbiAgICByZXR1cm4gbGl0ZXJhbChudW1iZXIpO1xufVxuLyoqXG4gKiBQcm9jZXNzIGFuIGFycmF5IG9mIG51bWJlcnMuIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3IgaXRlcmFibGVzIHdob3NlIGNvbnN0cnVjdG9yIHRha2VzIGFuIGFycmF5IG9mXG4gKiBudW1iZXJzIGFzIGlucHV0LlxuICpcbiAqIEBwYXJhbSBudW1iZXJzXG4gKiAgIFRoZSBudW1iZXJzIHRvIGFkZCB0byB0aGUgYXJyYXkgZXhwcmVzc2lvbi5cbiAqIEByZXR1cm5zXG4gKiAgIEFuIEVTVHJlZSBhcnJheSBleHByZXNzaW9uIHdob3NlIGVsZW1lbnRzIG1hdGNoIHRoZSBpbnB1dCBudW1iZXJzLlxuICovXG5mdW5jdGlvbiBwcm9jZXNzTnVtYmVyQXJyYXkobnVtYmVycykge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBudW1iZXJzKSB7XG4gICAgICAgIGVsZW1lbnRzLnB1c2gocHJvY2Vzc051bWJlcih2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiAnQXJyYXlFeHByZXNzaW9uJywgZWxlbWVudHMgfTtcbn1cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIHZhbHVlIGNhbiBiZSBjb25zdHJ1Y3RlZCBmcm9tIGl0cyBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKiAgIFRoZSB2YWx1ZSB0byBjaGVja1xuICogQHJldHVybnNcbiAqICAgV2hldGhlciBvciBub3QgdGhlIHZhbHVlIGNhbiBiZSBjb25zdHJ1Y3RlZCBmcm9tIGl0cyBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nUmVjb25zdHJ1Y3RhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVVJMIHx8IHZhbHVlIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgdmFsdWUgY2FuIGJlIGNvbnN0cnVjdGVkIGZyb20gaXRzIGB2YWx1ZU9mKClgIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWVcbiAqICAgVGhlIHZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJuc1xuICogICBXaGV0aGVyIG9yIG5vdCB0aGUgdmFsdWUgY2FuIGJlIGNvbnN0cnVjdGVkIGZyb20gaXRzIGB2YWx1ZU9mKClgIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNWYWx1ZVJlY29uc3RydWN0YWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuIHx8XG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlciB8fFxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyk7XG59XG5jb25zdCB3ZWxsS25vd25TeW1ib2xzID0gbmV3IE1hcCgpO1xuZm9yIChjb25zdCBuYW1lIG9mIFJlZmxlY3Qub3duS2V5cyhTeW1ib2wpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBTeW1ib2xbbmFtZV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgd2VsbEtub3duU3ltYm9scy5zZXQodmFsdWUsIG5hbWUpO1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIHZhbHVlIGlzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKiAgIFRoZSB2YWx1ZSB0byBjaGVja1xuICogQHJldHVybnNcbiAqICAgV2hldGhlciBvciBub3QgdGhlIHZhbHVlIGlzIGEgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBCaWdJbnQ2NEFycmF5IHx8XG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgQmlnVWludDY0QXJyYXkgfHxcbiAgICAgICAgKHR5cGVvZiBGbG9hdDE2QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgRmxvYXQxNkFycmF5KSB8fFxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSB8fFxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEludDhBcnJheSB8fFxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEludDE2QXJyYXkgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBJbnQzMkFycmF5IHx8XG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5IHx8XG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgVWludDE2QXJyYXkgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBVaW50MzJBcnJheSk7XG59XG4vKipcbiAqIENvbXBhcmUgdHdvIHZhbHVlIGNvbnRleHRzIGZvciBzb3J0aW5nIHRoZW0gYmFzZWQgb24gcmVmZXJlbmNlIGNvdW50LlxuICpcbiAqIEBwYXJhbSBhXG4gKiAgIFRoZSBmaXJzdCBjb250ZXh0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gYlxuICogICBUaGUgc2Vjb25kIGNvbnRleHQgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zXG4gKiAgIFRoZSBjb3VudCBvZiBjb250ZXh0IGEgbWludXMgdGhlIGNvdW50IG9mIGNvbnRleHQgYi5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUNvbnRleHRzKGEsIGIpIHtcbiAgICBjb25zdCBhUmVmZXJlbmNlZEJ5QiA9IGEucmVmZXJlbmNlZEJ5LmhhcyhiLnZhbHVlKTtcbiAgICBjb25zdCBiUmVmZXJlbmNlZEJ5QSA9IGIucmVmZXJlbmNlZEJ5LmhhcyhhLnZhbHVlKTtcbiAgICBpZiAoYVJlZmVyZW5jZWRCeUIpIHtcbiAgICAgICAgaWYgKGJSZWZlcmVuY2VkQnlBKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5jb3VudCAtIGIuY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoYlJlZmVyZW5jZWRCeUEpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBhLmNvdW50IC0gYi5jb3VudDtcbn1cbi8qKlxuICogUmVwbGFjZSB0aGUgYXNzaWduZWQgcmlnaHQgaGFuZCBleHByZXNzaW9uIHdpdGggdGhlIG5ldyBleHByZXNzaW9uLlxuICpcbiAqIElmIHRoZXJlIGlzIG5vIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiwgdGhlIG9yaWdpbmFsIGV4cHJlc3Npb24gaXMgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGVcbiAqIGFzc2lnbm1lbnQgaXMgbW9kaWZpZWQgYW5kIHJldHVybmVkLFxuICpcbiAqIEBwYXJhbSBleHByZXNzaW9uXG4gKiAgIFRoZSBleHByZXNzaW9uIHRvIHVzZSBmb3IgdGhlIGFzc2lnbm1lbnQuXG4gKiBAcGFyYW0gYXNzaWdubWVudFxuICogICBUaGUgZXhpc3RpbmcgYXNzaWdubWVudGV4cHJlc3Npb25cbiAqIEByZXR1cm5zXG4gKiAgIFRoZSBuZXcgZXhwcmVzc2lvbi5cbiAqL1xuZnVuY3Rpb24gcmVwbGFjZUFzc2lnbm1lbnQoZXhwcmVzc2lvbiwgYXNzaWdubWVudCkge1xuICAgIGlmICghYXNzaWdubWVudCB8fCBhc3NpZ25tZW50LnR5cGUgIT09ICdBc3NpZ25tZW50RXhwcmVzc2lvbicpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgfVxuICAgIGxldCBub2RlID0gYXNzaWdubWVudDtcbiAgICB3aGlsZSAobm9kZS5yaWdodC50eXBlID09PSAnQXNzaWdubWVudEV4cHJlc3Npb24nKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgIH1cbiAgICBub2RlLnJpZ2h0ID0gZXhwcmVzc2lvbjtcbiAgICByZXR1cm4gYXNzaWdubWVudDtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIEVTVHJlZSBlcHhyZXNzaW9uIHRvIHJlcHJlc2VudCBhIHN5bWJvbC4gR2xvYmFsIGFuZCB3ZWxsLWtub3duIHN5bWJvbHMgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiBAcGFyYW0gc3ltYm9sXG4gKiAgIFRIZSBzeW1ib2wgdG8gcmVwcmVzZW50LlxuICogQHJldHVybnNcbiAqICAgQW4gRVNUcmVlIGV4cHJlc3Npb24gdG8gcmVwcmVzZW50IHRoZSBzeW1ib2wuXG4gKi9cbmZ1bmN0aW9uIHN5bWJvbFRvRXN0cmVlKHN5bWJvbCkge1xuICAgIGNvbnN0IG5hbWUgPSB3ZWxsS25vd25TeW1ib2xzLmdldChzeW1ib2wpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgICAgICBvYmplY3Q6IGlkZW50aWZpZXIoJ1N5bWJvbCcpLFxuICAgICAgICAgICAgcHJvcGVydHk6IGlkZW50aWZpZXIobmFtZSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHN5bWJvbC5kZXNjcmlwdGlvbiAmJiBzeW1ib2wgPT09IFN5bWJvbC5mb3Ioc3ltYm9sLmRlc2NyaXB0aW9uKSkge1xuICAgICAgICByZXR1cm4gbWV0aG9kQ2FsbChpZGVudGlmaWVyKCdTeW1ib2wnKSwgJ2ZvcicsIFtsaXRlcmFsKHN5bWJvbC5kZXNjcmlwdGlvbildKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgT25seSBnbG9iYWwgc3ltYm9scyBhcmUgc3VwcG9ydGVkLCBnb3Q6ICR7U3RyaW5nKHN5bWJvbCl9YCwge1xuICAgICAgICBjYXVzZTogc3ltYm9sXG4gICAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhbiBFU1RyZWUgcHJvcGVydHkgZnJvbSBhIGtleSBhbmQgYSB2YWx1ZSBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSBrZXlcbiAqICAgVGhlIHByb3BlcnR5IGtleSB2YWx1ZVxuICogQHBhcmFtIHZhbHVlXG4gKiAgIFRoZSBwcm9wZXJ0eSB2YWx1ZSBhcyBhbiBFU1RyZWUgZXhwcmVzc2lvbi5cbiAqIEByZXR1cm5zXG4gKiAgIFRoZSBFU1RyZWUgcHJvcGVycnkgbm9kZS5cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IGlzU3RyaW5nID0gdHlwZW9mIGtleSA9PT0gJ3N0cmluZyc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1Byb3BlcnR5JyxcbiAgICAgICAgbWV0aG9kOiBmYWxzZSxcbiAgICAgICAgc2hvcnRoYW5kOiBmYWxzZSxcbiAgICAgICAgY29tcHV0ZWQ6IGtleSA9PT0gJ19fcHJvdG9fXycgfHwgIWlzU3RyaW5nLFxuICAgICAgICBraW5kOiAnaW5pdCcsXG4gICAgICAgIGtleTogaXNTdHJpbmcgPyBsaXRlcmFsKGtleSkgOiBzeW1ib2xUb0VzdHJlZShrZXkpLFxuICAgICAgICB2YWx1ZVxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnQgYSBUZW1wb3JhbCB2YWx1ZSB0byBhIGNvbnN0cnVjdG9yIGNhbGwuXG4gKlxuICogQHBhcmFtIG5hbWVcbiAqICAgVGhlIG5hbWUgb2YgdGhlIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHZhbHVlc1xuICogICBUaGUgbnVtZXJpYyB2YWx1ZXMgdG8gcGFzcyB0byB0aGUgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0gY2FsZW5kYXJcbiAqICAgVGhlIGNhbGVuZGFyIG5hbWUgdG8gcGFzcyB0byB0aGUgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0gZGVmYXVsdFJlZmVyZW5jZVZhbHVlXG4gKiAgIFRoZSBkZWZhdWx0IHJlZmVyZW5jZSB2YWx1ZSBvZiB0aGUgdGVtcG9yYWwgb2JqZWN0LlxuICogQHBhcmFtIHJlZmVyZW5jZVZhbHVlXG4gKiAgIFRoZSByZWZlcmVuY2UgdmFsdWUgb2YgdGhlIHRlbXBvcmFsIG9iamVjdC5cbiAqIEByZXR1cm5zXG4gKiAgIEFuIEVTVHJlZSBleHByZXNzaW9uIHdoaWNoIHJlcHJlc2VudHMgdGhlIGNvbnN0cnVjdG9yIGNhbGwuXG4gKi9cbmZ1bmN0aW9uIHRlbXBvcmFsQ29uc3RydWN0b3IobmFtZSwgdmFsdWVzLCBjYWxlbmRhciA9ICdpc284NjAxJywgZGVmYXVsdFJlZmVyZW5jZVZhbHVlLCByZWZlcmVuY2VWYWx1ZSkge1xuICAgIGlmIChjYWxlbmRhciAmJiB0eXBlb2YgY2FsZW5kYXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2FsZW5kYXI6ICR7Y2FsZW5kYXJ9YCwgeyBjYXVzZTogY2FsZW5kYXIgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICBpZiAocmVmZXJlbmNlVmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAoY2FsZW5kYXIgIT09ICdpc284NjAxJyB8fCByZWZlcmVuY2VWYWx1ZSAhPT0gZGVmYXVsdFJlZmVyZW5jZVZhbHVlKSkge1xuICAgICAgICBhcmdzLnB1c2gobGl0ZXJhbChyZWZlcmVuY2VWYWx1ZSkpO1xuICAgIH1cbiAgICBpZiAoY2FsZW5kYXIgIT09ICdpc284NjAxJyB8fCBhcmdzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBhcmdzLnVuc2hpZnQobGl0ZXJhbChjYWxlbmRhcikpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpbmRleCA9IHZhbHVlcy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleCAtPSAxKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgaWYgKCh2YWx1ZSAhPT0gMCAmJiB2YWx1ZSAhPT0gMG4pIHx8IGFyZ3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IGxpdGVyYWwodmFsdWUpIDogcHJvY2Vzc051bWJlcih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdOZXdFeHByZXNzaW9uJyxcbiAgICAgICAgY2FsbGVlOiB7XG4gICAgICAgICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgICAgICBvYmplY3Q6IGlkZW50aWZpZXIoJ1RlbXBvcmFsJyksXG4gICAgICAgICAgICBwcm9wZXJ0eTogaWRlbnRpZmllcihuYW1lKVxuICAgICAgICB9LFxuICAgICAgICBhcmd1bWVudHM6IGFyZ3NcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYW4gRVNUcmVlIG5vZGUuXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKiAgIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIG9wdGlvbnNcbiAqICAgQWRkaXRpb25hbCBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgb3V0cHV0LlxuICogQHJldHVybnNcbiAqICAgVGhlIEVTVHJlZSBub2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVUb0VzdHJlZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICBjb25zdCBjb2xsZWN0ZWRDb250ZXh0cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBuYW1lZENvbnRleHRzID0gW107XG4gICAgLyoqXG4gICAgICogQW5hbHl6ZSBhIHZhbHVlIGFuZCBjb2xsZWN0IGFsbCByZWZlcmVuY2UgY29udGV4dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICogICBUaGUgdmFsdWUgdG8gYW5hbHl6ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbmFseXplKHZhbCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdmFsdWU6ICR7dmFsfWAsIHsgY2F1c2U6IHZhbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY29sbGVjdGVkQ29udGV4dHMuZ2V0KHZhbCk7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wcmVzZXJ2ZVJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFuY2VzdG9yIG9mIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZWZlcmVuY2VkQnkuYWRkKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFjay5pbmNsdWRlcyh2YWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnByZXNlcnZlUmVmZXJlbmNlcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIGNpcmN1bGFyIHJlZmVyZW5jZTogJHt2YWx9YCwgeyBjYXVzZTogdmFsIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBzdGFjay5hdCgtMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Q29udGV4dCA9IGNvbGxlY3RlZENvbnRleHRzLmdldChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIHBhcmVudENvbnRleHQucmVjdXJzaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlY3Vyc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29sbGVjdGVkQ29udGV4dHMuc2V0KHZhbCwge1xuICAgICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgICByZWN1cnNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgcmVmZXJlbmNlZEJ5OiBuZXcgU2V0KHN0YWNrKSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1R5cGVkQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmluZ1JlY29uc3RydWN0YWJsZSh2YWwpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmFsdWVSZWNvbnN0cnVjdGFibGUodmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgVGVtcG9yYWwgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAodmFsdWUgaW5zdGFuY2VvZiBUZW1wb3JhbC5EdXJhdGlvbiB8fFxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgVGVtcG9yYWwuSW5zdGFudCB8fFxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgVGVtcG9yYWwuUGxhaW5EYXRlIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBUZW1wb3JhbC5QbGFpbkRhdGVUaW1lIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBUZW1wb3JhbC5QbGFpblllYXJNb250aCB8fFxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgVGVtcG9yYWwuUGxhaW5Nb250aERheSB8fFxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgVGVtcG9yYWwuUGxhaW5UaW1lIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBUZW1wb3JhbC5ab25lZERhdGVUaW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2godmFsKTtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHZhbCkge1xuICAgICAgICAgICAgICAgIGFuYWx5emUocGFpclswXSk7XG4gICAgICAgICAgICAgICAgYW5hbHl6ZShwYWlyWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdmFsIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHZhbCkge1xuICAgICAgICAgICAgICAgIGFuYWx5emUoZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgICAgICAgICAgIGlmIChwcm90byAhPSBudWxsICYmIHByb3RvICE9PSBPYmplY3QucHJvdG90eXBlICYmICFvcHRpb25zLmluc3RhbmNlQXNPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB2YWx1ZTogJHt2YWx9YCwgeyBjYXVzZTogdmFsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgUmVmbGVjdC5vd25LZXlzKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBhbmFseXplKHZhbFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZ2VuZXJhdGUgdGhlIEVTVHJlZSBleHByZXNzaW9uIG5lZWRlZCB0byByZWNvbnN0cnVjdCB0aGUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICogICBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0gaXNEZWNsYXJhdGlvblxuICAgICAqICAgV2hldGhlciBvciBub3QgdGhpcyBpcyBmb3IgYSB2YXJpYWJsZSBkZWNsYXJhdGlvbi5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqICAgVGhlIEVTVHJlZSBleHByZXNzaW9uIHRvIHJlY29uc3RydWN0IHRoZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZSh2YWwsIGlzRGVjbGFyYXRpb24pIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWRlbnRpZmllcihTdHJpbmcodmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCA9PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWwodmFsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcgfHwgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzTnVtYmVyKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sVG9Fc3RyZWUodmFsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY29sbGVjdGVkQ29udGV4dHMuZ2V0KHZhbCk7XG4gICAgICAgIGlmICghaXNEZWNsYXJhdGlvbiAmJiBjb250ZXh0Py5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gaWRlbnRpZmllcihjb250ZXh0Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZhbHVlUmVjb25zdHJ1Y3RhYmxlKHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ05ld0V4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgIGNhbGxlZTogaWRlbnRpZmllcih2YWwuY29uc3RydWN0b3IubmFtZSksXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbZ2VuZXJhdGUodmFsLnZhbHVlT2YoKSldXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0xpdGVyYWwnLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiB7IHBhdHRlcm46IHZhbC5zb3VyY2UsIGZsYWdzOiB2YWwuZmxhZ3MgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RDYWxsKGlkZW50aWZpZXIoJ0J1ZmZlcicpLCAnZnJvbScsIFtwcm9jZXNzTnVtYmVyQXJyYXkodmFsKV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1R5cGVkQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnTmV3RXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgY2FsbGVlOiBpZGVudGlmaWVyKHZhbC5jb25zdHJ1Y3Rvci5uYW1lKSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtwcm9jZXNzTnVtYmVyQXJyYXkodmFsKV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaW5nUmVjb25zdHJ1Y3RhYmxlKHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ05ld0V4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgIGNhbGxlZTogaWRlbnRpZmllcih2YWwuY29uc3RydWN0b3IubmFtZSksXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbbGl0ZXJhbChTdHJpbmcodmFsKSldXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgVGVtcG9yYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgVGVtcG9yYWwuRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcG9yYWxDb25zdHJ1Y3RvcignRHVyYXRpb24nLCBbXG4gICAgICAgICAgICAgICAgICAgIHZhbC55ZWFycyxcbiAgICAgICAgICAgICAgICAgICAgdmFsLm1vbnRocyxcbiAgICAgICAgICAgICAgICAgICAgdmFsLndlZWtzLFxuICAgICAgICAgICAgICAgICAgICB2YWwuZGF5cyxcbiAgICAgICAgICAgICAgICAgICAgdmFsLmhvdXJzLFxuICAgICAgICAgICAgICAgICAgICB2YWwubWludXRlcyxcbiAgICAgICAgICAgICAgICAgICAgdmFsLnNlY29uZHMsXG4gICAgICAgICAgICAgICAgICAgIHZhbC5taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgICAgIHZhbC5taWNyb3NlY29uZHMsXG4gICAgICAgICAgICAgICAgICAgIHZhbC5uYW5vc2Vjb25kc1xuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFRlbXBvcmFsLkluc3RhbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcG9yYWxDb25zdHJ1Y3RvcignSW5zdGFudCcsIFt2YWwuZXBvY2hOYW5vc2Vjb25kc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFRlbXBvcmFsLlBsYWluRGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzbyA9IHZhbC5nZXRJU09GaWVsZHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcG9yYWxDb25zdHJ1Y3RvcignUGxhaW5EYXRlJywgW2lzby5pc29ZZWFyLCBpc28uaXNvTW9udGgsIGlzby5pc29EYXldLCBpc28uY2FsZW5kYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFRlbXBvcmFsLlBsYWluRGF0ZVRpbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc28gPSB2YWwuZ2V0SVNPRmllbGRzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBvcmFsQ29uc3RydWN0b3IoJ1BsYWluRGF0ZVRpbWUnLCBbXG4gICAgICAgICAgICAgICAgICAgIGlzby5pc29ZZWFyLFxuICAgICAgICAgICAgICAgICAgICBpc28uaXNvTW9udGgsXG4gICAgICAgICAgICAgICAgICAgIGlzby5pc29EYXksXG4gICAgICAgICAgICAgICAgICAgIGlzby5pc29Ib3VyLFxuICAgICAgICAgICAgICAgICAgICBpc28uaXNvTWludXRlLFxuICAgICAgICAgICAgICAgICAgICBpc28uaXNvU2Vjb25kLFxuICAgICAgICAgICAgICAgICAgICBpc28uaXNvTWlsbGlzZWNvbmQsXG4gICAgICAgICAgICAgICAgICAgIGlzby5pc29NaWNyb3NlY29uZCxcbiAgICAgICAgICAgICAgICAgICAgaXNvLmlzb05hbm9zZWNvbmRcbiAgICAgICAgICAgICAgICBdLCBpc28uY2FsZW5kYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFRlbXBvcmFsLlBsYWluTW9udGhEYXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc28gPSB2YWwuZ2V0SVNPRmllbGRzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBvcmFsQ29uc3RydWN0b3IoJ1BsYWluTW9udGhEYXknLCBbaXNvLmlzb01vbnRoLCBpc28uaXNvRGF5XSwgaXNvLmNhbGVuZGFyLCAxOTcyLCBpc28uaXNvWWVhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgVGVtcG9yYWwuUGxhaW5UaW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNvID0gdmFsLmdldElTT0ZpZWxkcygpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wb3JhbENvbnN0cnVjdG9yKCdQbGFpblRpbWUnLCBbXG4gICAgICAgICAgICAgICAgICAgIGlzby5pc29Ib3VyLFxuICAgICAgICAgICAgICAgICAgICBpc28uaXNvTWludXRlLFxuICAgICAgICAgICAgICAgICAgICBpc28uaXNvU2Vjb25kLFxuICAgICAgICAgICAgICAgICAgICBpc28uaXNvTWlsbGlzZWNvbmQsXG4gICAgICAgICAgICAgICAgICAgIGlzby5pc29NaWNyb3NlY29uZCxcbiAgICAgICAgICAgICAgICAgICAgaXNvLmlzb05hbm9zZWNvbmRcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBUZW1wb3JhbC5QbGFpblllYXJNb250aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzbyA9IHZhbC5nZXRJU09GaWVsZHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcG9yYWxDb25zdHJ1Y3RvcignUGxhaW5ZZWFyTW9udGgnLCBbaXNvLmlzb1llYXIsIGlzby5pc29Nb250aF0sIGlzby5jYWxlbmRhciwgMSwgaXNvLmlzb0RheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgVGVtcG9yYWwuWm9uZWREYXRlVGltZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzbyA9IHZhbC5nZXRJU09GaWVsZHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcG9yYWxDb25zdHJ1Y3RvcignWm9uZWREYXRlVGltZScsIFt2YWwuZXBvY2hOYW5vc2Vjb25kcywgdmFsLnRpbWVab25lSWRdLCBpc28uY2FsZW5kYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdmFsLmxlbmd0aCB9KTtcbiAgICAgICAgICAgIGxldCB0cmltbWFibGU7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdmFsLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmICghKGluZGV4IGluIHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdHJpbW1hYmxlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB2YWxbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ29udGV4dCA9IGNvbGxlY3RlZENvbnRleHRzLmdldChjaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDb250ZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgIG5hbWVkQ29udGV4dHMuaW5kZXhPZihjaGlsZENvbnRleHQpID49IG5hbWVkQ29udGV4dHMuaW5kZXhPZihjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0cmltbWFibGUgfHw9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjaGlsZENvbnRleHQuYXNzaWdubWVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogJz0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBpZGVudGlmaWVyKGNvbnRleHQubmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IGxpdGVyYWwoaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNoaWxkQ29udGV4dC5hc3NpZ25tZW50IHx8IGlkZW50aWZpZXIoY2hpbGRDb250ZXh0Lm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1tpbmRleF0gPSBnZW5lcmF0ZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHRyaW1tYWJsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJpbW1hYmxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5zcGxpY2UodHJpbW1hYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0FycmF5RXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgZWxlbWVudHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBmaW5hbGl6ZXI7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHZhbCkge1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxpemVyID0gbWV0aG9kQ2FsbChmaW5hbGl6ZXIsICdhZGQnLCBbZ2VuZXJhdGUoY2hpbGQpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZENvbnRleHQgPSBjb2xsZWN0ZWRDb250ZXh0cy5nZXQoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRDb250ZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lZENvbnRleHRzLmluZGV4T2YoY2hpbGRDb250ZXh0KSA+PSBuYW1lZENvbnRleHRzLmluZGV4T2YoY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsaXplciA9IG1ldGhvZENhbGwoaWRlbnRpZmllcihjb250ZXh0Lm5hbWUpLCAnYWRkJywgW2dlbmVyYXRlKGNoaWxkKV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChnZW5lcmF0ZShjaGlsZCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgZmluYWxpemVyKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5hc3NpZ25tZW50ID0gcmVwbGFjZUFzc2lnbm1lbnQoZmluYWxpemVyLCBjb250ZXh0LmFzc2lnbm1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnTmV3RXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgY2FsbGVlOiBpZGVudGlmaWVyKCdTZXQnKSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGVsZW1lbnRzLmxlbmd0aCA/IFt7IHR5cGU6ICdBcnJheUV4cHJlc3Npb24nLCBlbGVtZW50cyB9XSA6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICAgICAgICBsZXQgZmluYWxpemVyO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiB2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxpemVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsaXplciA9IG1ldGhvZENhbGwoZmluYWxpemVyLCAnc2V0JywgW2dlbmVyYXRlKGtleSksIGdlbmVyYXRlKGl0ZW0pXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlDb250ZXh0ID0gY29sbGVjdGVkQ29udGV4dHMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1Db250ZXh0ID0gY29sbGVjdGVkQ29udGV4dHMuZ2V0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKChrZXlDb250ZXh0ICYmIG5hbWVkQ29udGV4dHMuaW5kZXhPZihrZXlDb250ZXh0KSA+PSBuYW1lZENvbnRleHRzLmluZGV4T2YoY29udGV4dCkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGl0ZW1Db250ZXh0ICYmIG5hbWVkQ29udGV4dHMuaW5kZXhPZihpdGVtQ29udGV4dCkgPj0gbmFtZWRDb250ZXh0cy5pbmRleE9mKGNvbnRleHQpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsaXplciA9IG1ldGhvZENhbGwoaWRlbnRpZmllcihjb250ZXh0Lm5hbWUpLCAnc2V0JywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlKGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGUoaXRlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0FycmF5RXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IFtnZW5lcmF0ZShrZXkpLCBnZW5lcmF0ZShpdGVtKV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgZmluYWxpemVyKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5hc3NpZ25tZW50ID0gcmVwbGFjZUFzc2lnbm1lbnQoZmluYWxpemVyLCBjb250ZXh0LmFzc2lnbm1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnTmV3RXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgY2FsbGVlOiBpZGVudGlmaWVyKCdNYXAnKSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGVsZW1lbnRzLmxlbmd0aCA/IFt7IHR5cGU6ICdBcnJheUV4cHJlc3Npb24nLCBlbGVtZW50cyB9XSA6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwpID09IG51bGwpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1Byb3BlcnR5JyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3J0aGFuZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdpbml0JyxcbiAgICAgICAgICAgICAgICBrZXk6IGlkZW50aWZpZXIoJ19fcHJvdG9fXycpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBsaXRlcmFsKG51bGwpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYmplY3QgPSB2YWw7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5RGVzY3JpcHRvcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgUmVmbGVjdC5vd25LZXlzKHZhbCkpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gWz49NF0gVGhyb3cgYW4gZXJyb3IgZm9yIGdldHRlcnMuXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgY29uc3QgeyBjb25maWd1cmFibGUsIGVudW1lcmFibGUsIHdyaXRhYmxlIH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbCwga2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ29udGV4dCA9IGNvbGxlY3RlZENvbnRleHRzLmdldChjaGlsZCk7XG4gICAgICAgICAgICBpZiAoIWNvbmZpZ3VyYWJsZSB8fCAhZW51bWVyYWJsZSB8fCAhd3JpdGFibGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eURlc2NyaXB0b3IgPSBbcHJvcGVydHkoJ3ZhbHVlJywgZ2VuZXJhdGUoY2hpbGQpKV07XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eURlc2NyaXB0b3IucHVzaChwcm9wZXJ0eSgnY29uZmlndXJhYmxlJywgbGl0ZXJhbCh0cnVlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW51bWVyYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eURlc2NyaXB0b3IucHVzaChwcm9wZXJ0eSgnZW51bWVyYWJsZScsIGxpdGVyYWwodHJ1ZSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5RGVzY3JpcHRvci5wdXNoKHByb3BlcnR5KCd3cml0YWJsZScsIGxpdGVyYWwodHJ1ZSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvcGVydHlEZXNjcmlwdG9ycy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdPYmplY3RFeHByZXNzaW9uJywgcHJvcGVydGllczogcHJvcGVydHlEZXNjcmlwdG9yIH1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRleHQgJiZcbiAgICAgICAgICAgICAgICBjaGlsZENvbnRleHQgJiZcbiAgICAgICAgICAgICAgICBuYW1lZENvbnRleHRzLmluZGV4T2YoY2hpbGRDb250ZXh0KSA+PSBuYW1lZENvbnRleHRzLmluZGV4T2YoY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eURlc2NyaXB0b3JzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5KCd2YWx1ZScsIGdlbmVyYXRlKGNoaWxkKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5KCdjb25maWd1cmFibGUnLCBsaXRlcmFsKHRydWUpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkoJ2VudW1lcmFibGUnLCBsaXRlcmFsKHRydWUpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkoJ3dyaXRhYmxlJywgbGl0ZXJhbCh0cnVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDb250ZXh0LmFzc2lnbm1lbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6ICc9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogaWRlbnRpZmllcihjb250ZXh0Lm5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBnZW5lcmF0ZShrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNoaWxkQ29udGV4dC5hc3NpZ25tZW50IHx8IGdlbmVyYXRlKGNoaWxkKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChwcm9wZXJ0eShrZXksIGdlbmVyYXRlKGNoaWxkKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9iamVjdEV4cHJlc3Npb24gPSB7XG4gICAgICAgICAgICB0eXBlOiAnT2JqZWN0RXhwcmVzc2lvbicsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5hbWU7XG4gICAgICAgICAgICBsZXQgYXJncztcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtba2V5LCBleHByZXNzaW9uXV0gPSBwcm9wZXJ0eURlc2NyaXB0b3JzO1xuICAgICAgICAgICAgICAgIG5hbWUgPSAnZGVmaW5lUHJvcGVydHknO1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBbdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgPyBsaXRlcmFsKGtleSkgOiBzeW1ib2xUb0VzdHJlZShrZXkpLCBleHByZXNzaW9uXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5hbWUgPSAnZGVmaW5lUHJvcGVydGllcyc7XG4gICAgICAgICAgICAgICAgYXJncyA9IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ09iamVjdEV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydHlEZXNjcmlwdG9ycy5tYXAoKFtrZXksIGV4cHJlc3Npb25dKSA9PiBwcm9wZXJ0eShrZXksIGV4cHJlc3Npb24pKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2RDYWxsKGlkZW50aWZpZXIoJ09iamVjdCcpLCBuYW1lLCBbb2JqZWN0RXhwcmVzc2lvbiwgLi4uYXJnc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5hc3NpZ25tZW50ID0gcmVwbGFjZUFzc2lnbm1lbnQobWV0aG9kQ2FsbChpZGVudGlmaWVyKCdPYmplY3QnKSwgbmFtZSwgW2lkZW50aWZpZXIoY29udGV4dC5uYW1lKSwgLi4uYXJnc10pLCBjb250ZXh0LmFzc2lnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3RFeHByZXNzaW9uO1xuICAgIH1cbiAgICBhbmFseXplKHZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IFt2YWwsIGNvbnRleHRdIG9mIGNvbGxlY3RlZENvbnRleHRzKSB7XG4gICAgICAgIGlmIChjb250ZXh0LnJlY3Vyc2l2ZSB8fCBjb250ZXh0LmNvdW50ID4gMSkge1xuICAgICAgICAgICAgLy8gQXNzaWduIHJldXNlZCBvciByZWN1cnNpdmUgcmVmZXJlbmNlcyB0byBhIHZhcmlhYmxlLlxuICAgICAgICAgICAgY29udGV4dC5uYW1lID0gYCQke25hbWVkQ29udGV4dHMubGVuZ3RofWA7XG4gICAgICAgICAgICBuYW1lZENvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgZG9u4oCZdCB0cmVhdCBpdCBhcyBhIHJlZmVyZW5jZS5cbiAgICAgICAgICAgIGNvbGxlY3RlZENvbnRleHRzLmRlbGV0ZSh2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbmFtZWRDb250ZXh0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlKHZhbHVlKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0gbmFtZWRDb250ZXh0cy5zb3J0KGNvbXBhcmVDb250ZXh0cykubWFwKChjb250ZXh0KSA9PiAoe1xuICAgICAgICB0eXBlOiAnQXNzaWdubWVudFBhdHRlcm4nLFxuICAgICAgICBsZWZ0OiBpZGVudGlmaWVyKGNvbnRleHQubmFtZSksXG4gICAgICAgIHJpZ2h0OiBnZW5lcmF0ZShjb250ZXh0LnZhbHVlLCB0cnVlKVxuICAgIH0pKTtcbiAgICBjb25zdCByb290Q29udGV4dCA9IGNvbGxlY3RlZENvbnRleHRzLmdldCh2YWx1ZSk7XG4gICAgY29uc3QgZmluYWxpemVycyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29udGV4dCBvZiBjb2xsZWN0ZWRDb250ZXh0cy52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoY29udGV4dCAhPT0gcm9vdENvbnRleHQgJiYgY29udGV4dC5hc3NpZ25tZW50KSB7XG4gICAgICAgICAgICBmaW5hbGl6ZXJzLnB1c2goY29udGV4dC5hc3NpZ25tZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5hbGl6ZXJzLnB1c2gocm9vdENvbnRleHQgPyByb290Q29udGV4dC5hc3NpZ25tZW50IHx8IGlkZW50aWZpZXIocm9vdENvbnRleHQubmFtZSkgOiBnZW5lcmF0ZSh2YWx1ZSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgYXJndW1lbnRzOiBbXSxcbiAgICAgICAgY2FsbGVlOiB7XG4gICAgICAgICAgICB0eXBlOiAnQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZmFsc2UsXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1NlcXVlbmNlRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnM6IGZpbmFsaXplcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lc3RyZWUtdXRpbC12YWx1ZS10by1lc3RyZWUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/estree-util-value-to-estree@3.4.0/node_modules/estree-util-value-to-estree/dist/estree-util-value-to-estree.js\n");

/***/ })

};
;