"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micromark-util-events-to-acorn@2.0.3";
exports.ids = ["vendor-chunks/micromark-util-events-to-acorn@2.0.3"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/micromark-util-events-to-acorn@2.0.3/node_modules/micromark-util-events-to-acorn/dev/lib/index.js":
/*!*******************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/micromark-util-events-to-acorn@2.0.3/node_modules/micromark-util-events-to-acorn/dev/lib/index.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eventsToAcorn: () => (/* binding */ eventsToAcorn)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devlop */ \"(rsc)/../node_modules/.pnpm/devlop@1.1.0/node_modules/devlop/lib/development.js\");\n/* harmony import */ var estree_util_visit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! estree-util-visit */ \"(rsc)/../node_modules/.pnpm/estree-util-visit@2.0.0/node_modules/estree-util-visit/lib/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol */ \"(rsc)/../node_modules/.pnpm/micromark-util-symbol@2.0.1/node_modules/micromark-util-symbol/lib/types.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol */ \"(rsc)/../node_modules/.pnpm/micromark-util-symbol@2.0.1/node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol */ \"(rsc)/../node_modules/.pnpm/micromark-util-symbol@2.0.1/node_modules/micromark-util-symbol/lib/values.js\");\n/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vfile-message */ \"(rsc)/../node_modules/.pnpm/vfile-message@4.0.2/node_modules/vfile-message/lib/index.js\");\n/**\n * @import {Comment, Node as AcornNode, Token} from 'acorn'\n * @import {Node as EstreeNode, Program} from 'estree'\n * @import {Chunk, Event, Point as MicromarkPoint, TokenType} from 'micromark-util-types'\n * @import {Point as UnistPoint} from 'unist'\n *\n * @import {AcornOptions, Options} from 'micromark-util-events-to-acorn'\n * @import {AcornError, Collection, Result, Stop} from './types.js'\n */\n\n\n\n\n\n\n/**\n * Parse a list of micromark events with acorn.\n *\n * @param {Array<Event>} events\n *   Events.\n * @param {Options} options\n *   Configuration (required).\n * @returns {Result}\n *   Result.\n */\n// eslint-disable-next-line complexity\nfunction eventsToAcorn(events, options) {\n  const prefix = options.prefix || ''\n  const suffix = options.suffix || ''\n  const acornOptions = Object.assign({}, options.acornOptions)\n  /** @type {Array<Comment>} */\n  const comments = []\n  /** @type {Array<Token>} */\n  const tokens = []\n  const onComment = acornOptions.onComment\n  const onToken = acornOptions.onToken\n  let swallow = false\n  /** @type {AcornNode | undefined} */\n  let estree\n  /** @type {AcornError | undefined} */\n  let exception\n  /** @type {AcornOptions} */\n  const acornConfig = Object.assign({}, acornOptions, {\n    onComment: comments,\n    preserveParens: true\n  })\n\n  if (onToken) {\n    acornConfig.onToken = tokens\n  }\n\n  const collection = collect(events, options.tokenTypes)\n\n  const source = collection.value\n\n  const value = prefix + source + suffix\n  const isEmptyExpression = options.expression && empty(source)\n\n  if (isEmptyExpression && !options.allowEmpty) {\n    throw new vfile_message__WEBPACK_IMPORTED_MODULE_0__.VFileMessage('Unexpected empty expression', {\n      place: parseOffsetToUnistPoint(0),\n      ruleId: 'unexpected-empty-expression',\n      source: 'micromark-extension-mdx-expression'\n    })\n  }\n\n  try {\n    estree =\n      options.expression && !isEmptyExpression\n        ? options.acorn.parseExpressionAt(value, 0, acornConfig)\n        : options.acorn.parse(value, acornConfig)\n  } catch (error_) {\n    const error = /** @type {AcornError} */ (error_)\n    const point = parseOffsetToUnistPoint(error.pos)\n    error.message = String(error.message).replace(/ \\(\\d+:\\d+\\)$/, '')\n    // Always defined in our unist points that come from micromark.\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(point.offset !== undefined, 'expected `offset`')\n    error.pos = point.offset\n    error.loc = {line: point.line, column: point.column - 1}\n    exception = error\n    swallow =\n      error.raisedAt >= prefix.length + source.length ||\n      // Broken comments are raised at their start, not their end.\n      error.message === 'Unterminated comment'\n  }\n\n  if (estree && options.expression && !isEmptyExpression) {\n    if (empty(value.slice(estree.end, value.length - suffix.length))) {\n      estree = {\n        type: 'Program',\n        start: 0,\n        end: prefix.length + source.length,\n        // @ts-expect-error: It’s good.\n        body: [\n          {\n            type: 'ExpressionStatement',\n            expression: estree,\n            start: 0,\n            end: prefix.length + source.length\n          }\n        ],\n        sourceType: 'module',\n        comments: []\n      }\n    } else {\n      const point = parseOffsetToUnistPoint(estree.end)\n      const error = /** @type {AcornError} */ (\n        new Error('Unexpected content after expression')\n      )\n      // Always defined in our unist points that come from micromark.\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(point.offset !== undefined, 'expected `offset`')\n      error.pos = point.offset\n      error.loc = {line: point.line, column: point.column - 1}\n      exception = error\n      estree = undefined\n    }\n  }\n\n  if (estree) {\n    // @ts-expect-error: acorn *does* allow comments\n    estree.comments = comments\n\n    // @ts-expect-error: acorn looks enough like estree.\n    ;(0,estree_util_visit__WEBPACK_IMPORTED_MODULE_2__.visit)(estree, function (esnode, field, index, parents) {\n      let context = /** @type {AcornNode | Array<AcornNode>} */ (\n        parents[parents.length - 1]\n      )\n      /** @type {number | string | undefined} */\n      let property = field\n\n      // Remove non-standard `ParenthesizedExpression`.\n      // @ts-expect-error: included in acorn.\n      if (esnode.type === 'ParenthesizedExpression' && context && property) {\n        /* c8 ignore next 5 */\n        if (typeof index === 'number') {\n          // @ts-expect-error: indexable.\n          context = context[property]\n          property = index\n        }\n\n        // @ts-expect-error: indexable.\n        context[property] = esnode.expression\n      }\n\n      fixPosition(esnode)\n    })\n\n    // Comment positions are fixed by `visit` because they’re in the tree.\n    if (Array.isArray(onComment)) {\n      onComment.push(...comments)\n    } else if (typeof onComment === 'function') {\n      for (const comment of comments) {\n        (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(comment.loc, 'expected `loc` on comment')\n        onComment(\n          comment.type === 'Block',\n          comment.value,\n          comment.start,\n          comment.end,\n          comment.loc.start,\n          comment.loc.end\n        )\n      }\n    }\n\n    for (const token of tokens) {\n      // Ignore tokens that ends in prefix or start in suffix:\n      if (\n        token.end <= prefix.length ||\n        token.start - prefix.length >= source.length\n      ) {\n        continue\n      }\n\n      fixPosition(token)\n\n      if (Array.isArray(onToken)) {\n        onToken.push(token)\n      } else {\n        // `tokens` are not added if `onToken` is not defined, so it must be a\n        // function.\n        (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(typeof onToken === 'function', 'expected function')\n        onToken(token)\n      }\n    }\n  }\n\n  // @ts-expect-error: It’s a program now.\n  return {estree, error: exception, swallow}\n\n  /**\n   * Update the position of a node.\n   *\n   * @param {AcornNode | EstreeNode | Token} nodeOrToken\n   * @returns {undefined}\n   */\n  function fixPosition(nodeOrToken) {\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n      'start' in nodeOrToken,\n      'expected `start` in node or token from acorn'\n    )\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)('end' in nodeOrToken, 'expected `end` in node or token from acorn')\n    const pointStart = parseOffsetToUnistPoint(nodeOrToken.start)\n    const pointEnd = parseOffsetToUnistPoint(nodeOrToken.end)\n    // Always defined in our unist points that come from micromark.\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(pointStart.offset !== undefined, 'expected `offset`')\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(pointEnd.offset !== undefined, 'expected `offset`')\n    nodeOrToken.start = pointStart.offset\n    nodeOrToken.end = pointEnd.offset\n    nodeOrToken.loc = {\n      start: {\n        line: pointStart.line,\n        column: pointStart.column - 1,\n        // @ts-expect-error: not allowed by acorn types.\n        offset: pointStart.offset\n      },\n      end: {\n        line: pointEnd.line,\n        column: pointEnd.column - 1,\n        // @ts-expect-error: not allowed by acorn types.\n        offset: pointEnd.offset\n      }\n    }\n    nodeOrToken.range = [nodeOrToken.start, nodeOrToken.end]\n  }\n\n  /**\n   * Turn an arbitrary offset into the parsed value, into a point in the source\n   * value.\n   *\n   * @param {number} acornOffset\n   * @returns {UnistPoint}\n   */\n  function parseOffsetToUnistPoint(acornOffset) {\n    let sourceOffset = acornOffset - prefix.length\n\n    if (sourceOffset < 0) {\n      sourceOffset = 0\n    } else if (sourceOffset > source.length) {\n      sourceOffset = source.length\n    }\n\n    let point = relativeToPoint(collection.stops, sourceOffset)\n\n    if (!point) {\n      (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n        options.start,\n        'empty expressions are need `options.start` being passed'\n      )\n      point = {\n        line: options.start.line,\n        column: options.start.column,\n        offset: options.start.offset\n      }\n    }\n\n    return point\n  }\n}\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nfunction empty(value) {\n  return /^\\s*$/.test(\n    value\n      // Multiline comments.\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '')\n      // Line comments.\n      // EOF instead of EOL is specifically not allowed, because that would\n      // mean the closing brace is on the commented-out line\n      .replace(/\\/\\/[^\\r\\n]*(\\r\\n|\\n|\\r)/g, '')\n  )\n}\n\n// Port from <https://github.com/wooorm/markdown-rs/blob/e692ab0/src/util/mdx_collect.rs#L15>.\n/**\n * @param {Array<Event>} events\n * @param {Array<TokenType>} tokenTypes\n * @returns {Collection}\n */\nfunction collect(events, tokenTypes) {\n  /** @type {Collection} */\n  const result = {value: '', stops: []}\n  let index = -1\n\n  while (++index < events.length) {\n    const event = events[index]\n\n    // Assume void.\n    if (event[0] === 'enter') {\n      const type = event[1].type\n\n      if (type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding || tokenTypes.includes(type)) {\n        const chunks = event[2].sliceStream(event[1])\n\n        // Drop virtual spaces.\n        while (chunks.length > 0 && chunks[0] === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.virtualSpace) {\n          chunks.shift()\n        }\n\n        const value = serializeChunks(chunks)\n        result.stops.push([result.value.length, event[1].start])\n        result.value += value\n        result.stops.push([result.value.length, event[1].end])\n      }\n    }\n  }\n\n  return result\n}\n\n// Port from <https://github.com/wooorm/markdown-rs/blob/e692ab0/src/util/location.rs#L91>.\n/**\n * Turn a relative offset into an absolute offset.\n *\n * @param {Array<Stop>} stops\n * @param {number} relative\n * @returns {UnistPoint | undefined}\n */\nfunction relativeToPoint(stops, relative) {\n  let index = 0\n\n  while (index < stops.length && stops[index][0] <= relative) {\n    index += 1\n  }\n\n  // There are no points: that only occurs if there was an empty string.\n  if (index === 0) {\n    return undefined\n  }\n\n  const [stopRelative, stopAbsolute] = stops[index - 1]\n  const rest = relative - stopRelative\n  return {\n    line: stopAbsolute.line,\n    column: stopAbsolute.column + rest,\n    offset: stopAbsolute.offset + rest\n  }\n}\n\n// Copy from <https://github.com/micromark/micromark/blob/ce3593a/packages/micromark/dev/lib/create-tokenizer.js#L595>\n// To do: expose that?\n/**\n * Get the string value of a slice of chunks.\n *\n * @param {Array<Chunk>} chunks\n * @returns {string}\n */\nfunction serializeChunks(chunks) {\n  let index = -1\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {boolean | undefined} */\n  let atTab\n\n  while (++index < chunks.length) {\n    const chunk = chunks[index]\n    /** @type {string} */\n    let value\n\n    if (typeof chunk === 'string') {\n      value = chunk\n    } else\n      switch (chunk) {\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.carriageReturn: {\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.cr\n\n          break\n        }\n\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.lineFeed: {\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.lf\n\n          break\n        }\n\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.carriageReturnLineFeed: {\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.cr + micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.lf\n\n          break\n        }\n\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.horizontalTab: {\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.ht\n\n          break\n        }\n\n        /* c8 ignore next 6 */\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.virtualSpace: {\n          if (atTab) continue\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.space\n\n          break\n        }\n\n        default: {\n          (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(typeof chunk === 'number', 'expected number')\n          // Currently only replacement character.\n          // eslint-disable-next-line unicorn/prefer-code-point\n          value = String.fromCharCode(chunk)\n        }\n      }\n\n    atTab = chunk === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.horizontalTab\n    result.push(value)\n  }\n\n  return result.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21pY3JvbWFyay11dGlsLWV2ZW50cy10by1hY29ybkAyLjAuMy9ub2RlX21vZHVsZXMvbWljcm9tYXJrLXV0aWwtZXZlbnRzLXRvLWFjb3JuL2Rldi9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0EsWUFBWSxtQ0FBbUM7QUFDL0MsWUFBWSw2QkFBNkI7QUFDekMsWUFBWSxrREFBa0Q7QUFDOUQsWUFBWSxxQkFBcUI7QUFDakM7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQyxZQUFZLHNDQUFzQztBQUNsRDs7QUFFbUM7QUFDSTtBQUNtQjtBQUNoQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQSxhQUFhLGNBQWM7QUFDM0Isc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx1REFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxJQUFJLDJDQUFNO0FBQ1Y7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q2xCO0FBQ0Esa0JBQWtCLHlEQUFNOztBQUV4QjtBQUNBOztBQUVBO0FBQ0EsVUFBVSwwQ0FBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQix3REFBSztBQUMzQjtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy91YW5lbGFfY29tby9Eb2N1bWVudHMvZGV2ZWxvcG1lbnQvbm9kZWpzL2Fya29zL25vZGVfbW9kdWxlcy8ucG5wbS9taWNyb21hcmstdXRpbC1ldmVudHMtdG8tYWNvcm5AMi4wLjMvbm9kZV9tb2R1bGVzL21pY3JvbWFyay11dGlsLWV2ZW50cy10by1hY29ybi9kZXYvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7Q29tbWVudCwgTm9kZSBhcyBBY29ybk5vZGUsIFRva2VufSBmcm9tICdhY29ybidcbiAqIEBpbXBvcnQge05vZGUgYXMgRXN0cmVlTm9kZSwgUHJvZ3JhbX0gZnJvbSAnZXN0cmVlJ1xuICogQGltcG9ydCB7Q2h1bmssIEV2ZW50LCBQb2ludCBhcyBNaWNyb21hcmtQb2ludCwgVG9rZW5UeXBlfSBmcm9tICdtaWNyb21hcmstdXRpbC10eXBlcydcbiAqIEBpbXBvcnQge1BvaW50IGFzIFVuaXN0UG9pbnR9IGZyb20gJ3VuaXN0J1xuICpcbiAqIEBpbXBvcnQge0Fjb3JuT3B0aW9ucywgT3B0aW9uc30gZnJvbSAnbWljcm9tYXJrLXV0aWwtZXZlbnRzLXRvLWFjb3JuJ1xuICogQGltcG9ydCB7QWNvcm5FcnJvciwgQ29sbGVjdGlvbiwgUmVzdWx0LCBTdG9wfSBmcm9tICcuL3R5cGVzLmpzJ1xuICovXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5pbXBvcnQge3Zpc2l0fSBmcm9tICdlc3RyZWUtdXRpbC12aXNpdCdcbmltcG9ydCB7Y29kZXMsIHR5cGVzLCB2YWx1ZXN9IGZyb20gJ21pY3JvbWFyay11dGlsLXN5bWJvbCdcbmltcG9ydCB7VkZpbGVNZXNzYWdlfSBmcm9tICd2ZmlsZS1tZXNzYWdlJ1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiBtaWNyb21hcmsgZXZlbnRzIHdpdGggYWNvcm4uXG4gKlxuICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICogICBFdmVudHMuXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbiAocmVxdWlyZWQpLlxuICogQHJldHVybnMge1Jlc3VsdH1cbiAqICAgUmVzdWx0LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50c1RvQWNvcm4oZXZlbnRzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHByZWZpeCA9IG9wdGlvbnMucHJlZml4IHx8ICcnXG4gIGNvbnN0IHN1ZmZpeCA9IG9wdGlvbnMuc3VmZml4IHx8ICcnXG4gIGNvbnN0IGFjb3JuT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuYWNvcm5PcHRpb25zKVxuICAvKiogQHR5cGUge0FycmF5PENvbW1lbnQ+fSAqL1xuICBjb25zdCBjb21tZW50cyA9IFtdXG4gIC8qKiBAdHlwZSB7QXJyYXk8VG9rZW4+fSAqL1xuICBjb25zdCB0b2tlbnMgPSBbXVxuICBjb25zdCBvbkNvbW1lbnQgPSBhY29ybk9wdGlvbnMub25Db21tZW50XG4gIGNvbnN0IG9uVG9rZW4gPSBhY29ybk9wdGlvbnMub25Ub2tlblxuICBsZXQgc3dhbGxvdyA9IGZhbHNlXG4gIC8qKiBAdHlwZSB7QWNvcm5Ob2RlIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgZXN0cmVlXG4gIC8qKiBAdHlwZSB7QWNvcm5FcnJvciB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IGV4Y2VwdGlvblxuICAvKiogQHR5cGUge0Fjb3JuT3B0aW9uc30gKi9cbiAgY29uc3QgYWNvcm5Db25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBhY29ybk9wdGlvbnMsIHtcbiAgICBvbkNvbW1lbnQ6IGNvbW1lbnRzLFxuICAgIHByZXNlcnZlUGFyZW5zOiB0cnVlXG4gIH0pXG5cbiAgaWYgKG9uVG9rZW4pIHtcbiAgICBhY29ybkNvbmZpZy5vblRva2VuID0gdG9rZW5zXG4gIH1cblxuICBjb25zdCBjb2xsZWN0aW9uID0gY29sbGVjdChldmVudHMsIG9wdGlvbnMudG9rZW5UeXBlcylcblxuICBjb25zdCBzb3VyY2UgPSBjb2xsZWN0aW9uLnZhbHVlXG5cbiAgY29uc3QgdmFsdWUgPSBwcmVmaXggKyBzb3VyY2UgKyBzdWZmaXhcbiAgY29uc3QgaXNFbXB0eUV4cHJlc3Npb24gPSBvcHRpb25zLmV4cHJlc3Npb24gJiYgZW1wdHkoc291cmNlKVxuXG4gIGlmIChpc0VtcHR5RXhwcmVzc2lvbiAmJiAhb3B0aW9ucy5hbGxvd0VtcHR5KSB7XG4gICAgdGhyb3cgbmV3IFZGaWxlTWVzc2FnZSgnVW5leHBlY3RlZCBlbXB0eSBleHByZXNzaW9uJywge1xuICAgICAgcGxhY2U6IHBhcnNlT2Zmc2V0VG9VbmlzdFBvaW50KDApLFxuICAgICAgcnVsZUlkOiAndW5leHBlY3RlZC1lbXB0eS1leHByZXNzaW9uJyxcbiAgICAgIHNvdXJjZTogJ21pY3JvbWFyay1leHRlbnNpb24tbWR4LWV4cHJlc3Npb24nXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgZXN0cmVlID1cbiAgICAgIG9wdGlvbnMuZXhwcmVzc2lvbiAmJiAhaXNFbXB0eUV4cHJlc3Npb25cbiAgICAgICAgPyBvcHRpb25zLmFjb3JuLnBhcnNlRXhwcmVzc2lvbkF0KHZhbHVlLCAwLCBhY29ybkNvbmZpZylcbiAgICAgICAgOiBvcHRpb25zLmFjb3JuLnBhcnNlKHZhbHVlLCBhY29ybkNvbmZpZylcbiAgfSBjYXRjaCAoZXJyb3JfKSB7XG4gICAgY29uc3QgZXJyb3IgPSAvKiogQHR5cGUge0Fjb3JuRXJyb3J9ICovIChlcnJvcl8pXG4gICAgY29uc3QgcG9pbnQgPSBwYXJzZU9mZnNldFRvVW5pc3RQb2ludChlcnJvci5wb3MpXG4gICAgZXJyb3IubWVzc2FnZSA9IFN0cmluZyhlcnJvci5tZXNzYWdlKS5yZXBsYWNlKC8gXFwoXFxkKzpcXGQrXFwpJC8sICcnKVxuICAgIC8vIEFsd2F5cyBkZWZpbmVkIGluIG91ciB1bmlzdCBwb2ludHMgdGhhdCBjb21lIGZyb20gbWljcm9tYXJrLlxuICAgIGFzc2VydChwb2ludC5vZmZzZXQgIT09IHVuZGVmaW5lZCwgJ2V4cGVjdGVkIGBvZmZzZXRgJylcbiAgICBlcnJvci5wb3MgPSBwb2ludC5vZmZzZXRcbiAgICBlcnJvci5sb2MgPSB7bGluZTogcG9pbnQubGluZSwgY29sdW1uOiBwb2ludC5jb2x1bW4gLSAxfVxuICAgIGV4Y2VwdGlvbiA9IGVycm9yXG4gICAgc3dhbGxvdyA9XG4gICAgICBlcnJvci5yYWlzZWRBdCA+PSBwcmVmaXgubGVuZ3RoICsgc291cmNlLmxlbmd0aCB8fFxuICAgICAgLy8gQnJva2VuIGNvbW1lbnRzIGFyZSByYWlzZWQgYXQgdGhlaXIgc3RhcnQsIG5vdCB0aGVpciBlbmQuXG4gICAgICBlcnJvci5tZXNzYWdlID09PSAnVW50ZXJtaW5hdGVkIGNvbW1lbnQnXG4gIH1cblxuICBpZiAoZXN0cmVlICYmIG9wdGlvbnMuZXhwcmVzc2lvbiAmJiAhaXNFbXB0eUV4cHJlc3Npb24pIHtcbiAgICBpZiAoZW1wdHkodmFsdWUuc2xpY2UoZXN0cmVlLmVuZCwgdmFsdWUubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkpKSB7XG4gICAgICBlc3RyZWUgPSB7XG4gICAgICAgIHR5cGU6ICdQcm9ncmFtJyxcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGVuZDogcHJlZml4Lmxlbmd0aCArIHNvdXJjZS5sZW5ndGgsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEl04oCZcyBnb29kLlxuICAgICAgICBib2R5OiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ0V4cHJlc3Npb25TdGF0ZW1lbnQnLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXN0cmVlLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IHByZWZpeC5sZW5ndGggKyBzb3VyY2UubGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzb3VyY2VUeXBlOiAnbW9kdWxlJyxcbiAgICAgICAgY29tbWVudHM6IFtdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcGFyc2VPZmZzZXRUb1VuaXN0UG9pbnQoZXN0cmVlLmVuZClcbiAgICAgIGNvbnN0IGVycm9yID0gLyoqIEB0eXBlIHtBY29ybkVycm9yfSAqLyAoXG4gICAgICAgIG5ldyBFcnJvcignVW5leHBlY3RlZCBjb250ZW50IGFmdGVyIGV4cHJlc3Npb24nKVxuICAgICAgKVxuICAgICAgLy8gQWx3YXlzIGRlZmluZWQgaW4gb3VyIHVuaXN0IHBvaW50cyB0aGF0IGNvbWUgZnJvbSBtaWNyb21hcmsuXG4gICAgICBhc3NlcnQocG9pbnQub2Zmc2V0ICE9PSB1bmRlZmluZWQsICdleHBlY3RlZCBgb2Zmc2V0YCcpXG4gICAgICBlcnJvci5wb3MgPSBwb2ludC5vZmZzZXRcbiAgICAgIGVycm9yLmxvYyA9IHtsaW5lOiBwb2ludC5saW5lLCBjb2x1bW46IHBvaW50LmNvbHVtbiAtIDF9XG4gICAgICBleGNlcHRpb24gPSBlcnJvclxuICAgICAgZXN0cmVlID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgaWYgKGVzdHJlZSkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGFjb3JuICpkb2VzKiBhbGxvdyBjb21tZW50c1xuICAgIGVzdHJlZS5jb21tZW50cyA9IGNvbW1lbnRzXG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBhY29ybiBsb29rcyBlbm91Z2ggbGlrZSBlc3RyZWUuXG4gICAgdmlzaXQoZXN0cmVlLCBmdW5jdGlvbiAoZXNub2RlLCBmaWVsZCwgaW5kZXgsIHBhcmVudHMpIHtcbiAgICAgIGxldCBjb250ZXh0ID0gLyoqIEB0eXBlIHtBY29ybk5vZGUgfCBBcnJheTxBY29ybk5vZGU+fSAqLyAoXG4gICAgICAgIHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXVxuICAgICAgKVxuICAgICAgLyoqIEB0eXBlIHtudW1iZXIgfCBzdHJpbmcgfCB1bmRlZmluZWR9ICovXG4gICAgICBsZXQgcHJvcGVydHkgPSBmaWVsZFxuXG4gICAgICAvLyBSZW1vdmUgbm9uLXN0YW5kYXJkIGBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbmAuXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbmNsdWRlZCBpbiBhY29ybi5cbiAgICAgIGlmIChlc25vZGUudHlwZSA9PT0gJ1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uJyAmJiBjb250ZXh0ICYmIHByb3BlcnR5KSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDUgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbmRleGFibGUuXG4gICAgICAgICAgY29udGV4dCA9IGNvbnRleHRbcHJvcGVydHldXG4gICAgICAgICAgcHJvcGVydHkgPSBpbmRleFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW5kZXhhYmxlLlxuICAgICAgICBjb250ZXh0W3Byb3BlcnR5XSA9IGVzbm9kZS5leHByZXNzaW9uXG4gICAgICB9XG5cbiAgICAgIGZpeFBvc2l0aW9uKGVzbm9kZSlcbiAgICB9KVxuXG4gICAgLy8gQ29tbWVudCBwb3NpdGlvbnMgYXJlIGZpeGVkIGJ5IGB2aXNpdGAgYmVjYXVzZSB0aGV54oCZcmUgaW4gdGhlIHRyZWUuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob25Db21tZW50KSkge1xuICAgICAgb25Db21tZW50LnB1c2goLi4uY29tbWVudHMpXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb25Db21tZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmb3IgKGNvbnN0IGNvbW1lbnQgb2YgY29tbWVudHMpIHtcbiAgICAgICAgYXNzZXJ0KGNvbW1lbnQubG9jLCAnZXhwZWN0ZWQgYGxvY2Agb24gY29tbWVudCcpXG4gICAgICAgIG9uQ29tbWVudChcbiAgICAgICAgICBjb21tZW50LnR5cGUgPT09ICdCbG9jaycsXG4gICAgICAgICAgY29tbWVudC52YWx1ZSxcbiAgICAgICAgICBjb21tZW50LnN0YXJ0LFxuICAgICAgICAgIGNvbW1lbnQuZW5kLFxuICAgICAgICAgIGNvbW1lbnQubG9jLnN0YXJ0LFxuICAgICAgICAgIGNvbW1lbnQubG9jLmVuZFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgIC8vIElnbm9yZSB0b2tlbnMgdGhhdCBlbmRzIGluIHByZWZpeCBvciBzdGFydCBpbiBzdWZmaXg6XG4gICAgICBpZiAoXG4gICAgICAgIHRva2VuLmVuZCA8PSBwcmVmaXgubGVuZ3RoIHx8XG4gICAgICAgIHRva2VuLnN0YXJ0IC0gcHJlZml4Lmxlbmd0aCA+PSBzb3VyY2UubGVuZ3RoXG4gICAgICApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgZml4UG9zaXRpb24odG9rZW4pXG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9uVG9rZW4pKSB7XG4gICAgICAgIG9uVG9rZW4ucHVzaCh0b2tlbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGB0b2tlbnNgIGFyZSBub3QgYWRkZWQgaWYgYG9uVG9rZW5gIGlzIG5vdCBkZWZpbmVkLCBzbyBpdCBtdXN0IGJlIGFcbiAgICAgICAgLy8gZnVuY3Rpb24uXG4gICAgICAgIGFzc2VydCh0eXBlb2Ygb25Ub2tlbiA9PT0gJ2Z1bmN0aW9uJywgJ2V4cGVjdGVkIGZ1bmN0aW9uJylcbiAgICAgICAgb25Ub2tlbih0b2tlbilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBJdOKAmXMgYSBwcm9ncmFtIG5vdy5cbiAgcmV0dXJuIHtlc3RyZWUsIGVycm9yOiBleGNlcHRpb24sIHN3YWxsb3d9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Fjb3JuTm9kZSB8IEVzdHJlZU5vZGUgfCBUb2tlbn0gbm9kZU9yVG9rZW5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGZ1bmN0aW9uIGZpeFBvc2l0aW9uKG5vZGVPclRva2VuKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgJ3N0YXJ0JyBpbiBub2RlT3JUb2tlbixcbiAgICAgICdleHBlY3RlZCBgc3RhcnRgIGluIG5vZGUgb3IgdG9rZW4gZnJvbSBhY29ybidcbiAgICApXG4gICAgYXNzZXJ0KCdlbmQnIGluIG5vZGVPclRva2VuLCAnZXhwZWN0ZWQgYGVuZGAgaW4gbm9kZSBvciB0b2tlbiBmcm9tIGFjb3JuJylcbiAgICBjb25zdCBwb2ludFN0YXJ0ID0gcGFyc2VPZmZzZXRUb1VuaXN0UG9pbnQobm9kZU9yVG9rZW4uc3RhcnQpXG4gICAgY29uc3QgcG9pbnRFbmQgPSBwYXJzZU9mZnNldFRvVW5pc3RQb2ludChub2RlT3JUb2tlbi5lbmQpXG4gICAgLy8gQWx3YXlzIGRlZmluZWQgaW4gb3VyIHVuaXN0IHBvaW50cyB0aGF0IGNvbWUgZnJvbSBtaWNyb21hcmsuXG4gICAgYXNzZXJ0KHBvaW50U3RhcnQub2Zmc2V0ICE9PSB1bmRlZmluZWQsICdleHBlY3RlZCBgb2Zmc2V0YCcpXG4gICAgYXNzZXJ0KHBvaW50RW5kLm9mZnNldCAhPT0gdW5kZWZpbmVkLCAnZXhwZWN0ZWQgYG9mZnNldGAnKVxuICAgIG5vZGVPclRva2VuLnN0YXJ0ID0gcG9pbnRTdGFydC5vZmZzZXRcbiAgICBub2RlT3JUb2tlbi5lbmQgPSBwb2ludEVuZC5vZmZzZXRcbiAgICBub2RlT3JUb2tlbi5sb2MgPSB7XG4gICAgICBzdGFydDoge1xuICAgICAgICBsaW5lOiBwb2ludFN0YXJ0LmxpbmUsXG4gICAgICAgIGNvbHVtbjogcG9pbnRTdGFydC5jb2x1bW4gLSAxLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBub3QgYWxsb3dlZCBieSBhY29ybiB0eXBlcy5cbiAgICAgICAgb2Zmc2V0OiBwb2ludFN0YXJ0Lm9mZnNldFxuICAgICAgfSxcbiAgICAgIGVuZDoge1xuICAgICAgICBsaW5lOiBwb2ludEVuZC5saW5lLFxuICAgICAgICBjb2x1bW46IHBvaW50RW5kLmNvbHVtbiAtIDEsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG5vdCBhbGxvd2VkIGJ5IGFjb3JuIHR5cGVzLlxuICAgICAgICBvZmZzZXQ6IHBvaW50RW5kLm9mZnNldFxuICAgICAgfVxuICAgIH1cbiAgICBub2RlT3JUb2tlbi5yYW5nZSA9IFtub2RlT3JUb2tlbi5zdGFydCwgbm9kZU9yVG9rZW4uZW5kXVxuICB9XG5cbiAgLyoqXG4gICAqIFR1cm4gYW4gYXJiaXRyYXJ5IG9mZnNldCBpbnRvIHRoZSBwYXJzZWQgdmFsdWUsIGludG8gYSBwb2ludCBpbiB0aGUgc291cmNlXG4gICAqIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYWNvcm5PZmZzZXRcbiAgICogQHJldHVybnMge1VuaXN0UG9pbnR9XG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZU9mZnNldFRvVW5pc3RQb2ludChhY29ybk9mZnNldCkge1xuICAgIGxldCBzb3VyY2VPZmZzZXQgPSBhY29ybk9mZnNldCAtIHByZWZpeC5sZW5ndGhcblxuICAgIGlmIChzb3VyY2VPZmZzZXQgPCAwKSB7XG4gICAgICBzb3VyY2VPZmZzZXQgPSAwXG4gICAgfSBlbHNlIGlmIChzb3VyY2VPZmZzZXQgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICBzb3VyY2VPZmZzZXQgPSBzb3VyY2UubGVuZ3RoXG4gICAgfVxuXG4gICAgbGV0IHBvaW50ID0gcmVsYXRpdmVUb1BvaW50KGNvbGxlY3Rpb24uc3RvcHMsIHNvdXJjZU9mZnNldClcblxuICAgIGlmICghcG9pbnQpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgb3B0aW9ucy5zdGFydCxcbiAgICAgICAgJ2VtcHR5IGV4cHJlc3Npb25zIGFyZSBuZWVkIGBvcHRpb25zLnN0YXJ0YCBiZWluZyBwYXNzZWQnXG4gICAgICApXG4gICAgICBwb2ludCA9IHtcbiAgICAgICAgbGluZTogb3B0aW9ucy5zdGFydC5saW5lLFxuICAgICAgICBjb2x1bW46IG9wdGlvbnMuc3RhcnQuY29sdW1uLFxuICAgICAgICBvZmZzZXQ6IG9wdGlvbnMuc3RhcnQub2Zmc2V0XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBlbXB0eSh2YWx1ZSkge1xuICByZXR1cm4gL15cXHMqJC8udGVzdChcbiAgICB2YWx1ZVxuICAgICAgLy8gTXVsdGlsaW5lIGNvbW1lbnRzLlxuICAgICAgLnJlcGxhY2UoL1xcL1xcKltcXHNcXFNdKj9cXCpcXC8vZywgJycpXG4gICAgICAvLyBMaW5lIGNvbW1lbnRzLlxuICAgICAgLy8gRU9GIGluc3RlYWQgb2YgRU9MIGlzIHNwZWNpZmljYWxseSBub3QgYWxsb3dlZCwgYmVjYXVzZSB0aGF0IHdvdWxkXG4gICAgICAvLyBtZWFuIHRoZSBjbG9zaW5nIGJyYWNlIGlzIG9uIHRoZSBjb21tZW50ZWQtb3V0IGxpbmVcbiAgICAgIC5yZXBsYWNlKC9cXC9cXC9bXlxcclxcbl0qKFxcclxcbnxcXG58XFxyKS9nLCAnJylcbiAgKVxufVxuXG4vLyBQb3J0IGZyb20gPGh0dHBzOi8vZ2l0aHViLmNvbS93b29vcm0vbWFya2Rvd24tcnMvYmxvYi9lNjkyYWIwL3NyYy91dGlsL21keF9jb2xsZWN0LnJzI0wxNT4uXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBldmVudHNcbiAqIEBwYXJhbSB7QXJyYXk8VG9rZW5UeXBlPn0gdG9rZW5UeXBlc1xuICogQHJldHVybnMge0NvbGxlY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3QoZXZlbnRzLCB0b2tlblR5cGVzKSB7XG4gIC8qKiBAdHlwZSB7Q29sbGVjdGlvbn0gKi9cbiAgY29uc3QgcmVzdWx0ID0ge3ZhbHVlOiAnJywgc3RvcHM6IFtdfVxuICBsZXQgaW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK2luZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzW2luZGV4XVxuXG4gICAgLy8gQXNzdW1lIHZvaWQuXG4gICAgaWYgKGV2ZW50WzBdID09PSAnZW50ZXInKSB7XG4gICAgICBjb25zdCB0eXBlID0gZXZlbnRbMV0udHlwZVxuXG4gICAgICBpZiAodHlwZSA9PT0gdHlwZXMubGluZUVuZGluZyB8fCB0b2tlblR5cGVzLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgIGNvbnN0IGNodW5rcyA9IGV2ZW50WzJdLnNsaWNlU3RyZWFtKGV2ZW50WzFdKVxuXG4gICAgICAgIC8vIERyb3AgdmlydHVhbCBzcGFjZXMuXG4gICAgICAgIHdoaWxlIChjaHVua3MubGVuZ3RoID4gMCAmJiBjaHVua3NbMF0gPT09IGNvZGVzLnZpcnR1YWxTcGFjZSkge1xuICAgICAgICAgIGNodW5rcy5zaGlmdCgpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZSA9IHNlcmlhbGl6ZUNodW5rcyhjaHVua3MpXG4gICAgICAgIHJlc3VsdC5zdG9wcy5wdXNoKFtyZXN1bHQudmFsdWUubGVuZ3RoLCBldmVudFsxXS5zdGFydF0pXG4gICAgICAgIHJlc3VsdC52YWx1ZSArPSB2YWx1ZVxuICAgICAgICByZXN1bHQuc3RvcHMucHVzaChbcmVzdWx0LnZhbHVlLmxlbmd0aCwgZXZlbnRbMV0uZW5kXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIFBvcnQgZnJvbSA8aHR0cHM6Ly9naXRodWIuY29tL3dvb29ybS9tYXJrZG93bi1ycy9ibG9iL2U2OTJhYjAvc3JjL3V0aWwvbG9jYXRpb24ucnMjTDkxPi5cbi8qKlxuICogVHVybiBhIHJlbGF0aXZlIG9mZnNldCBpbnRvIGFuIGFic29sdXRlIG9mZnNldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFN0b3A+fSBzdG9wc1xuICogQHBhcmFtIHtudW1iZXJ9IHJlbGF0aXZlXG4gKiBAcmV0dXJucyB7VW5pc3RQb2ludCB8IHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gcmVsYXRpdmVUb1BvaW50KHN0b3BzLCByZWxhdGl2ZSkge1xuICBsZXQgaW5kZXggPSAwXG5cbiAgd2hpbGUgKGluZGV4IDwgc3RvcHMubGVuZ3RoICYmIHN0b3BzW2luZGV4XVswXSA8PSByZWxhdGl2ZSkge1xuICAgIGluZGV4ICs9IDFcbiAgfVxuXG4gIC8vIFRoZXJlIGFyZSBubyBwb2ludHM6IHRoYXQgb25seSBvY2N1cnMgaWYgdGhlcmUgd2FzIGFuIGVtcHR5IHN0cmluZy5cbiAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgY29uc3QgW3N0b3BSZWxhdGl2ZSwgc3RvcEFic29sdXRlXSA9IHN0b3BzW2luZGV4IC0gMV1cbiAgY29uc3QgcmVzdCA9IHJlbGF0aXZlIC0gc3RvcFJlbGF0aXZlXG4gIHJldHVybiB7XG4gICAgbGluZTogc3RvcEFic29sdXRlLmxpbmUsXG4gICAgY29sdW1uOiBzdG9wQWJzb2x1dGUuY29sdW1uICsgcmVzdCxcbiAgICBvZmZzZXQ6IHN0b3BBYnNvbHV0ZS5vZmZzZXQgKyByZXN0XG4gIH1cbn1cblxuLy8gQ29weSBmcm9tIDxodHRwczovL2dpdGh1Yi5jb20vbWljcm9tYXJrL21pY3JvbWFyay9ibG9iL2NlMzU5M2EvcGFja2FnZXMvbWljcm9tYXJrL2Rldi9saWIvY3JlYXRlLXRva2VuaXplci5qcyNMNTk1PlxuLy8gVG8gZG86IGV4cG9zZSB0aGF0P1xuLyoqXG4gKiBHZXQgdGhlIHN0cmluZyB2YWx1ZSBvZiBhIHNsaWNlIG9mIGNodW5rcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PENodW5rPn0gY2h1bmtzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVDaHVua3MoY2h1bmtzKSB7XG4gIGxldCBpbmRleCA9IC0xXG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3QgcmVzdWx0ID0gW11cbiAgLyoqIEB0eXBlIHtib29sZWFuIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgYXRUYWJcblxuICB3aGlsZSAoKytpbmRleCA8IGNodW5rcy5sZW5ndGgpIHtcbiAgICBjb25zdCBjaHVuayA9IGNodW5rc1tpbmRleF1cbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBsZXQgdmFsdWVcblxuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IGNodW5rXG4gICAgfSBlbHNlXG4gICAgICBzd2l0Y2ggKGNodW5rKSB7XG4gICAgICAgIGNhc2UgY29kZXMuY2FycmlhZ2VSZXR1cm46IHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5jclxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgY29kZXMubGluZUZlZWQ6IHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5sZlxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgY29kZXMuY2FycmlhZ2VSZXR1cm5MaW5lRmVlZDoge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmNyICsgdmFsdWVzLmxmXG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBjb2Rlcy5ob3Jpem9udGFsVGFiOiB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuaHRcblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCA2ICovXG4gICAgICAgIGNhc2UgY29kZXMudmlydHVhbFNwYWNlOiB7XG4gICAgICAgICAgaWYgKGF0VGFiKSBjb250aW51ZVxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLnNwYWNlXG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGFzc2VydCh0eXBlb2YgY2h1bmsgPT09ICdudW1iZXInLCAnZXhwZWN0ZWQgbnVtYmVyJylcbiAgICAgICAgICAvLyBDdXJyZW50bHkgb25seSByZXBsYWNlbWVudCBjaGFyYWN0ZXIuXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWNvZGUtcG9pbnRcbiAgICAgICAgICB2YWx1ZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2h1bmspXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGF0VGFiID0gY2h1bmsgPT09IGNvZGVzLmhvcml6b250YWxUYWJcbiAgICByZXN1bHQucHVzaCh2YWx1ZSlcbiAgfVxuXG4gIHJldHVybiByZXN1bHQuam9pbignJylcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/micromark-util-events-to-acorn@2.0.3/node_modules/micromark-util-events-to-acorn/dev/lib/index.js\n");

/***/ })

};
;