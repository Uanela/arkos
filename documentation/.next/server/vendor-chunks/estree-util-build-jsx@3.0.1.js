"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/estree-util-build-jsx@3.0.1";
exports.ids = ["vendor-chunks/estree-util-build-jsx@3.0.1"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/estree-util-build-jsx@3.0.1/node_modules/estree-util-build-jsx/lib/index.js":
/*!*********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/estree-util-build-jsx@3.0.1/node_modules/estree-util-build-jsx/lib/index.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildJsx: () => (/* binding */ buildJsx)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devlop */ \"(rsc)/../node_modules/.pnpm/devlop@1.1.0/node_modules/devlop/lib/development.js\");\n/* harmony import */ var estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! estree-util-is-identifier-name */ \"(rsc)/../node_modules/.pnpm/estree-util-is-identifier-name@3.0.0/node_modules/estree-util-is-identifier-name/lib/index.js\");\n/* harmony import */ var estree_walker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! estree-walker */ \"(rsc)/../node_modules/.pnpm/estree-walker@3.0.3/node_modules/estree-walker/src/index.js\");\n/**\n * @typedef {import('estree-jsx').Expression} Expression\n * @typedef {import('estree-jsx').Identifier} Identifier\n * @typedef {import('estree-jsx').ImportSpecifier} ImportSpecifier\n * @typedef {import('estree-jsx').JSXAttribute} JSXAttribute\n * @typedef {import('estree-jsx').JSXIdentifier} JSXIdentifier\n * @typedef {import('estree-jsx').JSXMemberExpression} JSXMemberExpression\n * @typedef {import('estree-jsx').JSXNamespacedName} JSXNamespacedName\n * @typedef {import('estree-jsx').Literal} Literal\n * @typedef {import('estree-jsx').MemberExpression} MemberExpression\n * @typedef {import('estree-jsx').Node} Node\n * @typedef {import('estree-jsx').ObjectExpression} ObjectExpression\n * @typedef {import('estree-jsx').Property} Property\n * @typedef {import('estree-jsx').SpreadElement} SpreadElement\n *\n * @typedef {'automatic' | 'classic'} Runtime\n *   How to transform JSX.\n *\n * @typedef Options\n *   Configuration.\n *\n *   > ðŸ‘‰ **Note**: you can also configure `runtime`, `importSource`, `pragma`,\n *   > and `pragmaFrag` from within files through comments.\n * @property {Runtime | null | undefined} [runtime='classic']\n *   Choose the runtime (default: `'classic'`).\n *\n *   Comment form: `@jsxRuntime theRuntime`.\n * @property {string | null | undefined} [importSource='react']\n *   Place to import `jsx`, `jsxs`, `jsxDEV`, and `Fragment` from, when the\n *   effective runtime is automatic (default: `'react'`).\n *\n *   Comment form: `@jsxImportSource theSource`.\n *\n *   > ðŸ‘‰ **Note**: `/jsx-runtime` or `/jsx-dev-runtime` is appended to this\n *   > provided source.\n *   > In CJS, that can resolve to a file (as in `theSource/jsx-runtime.js`),\n *   > but for ESM an export map needs to be set up to point to files:\n *   >\n *   > ```js\n *   > // â€¦\n *   > \"exports\": {\n *   >   // â€¦\n *   >   \"./jsx-runtime\": \"./path/to/jsx-runtime.js\",\n *   >   \"./jsx-dev-runtime\": \"./path/to/jsx-runtime.js\"\n *   >   // â€¦\n *   > ```\n * @property {string | null | undefined} [pragma='React.createElement']\n *   Identifier or member expression to call when the effective runtime is\n *   classic (default: `'React.createElement'`).\n *\n *   Comment form: `@jsx identifier`.\n * @property {string | null | undefined} [pragmaFrag='React.Fragment']\n *   Identifier or member expression to use as a symbol for fragments when the\n *   effective runtime is classic (default: `'React.Fragment'`).\n *\n *   Comment form: `@jsxFrag identifier`.\n * @property {boolean | null | undefined} [development=false]\n *   When in the automatic runtime, whether to import\n *   `theSource/jsx-dev-runtime.js`, use `jsxDEV`, and pass location info when\n *   available (default: `false`).\n *\n *   This helps debugging but adds a lot of code that you donâ€™t want in\n *   production.\n * @property {string | null | undefined} [filePath]\n *   File path to the original source file (optional).\n *\n *   Passed in location info to `jsxDEV` when using the automatic runtime with\n *   `development: true`.\n *\n * @typedef Annotations\n *   State where info from comments is gathered.\n * @property {string | undefined} [jsx]\n *   JSX identifier (`pragma`).\n * @property {string | undefined} [jsxFrag]\n *   JSX identifier of fragment (`pragmaFrag`).\n * @property {string | undefined} [jsxImportSource]\n *   Where to import an automatic JSX runtime from.\n * @property {Runtime | undefined} [jsxRuntime]\n *   Runtime.\n *\n * @typedef Imports\n *   State of used identifiers from the automatic runtime.\n * @property {boolean | undefined} [fragment]\n *   Symbol of `Fragment`.\n * @property {boolean | undefined} [jsx]\n *   Symbol of `jsx`.\n * @property {boolean | undefined} [jsxs]\n *   Symbol of `jsxs`.\n * @property {boolean | undefined} [jsxDEV]\n *   Symbol of `jsxDEV`.\n */\n\n\n\n\n\nconst regex = /@(jsx|jsxFrag|jsxImportSource|jsxRuntime)\\s+(\\S+)/g\n\n/**\n * Turn JSX in `tree` into function calls: `<x />` -> `h('x')`!\n *\n * ###### Algorithm\n *\n * In almost all cases, this utility is the same as the Babel plugin, except that\n * they work on slightly different syntax trees.\n *\n * Some differences:\n *\n * *   no pure annotations things\n * *   `this` is not a component: `<this>` -> `h('this')`, not `h(this)`\n * *   namespaces are supported: `<a:b c:d>` -> `h('a:b', {'c:d': true})`,\n *     which throws by default in Babel or can be turned on with `throwIfNamespace`\n * *   no `useSpread`, `useBuiltIns`, or `filter` options\n *\n * @param {Node} tree\n *   Tree to transform (typically `Program`).\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nfunction buildJsx(tree, options) {\n  const config = options || {}\n  let automatic = config.runtime === 'automatic'\n  /** @type {Annotations} */\n  const annotations = {}\n  /** @type {Imports} */\n  const imports = {}\n\n  ;(0,estree_walker__WEBPACK_IMPORTED_MODULE_0__.walk)(tree, {\n    enter(node) {\n      if (node.type === 'Program') {\n        const comments = node.comments || []\n        let index = -1\n\n        while (++index < comments.length) {\n          regex.lastIndex = 0\n\n          let match = regex.exec(comments[index].value)\n\n          while (match) {\n            // @ts-expect-error: `match[1]` is always a key, `match[2]` when\n            // runtime is checked later.\n            annotations[match[1]] = match[2]\n            match = regex.exec(comments[index].value)\n          }\n        }\n\n        if (annotations.jsxRuntime) {\n          if (annotations.jsxRuntime === 'automatic') {\n            automatic = true\n\n            if (annotations.jsx) {\n              throw new Error('Unexpected `@jsx` pragma w/ automatic runtime')\n            }\n\n            if (annotations.jsxFrag) {\n              throw new Error(\n                'Unexpected `@jsxFrag` pragma w/ automatic runtime'\n              )\n            }\n          } else if (annotations.jsxRuntime === 'classic') {\n            automatic = false\n\n            if (annotations.jsxImportSource) {\n              throw new Error(\n                'Unexpected `@jsxImportSource` w/ classic runtime'\n              )\n            }\n          } else {\n            throw new Error(\n              'Unexpected `jsxRuntime` `' +\n                annotations.jsxRuntime +\n                '`, expected `automatic` or `classic`'\n            )\n          }\n        }\n      }\n    },\n    // eslint-disable-next-line complexity\n    leave(node) {\n      if (node.type === 'Program') {\n        /** @type {Array<ImportSpecifier>} */\n        const specifiers = []\n\n        if (imports.fragment) {\n          specifiers.push({\n            type: 'ImportSpecifier',\n            imported: {type: 'Identifier', name: 'Fragment'},\n            local: {type: 'Identifier', name: '_Fragment'}\n          })\n        }\n\n        if (imports.jsx) {\n          specifiers.push({\n            type: 'ImportSpecifier',\n            imported: {type: 'Identifier', name: 'jsx'},\n            local: {type: 'Identifier', name: '_jsx'}\n          })\n        }\n\n        if (imports.jsxs) {\n          specifiers.push({\n            type: 'ImportSpecifier',\n            imported: {type: 'Identifier', name: 'jsxs'},\n            local: {type: 'Identifier', name: '_jsxs'}\n          })\n        }\n\n        if (imports.jsxDEV) {\n          specifiers.push({\n            type: 'ImportSpecifier',\n            imported: {type: 'Identifier', name: 'jsxDEV'},\n            local: {type: 'Identifier', name: '_jsxDEV'}\n          })\n        }\n\n        if (specifiers.length > 0) {\n          let injectIndex = 0\n\n          while (injectIndex < node.body.length) {\n            const child = node.body[injectIndex]\n\n            if ('directive' in child && child.directive) {\n              injectIndex++\n            } else {\n              break\n            }\n          }\n\n          node.body.splice(injectIndex, 0, {\n            type: 'ImportDeclaration',\n            specifiers,\n            source: {\n              type: 'Literal',\n              value:\n                (annotations.jsxImportSource ||\n                  config.importSource ||\n                  'react') +\n                (config.development ? '/jsx-dev-runtime' : '/jsx-runtime')\n            }\n          })\n        }\n      }\n\n      if (node.type !== 'JSXElement' && node.type !== 'JSXFragment') {\n        return\n      }\n\n      /** @type {Array<Expression>} */\n      const children = []\n      let index = -1\n\n      // Figure out `children`.\n      while (++index < node.children.length) {\n        const child = node.children[index]\n\n        if (child.type === 'JSXExpressionContainer') {\n          // Ignore empty expressions.\n          if (child.expression.type !== 'JSXEmptyExpression') {\n            children.push(child.expression)\n          }\n        } else if (child.type === 'JSXText') {\n          const value = child.value\n            // Replace tabs w/ spaces.\n            .replace(/\\t/g, ' ')\n            // Use line feeds, drop spaces around them.\n            .replace(/ *(\\r?\\n|\\r) */g, '\\n')\n            // Collapse multiple line feeds.\n            .replace(/\\n+/g, '\\n')\n            // Drop final line feeds.\n            .replace(/\\n+$/, '')\n            // Drop first line feeds.\n            .replace(/^\\n+/, '')\n            // Replace line feeds with spaces.\n            .replace(/\\n/g, ' ')\n\n          // Ignore collapsible text.\n          if (value) {\n            /** @type {Node} */\n            const text = {type: 'Literal', value}\n            create(child, text)\n            children.push(text)\n          }\n        } else {\n          (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n            child.type !== 'JSXElement' &&\n              child.type !== 'JSXFragment' &&\n              child.type !== 'JSXSpreadChild'\n          )\n          children.push(child)\n        }\n      }\n\n      /** @type {Identifier | Literal | MemberExpression} */\n      let name\n      /** @type {Array<Property | SpreadElement>} */\n      const fields = []\n      /** @type {Array<Expression>} */\n      let parameters = []\n      /** @type {Expression | undefined} */\n      let key\n\n      // Do the stuff needed for elements.\n      if (node.type === 'JSXElement') {\n        name = toIdentifier(node.openingElement.name)\n\n        // If the name could be an identifier, but start with a lowercase letter,\n        // itâ€™s not a component.\n        if (name.type === 'Identifier' && /^[a-z]/.test(name.name)) {\n          /** @type {Node} */\n          const next = {type: 'Literal', value: name.name}\n          create(name, next)\n          name = next\n        }\n\n        /** @type {boolean | undefined} */\n        let spread\n        const attributes = node.openingElement.attributes\n        let index = -1\n\n        // Place props in the right order, because we might have duplicates\n        // in them and whatâ€™s spread in.\n        while (++index < attributes.length) {\n          const attribute = attributes[index]\n\n          if (attribute.type === 'JSXSpreadAttribute') {\n            if (attribute.argument.type === 'ObjectExpression') {\n              fields.push(...attribute.argument.properties)\n            } else {\n              fields.push({type: 'SpreadElement', argument: attribute.argument})\n            }\n\n            spread = true\n          } else {\n            const prop = toProperty(attribute)\n\n            if (\n              automatic &&\n              prop.key.type === 'Identifier' &&\n              prop.key.name === 'key'\n            ) {\n              if (spread) {\n                throw new Error(\n                  'Expected `key` to come before any spread expressions'\n                )\n              }\n\n              const value = prop.value\n\n              ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n                value.type !== 'AssignmentPattern' &&\n                  value.type !== 'ArrayPattern' &&\n                  value.type !== 'ObjectPattern' &&\n                  value.type !== 'RestElement'\n              )\n\n              key = value\n            } else {\n              fields.push(prop)\n            }\n          }\n        }\n      }\n      // â€¦and fragments.\n      else if (automatic) {\n        imports.fragment = true\n        name = {type: 'Identifier', name: '_Fragment'}\n      } else {\n        name = toMemberExpression(\n          annotations.jsxFrag || config.pragmaFrag || 'React.Fragment'\n        )\n      }\n\n      if (automatic) {\n        if (children.length > 0) {\n          fields.push({\n            type: 'Property',\n            key: {type: 'Identifier', name: 'children'},\n            value:\n              children.length > 1\n                ? {type: 'ArrayExpression', elements: children}\n                : children[0],\n            kind: 'init',\n            method: false,\n            shorthand: false,\n            computed: false\n          })\n        }\n      } else {\n        parameters = children\n      }\n\n      /** @type {Identifier | Literal | MemberExpression} */\n      let callee\n\n      if (automatic) {\n        parameters.push({type: 'ObjectExpression', properties: fields})\n\n        if (key) {\n          parameters.push(key)\n        } else if (config.development) {\n          parameters.push({type: 'Identifier', name: 'undefined'})\n        }\n\n        const isStaticChildren = children.length > 1\n\n        if (config.development) {\n          imports.jsxDEV = true\n          callee = {\n            type: 'Identifier',\n            name: '_jsxDEV'\n          }\n          parameters.push({type: 'Literal', value: isStaticChildren})\n\n          /** @type {ObjectExpression} */\n          const source = {\n            type: 'ObjectExpression',\n            properties: [\n              {\n                type: 'Property',\n                method: false,\n                shorthand: false,\n                computed: false,\n                kind: 'init',\n                key: {type: 'Identifier', name: 'fileName'},\n                value: {\n                  type: 'Literal',\n                  value: config.filePath || '<source.js>'\n                }\n              }\n            ]\n          }\n\n          if (node.loc) {\n            source.properties.push(\n              {\n                type: 'Property',\n                method: false,\n                shorthand: false,\n                computed: false,\n                kind: 'init',\n                key: {type: 'Identifier', name: 'lineNumber'},\n                value: {type: 'Literal', value: node.loc.start.line}\n              },\n              {\n                type: 'Property',\n                method: false,\n                shorthand: false,\n                computed: false,\n                kind: 'init',\n                key: {type: 'Identifier', name: 'columnNumber'},\n                value: {type: 'Literal', value: node.loc.start.column + 1}\n              }\n            )\n          }\n\n          parameters.push(source, {type: 'ThisExpression'})\n        } else if (isStaticChildren) {\n          imports.jsxs = true\n          callee = {type: 'Identifier', name: '_jsxs'}\n        } else {\n          imports.jsx = true\n          callee = {type: 'Identifier', name: '_jsx'}\n        }\n      }\n      // Classic.\n      else {\n        if (fields.length > 0) {\n          parameters.unshift({type: 'ObjectExpression', properties: fields})\n        } else if (parameters.length > 0) {\n          parameters.unshift({type: 'Literal', value: null})\n        }\n\n        callee = toMemberExpression(\n          annotations.jsx || config.pragma || 'React.createElement'\n        )\n      }\n\n      parameters.unshift(name)\n      /** @type {Node} */\n      const call = {\n        type: 'CallExpression',\n        callee,\n        arguments: parameters,\n        optional: false\n      }\n      create(node, call)\n      this.replace(call)\n    }\n  })\n}\n\n/**\n * Turn a JSX attribute into a JavaScript property.\n *\n * @param {JSXAttribute} node\n *   JSX attribute.\n * @returns {Property}\n *   JS property.\n */\nfunction toProperty(node) {\n  /** @type {Expression} */\n  let value\n\n  if (node.value) {\n    if (node.value.type === 'JSXExpressionContainer') {\n      const valueExpression = node.value.expression\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n        valueExpression.type !== 'JSXEmptyExpression',\n        '`JSXEmptyExpression` is not allowed in props.'\n      )\n      value = valueExpression\n    }\n    // Literal or call expression.\n    else {\n      const nodeValue = node.value\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n        nodeValue.type !== 'JSXElement' && nodeValue.type !== 'JSXFragment',\n        'JSX{Element,Fragment} are already compiled to `CallExpression`'\n      )\n      value = nodeValue\n      delete value.raw\n    }\n  }\n  // Boolean prop.\n  else {\n    value = {type: 'Literal', value: true}\n  }\n\n  /** @type {Property} */\n  const replacement = {\n    type: 'Property',\n    key: toIdentifier(node.name),\n    value,\n    kind: 'init',\n    method: false,\n    shorthand: false,\n    computed: false\n  }\n  create(node, replacement)\n  return replacement\n}\n\n/**\n * Turn a JSX identifier into a normal JS identifier.\n *\n * @param {JSXIdentifier | JSXMemberExpression | JSXNamespacedName} node\n *   JSX identifier.\n * @returns {Identifier | Literal | MemberExpression}\n *   JS identifier.\n */\nfunction toIdentifier(node) {\n  /** @type {Identifier | Literal | MemberExpression} */\n  let replace\n\n  if (node.type === 'JSXMemberExpression') {\n    // `property` is always a `JSXIdentifier`, but it could be something that\n    // isnâ€™t an ES identifier name.\n    const id = toIdentifier(node.property)\n    replace = {\n      type: 'MemberExpression',\n      object: toIdentifier(node.object),\n      property: id,\n      computed: id.type === 'Literal',\n      optional: false\n    }\n  } else if (node.type === 'JSXNamespacedName') {\n    replace = {\n      type: 'Literal',\n      value: node.namespace.name + ':' + node.name.name\n    }\n  }\n  // Must be `JSXIdentifier`.\n  else {\n    replace = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__.name)(node.name)\n      ? {type: 'Identifier', name: node.name}\n      : {type: 'Literal', value: node.name}\n  }\n\n  create(node, replace)\n  return replace\n}\n\n/**\n * Turn a dotted string into a member expression.\n *\n * @param {string} id\n *   Identifiers.\n * @returns {Identifier | Literal | MemberExpression}\n *   Expression.\n */\nfunction toMemberExpression(id) {\n  const identifiers = id.split('.')\n  let index = -1\n  /** @type {Identifier | Literal | MemberExpression | undefined} */\n  let result\n\n  while (++index < identifiers.length) {\n    /** @type {Identifier | Literal} */\n    const prop = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_2__.name)(identifiers[index])\n      ? {type: 'Identifier', name: identifiers[index]}\n      : {type: 'Literal', value: identifiers[index]}\n    result = result\n      ? {\n          type: 'MemberExpression',\n          object: result,\n          property: prop,\n          computed: Boolean(index && prop.type === 'Literal'),\n          optional: false\n        }\n      : prop\n  }\n\n  (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(result, 'always a result')\n  return result\n}\n\n/**\n * Inherit some fields from `from` into `to`.\n *\n * @param {Node} from\n *   Node to inherit from.\n * @param {Node} to\n *   Node to add to.\n * @returns {undefined}\n *   Nothing.\n */\nfunction create(from, to) {\n  const fields = ['start', 'end', 'loc', 'range', 'comments']\n  let index = -1\n\n  while (++index < fields.length) {\n    const field = fields[index]\n    if (field in from) {\n      // @ts-expect-error: indexable.\n      to[field] = from[field]\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2VzdHJlZS11dGlsLWJ1aWxkLWpzeEAzLjAuMS9ub2RlX21vZHVsZXMvZXN0cmVlLXV0aWwtYnVpbGQtanN4L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQSxhQUFhLGlDQUFpQztBQUM5QyxhQUFhLGlDQUFpQztBQUM5QyxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLG1DQUFtQztBQUNoRCxhQUFhLG9DQUFvQztBQUNqRCxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLHdDQUF3QztBQUNyRCxhQUFhLDhCQUE4QjtBQUMzQyxhQUFhLHVDQUF1QztBQUNwRCxhQUFhLDJCQUEyQjtBQUN4QyxhQUFhLHVDQUF1QztBQUNwRCxhQUFhLCtCQUErQjtBQUM1QyxhQUFhLG9DQUFvQztBQUNqRDtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBOztBQUVtQztBQUNvQztBQUNyQzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFlBQVk7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBLGFBQWEsU0FBUztBQUN0Qjs7QUFFQSxFQUFFLG9EQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFDQUFxQztBQUM1RCxvQkFBb0I7QUFDcEIsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0M7QUFDdkQsb0JBQW9CO0FBQ3BCLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hELG9CQUFvQjtBQUNwQixXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1DQUFtQztBQUMxRCxvQkFBb0I7QUFDcEIsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07QUFDN0IsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVLDBDQUFNO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix5Q0FBeUM7QUFDMUQ7QUFDQSxpQkFBaUIsaUNBQWlDO0FBQ2xEO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixNQUFNO0FBQzNCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLDJCQUEyQixvREFBb0Q7QUFDL0U7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYywyQ0FBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFDQUFxQztBQUN2RDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxpQkFBaUIseUNBQXlDO0FBQzFEOztBQUVBO0FBQ0EseUJBQXlCLDZDQUE2Qzs7QUFFdEU7QUFDQTtBQUNBLFVBQVU7QUFDViwyQkFBMkIsc0NBQXNDO0FBQ2pFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5Q0FBeUM7O0FBRXBFLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFDQUFxQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVDQUF1QztBQUM3RCx3QkFBd0I7QUFDeEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5Q0FBeUM7QUFDL0Qsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsdUJBQXVCO0FBQzFELFVBQVU7QUFDVjtBQUNBLG9CQUFvQjtBQUNwQixVQUFVO0FBQ1Y7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2Q0FBNkM7QUFDM0UsVUFBVTtBQUNWLDhCQUE4Qiw2QkFBNkI7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDJDQUFNO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMkNBQU07QUFDWjtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5REFBeUQ7QUFDcEU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5Q0FBeUM7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0VBQWdCO0FBQzlCLFNBQVM7QUFDVCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxREFBcUQ7QUFDbEU7O0FBRUE7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQyxpQkFBaUIsb0VBQWdCO0FBQ2pDLFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSwwQ0FBTTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3VhbmVsYV9jb21vL0RvY3VtZW50cy9kZXZlbG9wbWVudC9ub2RlanMvYXJrb3Mvbm9kZV9tb2R1bGVzLy5wbnBtL2VzdHJlZS11dGlsLWJ1aWxkLWpzeEAzLjAuMS9ub2RlX21vZHVsZXMvZXN0cmVlLXV0aWwtYnVpbGQtanN4L2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5FeHByZXNzaW9ufSBFeHByZXNzaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuSWRlbnRpZmllcn0gSWRlbnRpZmllclxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLkltcG9ydFNwZWNpZmllcn0gSW1wb3J0U3BlY2lmaWVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuSlNYQXR0cmlidXRlfSBKU1hBdHRyaWJ1dGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5KU1hJZGVudGlmaWVyfSBKU1hJZGVudGlmaWVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuSlNYTWVtYmVyRXhwcmVzc2lvbn0gSlNYTWVtYmVyRXhwcmVzc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLkpTWE5hbWVzcGFjZWROYW1lfSBKU1hOYW1lc3BhY2VkTmFtZVxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLkxpdGVyYWx9IExpdGVyYWxcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5NZW1iZXJFeHByZXNzaW9ufSBNZW1iZXJFeHByZXNzaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdlc3RyZWUtanN4JykuTm9kZX0gTm9kZVxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlLWpzeCcpLk9iamVjdEV4cHJlc3Npb259IE9iamVjdEV4cHJlc3Npb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5Qcm9wZXJ0eX0gUHJvcGVydHlcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2VzdHJlZS1qc3gnKS5TcHJlYWRFbGVtZW50fSBTcHJlYWRFbGVtZW50XG4gKlxuICogQHR5cGVkZWYgeydhdXRvbWF0aWMnIHwgJ2NsYXNzaWMnfSBSdW50aW1lXG4gKiAgIEhvdyB0byB0cmFuc2Zvcm0gSlNYLlxuICpcbiAqIEB0eXBlZGVmIE9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqXG4gKiAgID4g8J+RiSAqKk5vdGUqKjogeW91IGNhbiBhbHNvIGNvbmZpZ3VyZSBgcnVudGltZWAsIGBpbXBvcnRTb3VyY2VgLCBgcHJhZ21hYCxcbiAqICAgPiBhbmQgYHByYWdtYUZyYWdgIGZyb20gd2l0aGluIGZpbGVzIHRocm91Z2ggY29tbWVudHMuXG4gKiBAcHJvcGVydHkge1J1bnRpbWUgfCBudWxsIHwgdW5kZWZpbmVkfSBbcnVudGltZT0nY2xhc3NpYyddXG4gKiAgIENob29zZSB0aGUgcnVudGltZSAoZGVmYXVsdDogYCdjbGFzc2ljJ2ApLlxuICpcbiAqICAgQ29tbWVudCBmb3JtOiBgQGpzeFJ1bnRpbWUgdGhlUnVudGltZWAuXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtpbXBvcnRTb3VyY2U9J3JlYWN0J11cbiAqICAgUGxhY2UgdG8gaW1wb3J0IGBqc3hgLCBganN4c2AsIGBqc3hERVZgLCBhbmQgYEZyYWdtZW50YCBmcm9tLCB3aGVuIHRoZVxuICogICBlZmZlY3RpdmUgcnVudGltZSBpcyBhdXRvbWF0aWMgKGRlZmF1bHQ6IGAncmVhY3QnYCkuXG4gKlxuICogICBDb21tZW50IGZvcm06IGBAanN4SW1wb3J0U291cmNlIHRoZVNvdXJjZWAuXG4gKlxuICogICA+IPCfkYkgKipOb3RlKio6IGAvanN4LXJ1bnRpbWVgIG9yIGAvanN4LWRldi1ydW50aW1lYCBpcyBhcHBlbmRlZCB0byB0aGlzXG4gKiAgID4gcHJvdmlkZWQgc291cmNlLlxuICogICA+IEluIENKUywgdGhhdCBjYW4gcmVzb2x2ZSB0byBhIGZpbGUgKGFzIGluIGB0aGVTb3VyY2UvanN4LXJ1bnRpbWUuanNgKSxcbiAqICAgPiBidXQgZm9yIEVTTSBhbiBleHBvcnQgbWFwIG5lZWRzIHRvIGJlIHNldCB1cCB0byBwb2ludCB0byBmaWxlczpcbiAqICAgPlxuICogICA+IGBgYGpzXG4gKiAgID4gLy8g4oCmXG4gKiAgID4gXCJleHBvcnRzXCI6IHtcbiAqICAgPiAgIC8vIOKAplxuICogICA+ICAgXCIuL2pzeC1ydW50aW1lXCI6IFwiLi9wYXRoL3RvL2pzeC1ydW50aW1lLmpzXCIsXG4gKiAgID4gICBcIi4vanN4LWRldi1ydW50aW1lXCI6IFwiLi9wYXRoL3RvL2pzeC1ydW50aW1lLmpzXCJcbiAqICAgPiAgIC8vIOKAplxuICogICA+IGBgYFxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbcHJhZ21hPSdSZWFjdC5jcmVhdGVFbGVtZW50J11cbiAqICAgSWRlbnRpZmllciBvciBtZW1iZXIgZXhwcmVzc2lvbiB0byBjYWxsIHdoZW4gdGhlIGVmZmVjdGl2ZSBydW50aW1lIGlzXG4gKiAgIGNsYXNzaWMgKGRlZmF1bHQ6IGAnUmVhY3QuY3JlYXRlRWxlbWVudCdgKS5cbiAqXG4gKiAgIENvbW1lbnQgZm9ybTogYEBqc3ggaWRlbnRpZmllcmAuXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtwcmFnbWFGcmFnPSdSZWFjdC5GcmFnbWVudCddXG4gKiAgIElkZW50aWZpZXIgb3IgbWVtYmVyIGV4cHJlc3Npb24gdG8gdXNlIGFzIGEgc3ltYm9sIGZvciBmcmFnbWVudHMgd2hlbiB0aGVcbiAqICAgZWZmZWN0aXZlIHJ1bnRpbWUgaXMgY2xhc3NpYyAoZGVmYXVsdDogYCdSZWFjdC5GcmFnbWVudCdgKS5cbiAqXG4gKiAgIENvbW1lbnQgZm9ybTogYEBqc3hGcmFnIGlkZW50aWZpZXJgLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2RldmVsb3BtZW50PWZhbHNlXVxuICogICBXaGVuIGluIHRoZSBhdXRvbWF0aWMgcnVudGltZSwgd2hldGhlciB0byBpbXBvcnRcbiAqICAgYHRoZVNvdXJjZS9qc3gtZGV2LXJ1bnRpbWUuanNgLCB1c2UgYGpzeERFVmAsIGFuZCBwYXNzIGxvY2F0aW9uIGluZm8gd2hlblxuICogICBhdmFpbGFibGUgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICpcbiAqICAgVGhpcyBoZWxwcyBkZWJ1Z2dpbmcgYnV0IGFkZHMgYSBsb3Qgb2YgY29kZSB0aGF0IHlvdSBkb27igJl0IHdhbnQgaW5cbiAqICAgcHJvZHVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2ZpbGVQYXRoXVxuICogICBGaWxlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChvcHRpb25hbCkuXG4gKlxuICogICBQYXNzZWQgaW4gbG9jYXRpb24gaW5mbyB0byBganN4REVWYCB3aGVuIHVzaW5nIHRoZSBhdXRvbWF0aWMgcnVudGltZSB3aXRoXG4gKiAgIGBkZXZlbG9wbWVudDogdHJ1ZWAuXG4gKlxuICogQHR5cGVkZWYgQW5ub3RhdGlvbnNcbiAqICAgU3RhdGUgd2hlcmUgaW5mbyBmcm9tIGNvbW1lbnRzIGlzIGdhdGhlcmVkLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCB1bmRlZmluZWR9IFtqc3hdXG4gKiAgIEpTWCBpZGVudGlmaWVyIChgcHJhZ21hYCkuXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IHVuZGVmaW5lZH0gW2pzeEZyYWddXG4gKiAgIEpTWCBpZGVudGlmaWVyIG9mIGZyYWdtZW50IChgcHJhZ21hRnJhZ2ApLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCB1bmRlZmluZWR9IFtqc3hJbXBvcnRTb3VyY2VdXG4gKiAgIFdoZXJlIHRvIGltcG9ydCBhbiBhdXRvbWF0aWMgSlNYIHJ1bnRpbWUgZnJvbS5cbiAqIEBwcm9wZXJ0eSB7UnVudGltZSB8IHVuZGVmaW5lZH0gW2pzeFJ1bnRpbWVdXG4gKiAgIFJ1bnRpbWUuXG4gKlxuICogQHR5cGVkZWYgSW1wb3J0c1xuICogICBTdGF0ZSBvZiB1c2VkIGlkZW50aWZpZXJzIGZyb20gdGhlIGF1dG9tYXRpYyBydW50aW1lLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgdW5kZWZpbmVkfSBbZnJhZ21lbnRdXG4gKiAgIFN5bWJvbCBvZiBgRnJhZ21lbnRgLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgdW5kZWZpbmVkfSBbanN4XVxuICogICBTeW1ib2wgb2YgYGpzeGAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCB1bmRlZmluZWR9IFtqc3hzXVxuICogICBTeW1ib2wgb2YgYGpzeHNgLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgdW5kZWZpbmVkfSBbanN4REVWXVxuICogICBTeW1ib2wgb2YgYGpzeERFVmAuXG4gKi9cblxuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ2RldmxvcCdcbmltcG9ydCB7bmFtZSBhcyBpc0lkZW50aWZpZXJOYW1lfSBmcm9tICdlc3RyZWUtdXRpbC1pcy1pZGVudGlmaWVyLW5hbWUnXG5pbXBvcnQge3dhbGt9IGZyb20gJ2VzdHJlZS13YWxrZXInXG5cbmNvbnN0IHJlZ2V4ID0gL0AoanN4fGpzeEZyYWd8anN4SW1wb3J0U291cmNlfGpzeFJ1bnRpbWUpXFxzKyhcXFMrKS9nXG5cbi8qKlxuICogVHVybiBKU1ggaW4gYHRyZWVgIGludG8gZnVuY3Rpb24gY2FsbHM6IGA8eCAvPmAgLT4gYGgoJ3gnKWAhXG4gKlxuICogIyMjIyMjIEFsZ29yaXRobVxuICpcbiAqIEluIGFsbW9zdCBhbGwgY2FzZXMsIHRoaXMgdXRpbGl0eSBpcyB0aGUgc2FtZSBhcyB0aGUgQmFiZWwgcGx1Z2luLCBleGNlcHQgdGhhdFxuICogdGhleSB3b3JrIG9uIHNsaWdodGx5IGRpZmZlcmVudCBzeW50YXggdHJlZXMuXG4gKlxuICogU29tZSBkaWZmZXJlbmNlczpcbiAqXG4gKiAqICAgbm8gcHVyZSBhbm5vdGF0aW9ucyB0aGluZ3NcbiAqICogICBgdGhpc2AgaXMgbm90IGEgY29tcG9uZW50OiBgPHRoaXM+YCAtPiBgaCgndGhpcycpYCwgbm90IGBoKHRoaXMpYFxuICogKiAgIG5hbWVzcGFjZXMgYXJlIHN1cHBvcnRlZDogYDxhOmIgYzpkPmAgLT4gYGgoJ2E6YicsIHsnYzpkJzogdHJ1ZX0pYCxcbiAqICAgICB3aGljaCB0aHJvd3MgYnkgZGVmYXVsdCBpbiBCYWJlbCBvciBjYW4gYmUgdHVybmVkIG9uIHdpdGggYHRocm93SWZOYW1lc3BhY2VgXG4gKiAqICAgbm8gYHVzZVNwcmVhZGAsIGB1c2VCdWlsdEluc2AsIG9yIGBmaWx0ZXJgIG9wdGlvbnNcbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRyZWVcbiAqICAgVHJlZSB0byB0cmFuc2Zvcm0gKHR5cGljYWxseSBgUHJvZ3JhbWApLlxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEpzeCh0cmVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvbmZpZyA9IG9wdGlvbnMgfHwge31cbiAgbGV0IGF1dG9tYXRpYyA9IGNvbmZpZy5ydW50aW1lID09PSAnYXV0b21hdGljJ1xuICAvKiogQHR5cGUge0Fubm90YXRpb25zfSAqL1xuICBjb25zdCBhbm5vdGF0aW9ucyA9IHt9XG4gIC8qKiBAdHlwZSB7SW1wb3J0c30gKi9cbiAgY29uc3QgaW1wb3J0cyA9IHt9XG5cbiAgd2Fsayh0cmVlLCB7XG4gICAgZW50ZXIobm9kZSkge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ1Byb2dyYW0nKSB7XG4gICAgICAgIGNvbnN0IGNvbW1lbnRzID0gbm9kZS5jb21tZW50cyB8fCBbXVxuICAgICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmVnZXgubGFzdEluZGV4ID0gMFxuXG4gICAgICAgICAgbGV0IG1hdGNoID0gcmVnZXguZXhlYyhjb21tZW50c1tpbmRleF0udmFsdWUpXG5cbiAgICAgICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBtYXRjaFsxXWAgaXMgYWx3YXlzIGEga2V5LCBgbWF0Y2hbMl1gIHdoZW5cbiAgICAgICAgICAgIC8vIHJ1bnRpbWUgaXMgY2hlY2tlZCBsYXRlci5cbiAgICAgICAgICAgIGFubm90YXRpb25zW21hdGNoWzFdXSA9IG1hdGNoWzJdXG4gICAgICAgICAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoY29tbWVudHNbaW5kZXhdLnZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbm5vdGF0aW9ucy5qc3hSdW50aW1lKSB7XG4gICAgICAgICAgaWYgKGFubm90YXRpb25zLmpzeFJ1bnRpbWUgPT09ICdhdXRvbWF0aWMnKSB7XG4gICAgICAgICAgICBhdXRvbWF0aWMgPSB0cnVlXG5cbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucy5qc3gpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGBAanN4YCBwcmFnbWEgdy8gYXV0b21hdGljIHJ1bnRpbWUnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMuanN4RnJhZykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ1VuZXhwZWN0ZWQgYEBqc3hGcmFnYCBwcmFnbWEgdy8gYXV0b21hdGljIHJ1bnRpbWUnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGFubm90YXRpb25zLmpzeFJ1bnRpbWUgPT09ICdjbGFzc2ljJykge1xuICAgICAgICAgICAgYXV0b21hdGljID0gZmFsc2VcblxuICAgICAgICAgICAgaWYgKGFubm90YXRpb25zLmpzeEltcG9ydFNvdXJjZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ1VuZXhwZWN0ZWQgYEBqc3hJbXBvcnRTb3VyY2VgIHcvIGNsYXNzaWMgcnVudGltZSdcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdVbmV4cGVjdGVkIGBqc3hSdW50aW1lYCBgJyArXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMuanN4UnVudGltZSArXG4gICAgICAgICAgICAgICAgJ2AsIGV4cGVjdGVkIGBhdXRvbWF0aWNgIG9yIGBjbGFzc2ljYCdcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgbGVhdmUobm9kZSkge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ1Byb2dyYW0nKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8SW1wb3J0U3BlY2lmaWVyPn0gKi9cbiAgICAgICAgY29uc3Qgc3BlY2lmaWVycyA9IFtdXG5cbiAgICAgICAgaWYgKGltcG9ydHMuZnJhZ21lbnQpIHtcbiAgICAgICAgICBzcGVjaWZpZXJzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ0ltcG9ydFNwZWNpZmllcicsXG4gICAgICAgICAgICBpbXBvcnRlZDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ0ZyYWdtZW50J30sXG4gICAgICAgICAgICBsb2NhbDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ19GcmFnbWVudCd9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbXBvcnRzLmpzeCkge1xuICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnSW1wb3J0U3BlY2lmaWVyJyxcbiAgICAgICAgICAgIGltcG9ydGVkOiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnanN4J30sXG4gICAgICAgICAgICBsb2NhbDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ19qc3gnfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW1wb3J0cy5qc3hzKSB7XG4gICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICAgICAgaW1wb3J0ZWQ6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdqc3hzJ30sXG4gICAgICAgICAgICBsb2NhbDoge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ19qc3hzJ31cbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGltcG9ydHMuanN4REVWKSB7XG4gICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICAgICAgaW1wb3J0ZWQ6IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdqc3hERVYnfSxcbiAgICAgICAgICAgIGxvY2FsOiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnX2pzeERFVid9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzcGVjaWZpZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsZXQgaW5qZWN0SW5kZXggPSAwXG5cbiAgICAgICAgICB3aGlsZSAoaW5qZWN0SW5kZXggPCBub2RlLmJvZHkubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuYm9keVtpbmplY3RJbmRleF1cblxuICAgICAgICAgICAgaWYgKCdkaXJlY3RpdmUnIGluIGNoaWxkICYmIGNoaWxkLmRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICBpbmplY3RJbmRleCsrXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGUuYm9keS5zcGxpY2UoaW5qZWN0SW5kZXgsIDAsIHtcbiAgICAgICAgICAgIHR5cGU6ICdJbXBvcnREZWNsYXJhdGlvbicsXG4gICAgICAgICAgICBzcGVjaWZpZXJzLFxuICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdMaXRlcmFsJyxcbiAgICAgICAgICAgICAgdmFsdWU6XG4gICAgICAgICAgICAgICAgKGFubm90YXRpb25zLmpzeEltcG9ydFNvdXJjZSB8fFxuICAgICAgICAgICAgICAgICAgY29uZmlnLmltcG9ydFNvdXJjZSB8fFxuICAgICAgICAgICAgICAgICAgJ3JlYWN0JykgK1xuICAgICAgICAgICAgICAgIChjb25maWcuZGV2ZWxvcG1lbnQgPyAnL2pzeC1kZXYtcnVudGltZScgOiAnL2pzeC1ydW50aW1lJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnR5cGUgIT09ICdKU1hFbGVtZW50JyAmJiBub2RlLnR5cGUgIT09ICdKU1hGcmFnbWVudCcpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8RXhwcmVzc2lvbj59ICovXG4gICAgICBjb25zdCBjaGlsZHJlbiA9IFtdXG4gICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICAvLyBGaWd1cmUgb3V0IGBjaGlsZHJlbmAuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpbmRleF1cblxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ0pTWEV4cHJlc3Npb25Db250YWluZXInKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGVtcHR5IGV4cHJlc3Npb25zLlxuICAgICAgICAgIGlmIChjaGlsZC5leHByZXNzaW9uLnR5cGUgIT09ICdKU1hFbXB0eUV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkLmV4cHJlc3Npb24pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09ICdKU1hUZXh0Jykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2hpbGQudmFsdWVcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGFicyB3LyBzcGFjZXMuXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx0L2csICcgJylcbiAgICAgICAgICAgIC8vIFVzZSBsaW5lIGZlZWRzLCBkcm9wIHNwYWNlcyBhcm91bmQgdGhlbS5cbiAgICAgICAgICAgIC5yZXBsYWNlKC8gKihcXHI/XFxufFxccikgKi9nLCAnXFxuJylcbiAgICAgICAgICAgIC8vIENvbGxhcHNlIG11bHRpcGxlIGxpbmUgZmVlZHMuXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuKy9nLCAnXFxuJylcbiAgICAgICAgICAgIC8vIERyb3AgZmluYWwgbGluZSBmZWVkcy5cbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4rJC8sICcnKVxuICAgICAgICAgICAgLy8gRHJvcCBmaXJzdCBsaW5lIGZlZWRzLlxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXG4rLywgJycpXG4gICAgICAgICAgICAvLyBSZXBsYWNlIGxpbmUgZmVlZHMgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csICcgJylcblxuICAgICAgICAgIC8vIElnbm9yZSBjb2xsYXBzaWJsZSB0ZXh0LlxuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHtOb2RlfSAqL1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlfVxuICAgICAgICAgICAgY3JlYXRlKGNoaWxkLCB0ZXh0KVxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0ZXh0KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgICBjaGlsZC50eXBlICE9PSAnSlNYRWxlbWVudCcgJiZcbiAgICAgICAgICAgICAgY2hpbGQudHlwZSAhPT0gJ0pTWEZyYWdtZW50JyAmJlxuICAgICAgICAgICAgICBjaGlsZC50eXBlICE9PSAnSlNYU3ByZWFkQ2hpbGQnXG4gICAgICAgICAgKVxuICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqIEB0eXBlIHtJZGVudGlmaWVyIHwgTGl0ZXJhbCB8IE1lbWJlckV4cHJlc3Npb259ICovXG4gICAgICBsZXQgbmFtZVxuICAgICAgLyoqIEB0eXBlIHtBcnJheTxQcm9wZXJ0eSB8IFNwcmVhZEVsZW1lbnQ+fSAqL1xuICAgICAgY29uc3QgZmllbGRzID0gW11cbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8RXhwcmVzc2lvbj59ICovXG4gICAgICBsZXQgcGFyYW1ldGVycyA9IFtdXG4gICAgICAvKiogQHR5cGUge0V4cHJlc3Npb24gfCB1bmRlZmluZWR9ICovXG4gICAgICBsZXQga2V5XG5cbiAgICAgIC8vIERvIHRoZSBzdHVmZiBuZWVkZWQgZm9yIGVsZW1lbnRzLlxuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0pTWEVsZW1lbnQnKSB7XG4gICAgICAgIG5hbWUgPSB0b0lkZW50aWZpZXIobm9kZS5vcGVuaW5nRWxlbWVudC5uYW1lKVxuXG4gICAgICAgIC8vIElmIHRoZSBuYW1lIGNvdWxkIGJlIGFuIGlkZW50aWZpZXIsIGJ1dCBzdGFydCB3aXRoIGEgbG93ZXJjYXNlIGxldHRlcixcbiAgICAgICAgLy8gaXTigJlzIG5vdCBhIGNvbXBvbmVudC5cbiAgICAgICAgaWYgKG5hbWUudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmIC9eW2Etel0vLnRlc3QobmFtZS5uYW1lKSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7Tm9kZX0gKi9cbiAgICAgICAgICBjb25zdCBuZXh0ID0ge3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IG5hbWUubmFtZX1cbiAgICAgICAgICBjcmVhdGUobmFtZSwgbmV4dClcbiAgICAgICAgICBuYW1lID0gbmV4dFxuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFuIHwgdW5kZWZpbmVkfSAqL1xuICAgICAgICBsZXQgc3ByZWFkXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBub2RlLm9wZW5pbmdFbGVtZW50LmF0dHJpYnV0ZXNcbiAgICAgICAgbGV0IGluZGV4ID0gLTFcblxuICAgICAgICAvLyBQbGFjZSBwcm9wcyBpbiB0aGUgcmlnaHQgb3JkZXIsIGJlY2F1c2Ugd2UgbWlnaHQgaGF2ZSBkdXBsaWNhdGVzXG4gICAgICAgIC8vIGluIHRoZW0gYW5kIHdoYXTigJlzIHNwcmVhZCBpbi5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaW5kZXhdXG5cbiAgICAgICAgICBpZiAoYXR0cmlidXRlLnR5cGUgPT09ICdKU1hTcHJlYWRBdHRyaWJ1dGUnKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlLmFyZ3VtZW50LnR5cGUgPT09ICdPYmplY3RFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICBmaWVsZHMucHVzaCguLi5hdHRyaWJ1dGUuYXJndW1lbnQucHJvcGVydGllcylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpZWxkcy5wdXNoKHt0eXBlOiAnU3ByZWFkRWxlbWVudCcsIGFyZ3VtZW50OiBhdHRyaWJ1dGUuYXJndW1lbnR9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzcHJlYWQgPSB0cnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3AgPSB0b1Byb3BlcnR5KGF0dHJpYnV0ZSlcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBhdXRvbWF0aWMgJiZcbiAgICAgICAgICAgICAgcHJvcC5rZXkudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmXG4gICAgICAgICAgICAgIHByb3Aua2V5Lm5hbWUgPT09ICdrZXknXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKHNwcmVhZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICdFeHBlY3RlZCBga2V5YCB0byBjb21lIGJlZm9yZSBhbnkgc3ByZWFkIGV4cHJlc3Npb25zJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcC52YWx1ZVxuXG4gICAgICAgICAgICAgIGFzc2VydChcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlICE9PSAnQXNzaWdubWVudFBhdHRlcm4nICYmXG4gICAgICAgICAgICAgICAgICB2YWx1ZS50eXBlICE9PSAnQXJyYXlQYXR0ZXJuJyAmJlxuICAgICAgICAgICAgICAgICAgdmFsdWUudHlwZSAhPT0gJ09iamVjdFBhdHRlcm4nICYmXG4gICAgICAgICAgICAgICAgICB2YWx1ZS50eXBlICE9PSAnUmVzdEVsZW1lbnQnXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICBrZXkgPSB2YWx1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmllbGRzLnB1c2gocHJvcClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIOKApmFuZCBmcmFnbWVudHMuXG4gICAgICBlbHNlIGlmIChhdXRvbWF0aWMpIHtcbiAgICAgICAgaW1wb3J0cy5mcmFnbWVudCA9IHRydWVcbiAgICAgICAgbmFtZSA9IHt0eXBlOiAnSWRlbnRpZmllcicsIG5hbWU6ICdfRnJhZ21lbnQnfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSA9IHRvTWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgICBhbm5vdGF0aW9ucy5qc3hGcmFnIHx8IGNvbmZpZy5wcmFnbWFGcmFnIHx8ICdSZWFjdC5GcmFnbWVudCdcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoYXV0b21hdGljKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ1Byb3BlcnR5JyxcbiAgICAgICAgICAgIGtleToge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ2NoaWxkcmVuJ30sXG4gICAgICAgICAgICB2YWx1ZTpcbiAgICAgICAgICAgICAgY2hpbGRyZW4ubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgID8ge3R5cGU6ICdBcnJheUV4cHJlc3Npb24nLCBlbGVtZW50czogY2hpbGRyZW59XG4gICAgICAgICAgICAgICAgOiBjaGlsZHJlblswXSxcbiAgICAgICAgICAgIGtpbmQ6ICdpbml0JyxcbiAgICAgICAgICAgIG1ldGhvZDogZmFsc2UsXG4gICAgICAgICAgICBzaG9ydGhhbmQ6IGZhbHNlLFxuICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1ldGVycyA9IGNoaWxkcmVuXG4gICAgICB9XG5cbiAgICAgIC8qKiBAdHlwZSB7SWRlbnRpZmllciB8IExpdGVyYWwgfCBNZW1iZXJFeHByZXNzaW9ufSAqL1xuICAgICAgbGV0IGNhbGxlZVxuXG4gICAgICBpZiAoYXV0b21hdGljKSB7XG4gICAgICAgIHBhcmFtZXRlcnMucHVzaCh7dHlwZTogJ09iamVjdEV4cHJlc3Npb24nLCBwcm9wZXJ0aWVzOiBmaWVsZHN9KVxuXG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2goa2V5KVxuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5kZXZlbG9wbWVudCkge1xuICAgICAgICAgIHBhcmFtZXRlcnMucHVzaCh7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAndW5kZWZpbmVkJ30pXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc1N0YXRpY0NoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoID4gMVxuXG4gICAgICAgIGlmIChjb25maWcuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICBpbXBvcnRzLmpzeERFViA9IHRydWVcbiAgICAgICAgICBjYWxsZWUgPSB7XG4gICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICBuYW1lOiAnX2pzeERFVidcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyYW1ldGVycy5wdXNoKHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBpc1N0YXRpY0NoaWxkcmVufSlcblxuICAgICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0RXhwcmVzc2lvbn0gKi9cbiAgICAgICAgICBjb25zdCBzb3VyY2UgPSB7XG4gICAgICAgICAgICB0eXBlOiAnT2JqZWN0RXhwcmVzc2lvbicsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUHJvcGVydHknLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvcnRoYW5kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAga2luZDogJ2luaXQnLFxuICAgICAgICAgICAgICAgIGtleToge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ2ZpbGVOYW1lJ30sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdMaXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb25maWcuZmlsZVBhdGggfHwgJzxzb3VyY2UuanM+J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChub2RlLmxvYykge1xuICAgICAgICAgICAgc291cmNlLnByb3BlcnRpZXMucHVzaChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdQcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG9ydGhhbmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBraW5kOiAnaW5pdCcsXG4gICAgICAgICAgICAgICAga2V5OiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnbGluZU51bWJlcid9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogbm9kZS5sb2Muc3RhcnQubGluZX1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdQcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG9ydGhhbmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBraW5kOiAnaW5pdCcsXG4gICAgICAgICAgICAgICAga2V5OiB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnY29sdW1uTnVtYmVyJ30sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBub2RlLmxvYy5zdGFydC5jb2x1bW4gKyAxfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyYW1ldGVycy5wdXNoKHNvdXJjZSwge3R5cGU6ICdUaGlzRXhwcmVzc2lvbid9KVxuICAgICAgICB9IGVsc2UgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpbXBvcnRzLmpzeHMgPSB0cnVlXG4gICAgICAgICAgY2FsbGVlID0ge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogJ19qc3hzJ31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbXBvcnRzLmpzeCA9IHRydWVcbiAgICAgICAgICBjYWxsZWUgPSB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiAnX2pzeCd9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENsYXNzaWMuXG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGZpZWxkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGFyYW1ldGVycy51bnNoaWZ0KHt0eXBlOiAnT2JqZWN0RXhwcmVzc2lvbicsIHByb3BlcnRpZXM6IGZpZWxkc30pXG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGFyYW1ldGVycy51bnNoaWZ0KHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBudWxsfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxlZSA9IHRvTWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgICBhbm5vdGF0aW9ucy5qc3ggfHwgY29uZmlnLnByYWdtYSB8fCAnUmVhY3QuY3JlYXRlRWxlbWVudCdcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBwYXJhbWV0ZXJzLnVuc2hpZnQobmFtZSlcbiAgICAgIC8qKiBAdHlwZSB7Tm9kZX0gKi9cbiAgICAgIGNvbnN0IGNhbGwgPSB7XG4gICAgICAgIHR5cGU6ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgIGNhbGxlZSxcbiAgICAgICAgYXJndW1lbnRzOiBwYXJhbWV0ZXJzLFxuICAgICAgICBvcHRpb25hbDogZmFsc2VcbiAgICAgIH1cbiAgICAgIGNyZWF0ZShub2RlLCBjYWxsKVxuICAgICAgdGhpcy5yZXBsYWNlKGNhbGwpXG4gICAgfVxuICB9KVxufVxuXG4vKipcbiAqIFR1cm4gYSBKU1ggYXR0cmlidXRlIGludG8gYSBKYXZhU2NyaXB0IHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7SlNYQXR0cmlidXRlfSBub2RlXG4gKiAgIEpTWCBhdHRyaWJ1dGUuXG4gKiBAcmV0dXJucyB7UHJvcGVydHl9XG4gKiAgIEpTIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiB0b1Byb3BlcnR5KG5vZGUpIHtcbiAgLyoqIEB0eXBlIHtFeHByZXNzaW9ufSAqL1xuICBsZXQgdmFsdWVcblxuICBpZiAobm9kZS52YWx1ZSkge1xuICAgIGlmIChub2RlLnZhbHVlLnR5cGUgPT09ICdKU1hFeHByZXNzaW9uQ29udGFpbmVyJykge1xuICAgICAgY29uc3QgdmFsdWVFeHByZXNzaW9uID0gbm9kZS52YWx1ZS5leHByZXNzaW9uXG4gICAgICBhc3NlcnQoXG4gICAgICAgIHZhbHVlRXhwcmVzc2lvbi50eXBlICE9PSAnSlNYRW1wdHlFeHByZXNzaW9uJyxcbiAgICAgICAgJ2BKU1hFbXB0eUV4cHJlc3Npb25gIGlzIG5vdCBhbGxvd2VkIGluIHByb3BzLidcbiAgICAgIClcbiAgICAgIHZhbHVlID0gdmFsdWVFeHByZXNzaW9uXG4gICAgfVxuICAgIC8vIExpdGVyYWwgb3IgY2FsbCBleHByZXNzaW9uLlxuICAgIGVsc2Uge1xuICAgICAgY29uc3Qgbm9kZVZhbHVlID0gbm9kZS52YWx1ZVxuICAgICAgYXNzZXJ0KFxuICAgICAgICBub2RlVmFsdWUudHlwZSAhPT0gJ0pTWEVsZW1lbnQnICYmIG5vZGVWYWx1ZS50eXBlICE9PSAnSlNYRnJhZ21lbnQnLFxuICAgICAgICAnSlNYe0VsZW1lbnQsRnJhZ21lbnR9IGFyZSBhbHJlYWR5IGNvbXBpbGVkIHRvIGBDYWxsRXhwcmVzc2lvbmAnXG4gICAgICApXG4gICAgICB2YWx1ZSA9IG5vZGVWYWx1ZVxuICAgICAgZGVsZXRlIHZhbHVlLnJhd1xuICAgIH1cbiAgfVxuICAvLyBCb29sZWFuIHByb3AuXG4gIGVsc2Uge1xuICAgIHZhbHVlID0ge3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IHRydWV9XG4gIH1cblxuICAvKiogQHR5cGUge1Byb3BlcnR5fSAqL1xuICBjb25zdCByZXBsYWNlbWVudCA9IHtcbiAgICB0eXBlOiAnUHJvcGVydHknLFxuICAgIGtleTogdG9JZGVudGlmaWVyKG5vZGUubmFtZSksXG4gICAgdmFsdWUsXG4gICAga2luZDogJ2luaXQnLFxuICAgIG1ldGhvZDogZmFsc2UsXG4gICAgc2hvcnRoYW5kOiBmYWxzZSxcbiAgICBjb21wdXRlZDogZmFsc2VcbiAgfVxuICBjcmVhdGUobm9kZSwgcmVwbGFjZW1lbnQpXG4gIHJldHVybiByZXBsYWNlbWVudFxufVxuXG4vKipcbiAqIFR1cm4gYSBKU1ggaWRlbnRpZmllciBpbnRvIGEgbm9ybWFsIEpTIGlkZW50aWZpZXIuXG4gKlxuICogQHBhcmFtIHtKU1hJZGVudGlmaWVyIHwgSlNYTWVtYmVyRXhwcmVzc2lvbiB8IEpTWE5hbWVzcGFjZWROYW1lfSBub2RlXG4gKiAgIEpTWCBpZGVudGlmaWVyLlxuICogQHJldHVybnMge0lkZW50aWZpZXIgfCBMaXRlcmFsIHwgTWVtYmVyRXhwcmVzc2lvbn1cbiAqICAgSlMgaWRlbnRpZmllci5cbiAqL1xuZnVuY3Rpb24gdG9JZGVudGlmaWVyKG5vZGUpIHtcbiAgLyoqIEB0eXBlIHtJZGVudGlmaWVyIHwgTGl0ZXJhbCB8IE1lbWJlckV4cHJlc3Npb259ICovXG4gIGxldCByZXBsYWNlXG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ0pTWE1lbWJlckV4cHJlc3Npb24nKSB7XG4gICAgLy8gYHByb3BlcnR5YCBpcyBhbHdheXMgYSBgSlNYSWRlbnRpZmllcmAsIGJ1dCBpdCBjb3VsZCBiZSBzb21ldGhpbmcgdGhhdFxuICAgIC8vIGlzbuKAmXQgYW4gRVMgaWRlbnRpZmllciBuYW1lLlxuICAgIGNvbnN0IGlkID0gdG9JZGVudGlmaWVyKG5vZGUucHJvcGVydHkpXG4gICAgcmVwbGFjZSA9IHtcbiAgICAgIHR5cGU6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgIG9iamVjdDogdG9JZGVudGlmaWVyKG5vZGUub2JqZWN0KSxcbiAgICAgIHByb3BlcnR5OiBpZCxcbiAgICAgIGNvbXB1dGVkOiBpZC50eXBlID09PSAnTGl0ZXJhbCcsXG4gICAgICBvcHRpb25hbDogZmFsc2VcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAnSlNYTmFtZXNwYWNlZE5hbWUnKSB7XG4gICAgcmVwbGFjZSA9IHtcbiAgICAgIHR5cGU6ICdMaXRlcmFsJyxcbiAgICAgIHZhbHVlOiBub2RlLm5hbWVzcGFjZS5uYW1lICsgJzonICsgbm9kZS5uYW1lLm5hbWVcbiAgICB9XG4gIH1cbiAgLy8gTXVzdCBiZSBgSlNYSWRlbnRpZmllcmAuXG4gIGVsc2Uge1xuICAgIHJlcGxhY2UgPSBpc0lkZW50aWZpZXJOYW1lKG5vZGUubmFtZSlcbiAgICAgID8ge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogbm9kZS5uYW1lfVxuICAgICAgOiB7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogbm9kZS5uYW1lfVxuICB9XG5cbiAgY3JlYXRlKG5vZGUsIHJlcGxhY2UpXG4gIHJldHVybiByZXBsYWNlXG59XG5cbi8qKlxuICogVHVybiBhIGRvdHRlZCBzdHJpbmcgaW50byBhIG1lbWJlciBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICogICBJZGVudGlmaWVycy5cbiAqIEByZXR1cm5zIHtJZGVudGlmaWVyIHwgTGl0ZXJhbCB8IE1lbWJlckV4cHJlc3Npb259XG4gKiAgIEV4cHJlc3Npb24uXG4gKi9cbmZ1bmN0aW9uIHRvTWVtYmVyRXhwcmVzc2lvbihpZCkge1xuICBjb25zdCBpZGVudGlmaWVycyA9IGlkLnNwbGl0KCcuJylcbiAgbGV0IGluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHtJZGVudGlmaWVyIHwgTGl0ZXJhbCB8IE1lbWJlckV4cHJlc3Npb24gfCB1bmRlZmluZWR9ICovXG4gIGxldCByZXN1bHRcblxuICB3aGlsZSAoKytpbmRleCA8IGlkZW50aWZpZXJzLmxlbmd0aCkge1xuICAgIC8qKiBAdHlwZSB7SWRlbnRpZmllciB8IExpdGVyYWx9ICovXG4gICAgY29uc3QgcHJvcCA9IGlzSWRlbnRpZmllck5hbWUoaWRlbnRpZmllcnNbaW5kZXhdKVxuICAgICAgPyB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiBpZGVudGlmaWVyc1tpbmRleF19XG4gICAgICA6IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBpZGVudGlmaWVyc1tpbmRleF19XG4gICAgcmVzdWx0ID0gcmVzdWx0XG4gICAgICA/IHtcbiAgICAgICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgICAgb2JqZWN0OiByZXN1bHQsXG4gICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgY29tcHV0ZWQ6IEJvb2xlYW4oaW5kZXggJiYgcHJvcC50eXBlID09PSAnTGl0ZXJhbCcpLFxuICAgICAgICAgIG9wdGlvbmFsOiBmYWxzZVxuICAgICAgICB9XG4gICAgICA6IHByb3BcbiAgfVxuXG4gIGFzc2VydChyZXN1bHQsICdhbHdheXMgYSByZXN1bHQnKVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogSW5oZXJpdCBzb21lIGZpZWxkcyBmcm9tIGBmcm9tYCBpbnRvIGB0b2AuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBmcm9tXG4gKiAgIE5vZGUgdG8gaW5oZXJpdCBmcm9tLlxuICogQHBhcmFtIHtOb2RlfSB0b1xuICogICBOb2RlIHRvIGFkZCB0by5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZShmcm9tLCB0bykge1xuICBjb25zdCBmaWVsZHMgPSBbJ3N0YXJ0JywgJ2VuZCcsICdsb2MnLCAncmFuZ2UnLCAnY29tbWVudHMnXVxuICBsZXQgaW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK2luZGV4IDwgZmllbGRzLmxlbmd0aCkge1xuICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW2luZGV4XVxuICAgIGlmIChmaWVsZCBpbiBmcm9tKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbmRleGFibGUuXG4gICAgICB0b1tmaWVsZF0gPSBmcm9tW2ZpZWxkXVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/estree-util-build-jsx@3.0.1/node_modules/estree-util-build-jsx/lib/index.js\n");

/***/ })

};
;