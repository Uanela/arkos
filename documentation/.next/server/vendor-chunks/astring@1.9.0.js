"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/astring@1.9.0";
exports.ids = ["vendor-chunks/astring@1.9.0"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/astring@1.9.0/node_modules/astring/dist/astring.mjs":
/*!*********************************************************************************!*\
  !*** ../node_modules/.pnpm/astring@1.9.0/node_modules/astring/dist/astring.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXPRESSIONS_PRECEDENCE: () => (/* binding */ EXPRESSIONS_PRECEDENCE),\n/* harmony export */   GENERATOR: () => (/* binding */ GENERATOR),\n/* harmony export */   NEEDS_PARENTHESES: () => (/* binding */ NEEDS_PARENTHESES),\n/* harmony export */   baseGenerator: () => (/* binding */ baseGenerator),\n/* harmony export */   generate: () => (/* binding */ generate)\n/* harmony export */ });\n// Astring is a tiny and fast JavaScript code generator from an ESTree-compliant AST.\n//\n// Astring was written by David Bonnet and released under an MIT license.\n//\n// The Git repository for Astring is available at:\n// https://github.com/davidbonnet/astring.git\n//\n// Please use the GitHub bug tracker to report issues:\n// https://github.com/davidbonnet/astring/issues\n\nconst { stringify } = JSON\n\n/* c8 ignore if */\nif (!String.prototype.repeat) {\n  /* c8 ignore next */\n  throw new Error(\n    'String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation',\n  )\n}\n\n/* c8 ignore if */\nif (!String.prototype.endsWith) {\n  /* c8 ignore next */\n  throw new Error(\n    'String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation',\n  )\n}\n\nconst OPERATOR_PRECEDENCE = {\n  '||': 2,\n  '??': 3,\n  '&&': 4,\n  '|': 5,\n  '^': 6,\n  '&': 7,\n  '==': 8,\n  '!=': 8,\n  '===': 8,\n  '!==': 8,\n  '<': 9,\n  '>': 9,\n  '<=': 9,\n  '>=': 9,\n  in: 9,\n  instanceof: 9,\n  '<<': 10,\n  '>>': 10,\n  '>>>': 10,\n  '+': 11,\n  '-': 11,\n  '*': 12,\n  '%': 12,\n  '/': 12,\n  '**': 13,\n}\n\n// Enables parenthesis regardless of precedence\nconst NEEDS_PARENTHESES = 17\n\nconst EXPRESSIONS_PRECEDENCE = {\n  // Definitions\n  ArrayExpression: 20,\n  TaggedTemplateExpression: 20,\n  ThisExpression: 20,\n  Identifier: 20,\n  PrivateIdentifier: 20,\n  Literal: 18,\n  TemplateLiteral: 20,\n  Super: 20,\n  SequenceExpression: 20,\n  // Operations\n  MemberExpression: 19,\n  ChainExpression: 19,\n  CallExpression: 19,\n  NewExpression: 19,\n  // Other definitions\n  ArrowFunctionExpression: NEEDS_PARENTHESES,\n  ClassExpression: NEEDS_PARENTHESES,\n  FunctionExpression: NEEDS_PARENTHESES,\n  ObjectExpression: NEEDS_PARENTHESES,\n  // Other operations\n  UpdateExpression: 16,\n  UnaryExpression: 15,\n  AwaitExpression: 15,\n  BinaryExpression: 14,\n  LogicalExpression: 13,\n  ConditionalExpression: 4,\n  AssignmentExpression: 3,\n  YieldExpression: 2,\n  RestElement: 1,\n}\n\nfunction formatSequence(state, nodes) {\n  /*\n  Writes into `state` a sequence of `nodes`.\n  */\n  const { generator } = state\n  state.write('(')\n  if (nodes != null && nodes.length > 0) {\n    generator[nodes[0].type](nodes[0], state)\n    const { length } = nodes\n    for (let i = 1; i < length; i++) {\n      const param = nodes[i]\n      state.write(', ')\n      generator[param.type](param, state)\n    }\n  }\n  state.write(')')\n}\n\nfunction expressionNeedsParenthesis(state, node, parentNode, isRightHand) {\n  const nodePrecedence = state.expressionsPrecedence[node.type]\n  if (nodePrecedence === NEEDS_PARENTHESES) {\n    return true\n  }\n  const parentNodePrecedence = state.expressionsPrecedence[parentNode.type]\n  if (nodePrecedence !== parentNodePrecedence) {\n    // Different node types\n    return (\n      (!isRightHand &&\n        nodePrecedence === 15 &&\n        parentNodePrecedence === 14 &&\n        parentNode.operator === '**') ||\n      nodePrecedence < parentNodePrecedence\n    )\n  }\n  if (nodePrecedence !== 13 && nodePrecedence !== 14) {\n    // Not a `LogicalExpression` or `BinaryExpression`\n    return false\n  }\n  if (node.operator === '**' && parentNode.operator === '**') {\n    // Exponentiation operator has right-to-left associativity\n    return !isRightHand\n  }\n  if (\n    nodePrecedence === 13 &&\n    parentNodePrecedence === 13 &&\n    (node.operator === '??' || parentNode.operator === '??')\n  ) {\n    // Nullish coalescing and boolean operators cannot be combined\n    return true\n  }\n  if (isRightHand) {\n    // Parenthesis are used if both operators have the same precedence\n    return (\n      OPERATOR_PRECEDENCE[node.operator] <=\n      OPERATOR_PRECEDENCE[parentNode.operator]\n    )\n  }\n  return (\n    OPERATOR_PRECEDENCE[node.operator] <\n    OPERATOR_PRECEDENCE[parentNode.operator]\n  )\n}\n\nfunction formatExpression(state, node, parentNode, isRightHand) {\n  /*\n  Writes into `state` the provided `node`, adding parenthesis around if the provided `parentNode` needs it. If `node` is a right-hand argument, the provided `isRightHand` parameter should be `true`.\n  */\n  const { generator } = state\n  if (expressionNeedsParenthesis(state, node, parentNode, isRightHand)) {\n    state.write('(')\n    generator[node.type](node, state)\n    state.write(')')\n  } else {\n    generator[node.type](node, state)\n  }\n}\n\nfunction reindent(state, text, indent, lineEnd) {\n  /*\n  Writes into `state` the `text` string reindented with the provided `indent`.\n  */\n  const lines = text.split('\\n')\n  const end = lines.length - 1\n  state.write(lines[0].trim())\n  if (end > 0) {\n    state.write(lineEnd)\n    for (let i = 1; i < end; i++) {\n      state.write(indent + lines[i].trim() + lineEnd)\n    }\n    state.write(indent + lines[end].trim())\n  }\n}\n\nfunction formatComments(state, comments, indent, lineEnd) {\n  /*\n  Writes into `state` the provided list of `comments`, with the given `indent` and `lineEnd` strings.\n  Line comments will end with `\"\\n\"` regardless of the value of `lineEnd`.\n  Expects to start on a new unindented line.\n  */\n  const { length } = comments\n  for (let i = 0; i < length; i++) {\n    const comment = comments[i]\n    state.write(indent)\n    if (comment.type[0] === 'L') {\n      // Line comment\n      state.write('// ' + comment.value.trim() + '\\n', comment)\n    } else {\n      // Block comment\n      state.write('/*')\n      reindent(state, comment.value, indent, lineEnd)\n      state.write('*/' + lineEnd)\n    }\n  }\n}\n\nfunction hasCallExpression(node) {\n  /*\n  Returns `true` if the provided `node` contains a call expression and `false` otherwise.\n  */\n  let currentNode = node\n  while (currentNode != null) {\n    const { type } = currentNode\n    if (type[0] === 'C' && type[1] === 'a') {\n      // Is CallExpression\n      return true\n    } else if (type[0] === 'M' && type[1] === 'e' && type[2] === 'm') {\n      // Is MemberExpression\n      currentNode = currentNode.object\n    } else {\n      return false\n    }\n  }\n}\n\nfunction formatVariableDeclaration(state, node) {\n  /*\n  Writes into `state` a variable declaration.\n  */\n  const { generator } = state\n  const { declarations } = node\n  state.write(node.kind + ' ')\n  const { length } = declarations\n  if (length > 0) {\n    generator.VariableDeclarator(declarations[0], state)\n    for (let i = 1; i < length; i++) {\n      state.write(', ')\n      generator.VariableDeclarator(declarations[i], state)\n    }\n  }\n}\n\nlet ForInStatement,\n  FunctionDeclaration,\n  RestElement,\n  BinaryExpression,\n  ArrayExpression,\n  BlockStatement\n\nconst GENERATOR = {\n  /*\n  Default generator.\n  */\n  Program(node, state) {\n    const indent = state.indent.repeat(state.indentLevel)\n    const { lineEnd, writeComments } = state\n    if (writeComments && node.comments != null) {\n      formatComments(state, node.comments, indent, lineEnd)\n    }\n    const statements = node.body\n    const { length } = statements\n    for (let i = 0; i < length; i++) {\n      const statement = statements[i]\n      if (writeComments && statement.comments != null) {\n        formatComments(state, statement.comments, indent, lineEnd)\n      }\n      state.write(indent)\n      this[statement.type](statement, state)\n      state.write(lineEnd)\n    }\n    if (writeComments && node.trailingComments != null) {\n      formatComments(state, node.trailingComments, indent, lineEnd)\n    }\n  },\n  BlockStatement: (BlockStatement = function (node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    const statementIndent = indent + state.indent\n    state.write('{')\n    const statements = node.body\n    if (statements != null && statements.length > 0) {\n      state.write(lineEnd)\n      if (writeComments && node.comments != null) {\n        formatComments(state, node.comments, statementIndent, lineEnd)\n      }\n      const { length } = statements\n      for (let i = 0; i < length; i++) {\n        const statement = statements[i]\n        if (writeComments && statement.comments != null) {\n          formatComments(state, statement.comments, statementIndent, lineEnd)\n        }\n        state.write(statementIndent)\n        this[statement.type](statement, state)\n        state.write(lineEnd)\n      }\n      state.write(indent)\n    } else {\n      if (writeComments && node.comments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.comments, statementIndent, lineEnd)\n        state.write(indent)\n      }\n    }\n    if (writeComments && node.trailingComments != null) {\n      formatComments(state, node.trailingComments, statementIndent, lineEnd)\n    }\n    state.write('}')\n    state.indentLevel--\n  }),\n  ClassBody: BlockStatement,\n  StaticBlock(node, state) {\n    state.write('static ')\n    this.BlockStatement(node, state)\n  },\n  EmptyStatement(node, state) {\n    state.write(';')\n  },\n  ExpressionStatement(node, state) {\n    const precedence = state.expressionsPrecedence[node.expression.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      (precedence === 3 && node.expression.left.type[0] === 'O')\n    ) {\n      // Should always have parentheses or is an AssignmentExpression to an ObjectPattern\n      state.write('(')\n      this[node.expression.type](node.expression, state)\n      state.write(')')\n    } else {\n      this[node.expression.type](node.expression, state)\n    }\n    state.write(';')\n  },\n  IfStatement(node, state) {\n    state.write('if (')\n    this[node.test.type](node.test, state)\n    state.write(') ')\n    this[node.consequent.type](node.consequent, state)\n    if (node.alternate != null) {\n      state.write(' else ')\n      this[node.alternate.type](node.alternate, state)\n    }\n  },\n  LabeledStatement(node, state) {\n    this[node.label.type](node.label, state)\n    state.write(': ')\n    this[node.body.type](node.body, state)\n  },\n  BreakStatement(node, state) {\n    state.write('break')\n    if (node.label != null) {\n      state.write(' ')\n      this[node.label.type](node.label, state)\n    }\n    state.write(';')\n  },\n  ContinueStatement(node, state) {\n    state.write('continue')\n    if (node.label != null) {\n      state.write(' ')\n      this[node.label.type](node.label, state)\n    }\n    state.write(';')\n  },\n  WithStatement(node, state) {\n    state.write('with (')\n    this[node.object.type](node.object, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  SwitchStatement(node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    state.indentLevel++\n    const caseIndent = indent + state.indent\n    const statementIndent = caseIndent + state.indent\n    state.write('switch (')\n    this[node.discriminant.type](node.discriminant, state)\n    state.write(') {' + lineEnd)\n    const { cases: occurences } = node\n    const { length: occurencesCount } = occurences\n    for (let i = 0; i < occurencesCount; i++) {\n      const occurence = occurences[i]\n      if (writeComments && occurence.comments != null) {\n        formatComments(state, occurence.comments, caseIndent, lineEnd)\n      }\n      if (occurence.test) {\n        state.write(caseIndent + 'case ')\n        this[occurence.test.type](occurence.test, state)\n        state.write(':' + lineEnd)\n      } else {\n        state.write(caseIndent + 'default:' + lineEnd)\n      }\n      const { consequent } = occurence\n      const { length: consequentCount } = consequent\n      for (let i = 0; i < consequentCount; i++) {\n        const statement = consequent[i]\n        if (writeComments && statement.comments != null) {\n          formatComments(state, statement.comments, statementIndent, lineEnd)\n        }\n        state.write(statementIndent)\n        this[statement.type](statement, state)\n        state.write(lineEnd)\n      }\n    }\n    state.indentLevel -= 2\n    state.write(indent + '}')\n  },\n  ReturnStatement(node, state) {\n    state.write('return')\n    if (node.argument) {\n      state.write(' ')\n      this[node.argument.type](node.argument, state)\n    }\n    state.write(';')\n  },\n  ThrowStatement(node, state) {\n    state.write('throw ')\n    this[node.argument.type](node.argument, state)\n    state.write(';')\n  },\n  TryStatement(node, state) {\n    state.write('try ')\n    this[node.block.type](node.block, state)\n    if (node.handler) {\n      const { handler } = node\n      if (handler.param == null) {\n        state.write(' catch ')\n      } else {\n        state.write(' catch (')\n        this[handler.param.type](handler.param, state)\n        state.write(') ')\n      }\n      this[handler.body.type](handler.body, state)\n    }\n    if (node.finalizer) {\n      state.write(' finally ')\n      this[node.finalizer.type](node.finalizer, state)\n    }\n  },\n  WhileStatement(node, state) {\n    state.write('while (')\n    this[node.test.type](node.test, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  DoWhileStatement(node, state) {\n    state.write('do ')\n    this[node.body.type](node.body, state)\n    state.write(' while (')\n    this[node.test.type](node.test, state)\n    state.write(');')\n  },\n  ForStatement(node, state) {\n    state.write('for (')\n    if (node.init != null) {\n      const { init } = node\n      if (init.type[0] === 'V') {\n        formatVariableDeclaration(state, init)\n      } else {\n        this[init.type](init, state)\n      }\n    }\n    state.write('; ')\n    if (node.test) {\n      this[node.test.type](node.test, state)\n    }\n    state.write('; ')\n    if (node.update) {\n      this[node.update.type](node.update, state)\n    }\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  ForInStatement: (ForInStatement = function (node, state) {\n    state.write(`for ${node.await ? 'await ' : ''}(`)\n    const { left } = node\n    if (left.type[0] === 'V') {\n      formatVariableDeclaration(state, left)\n    } else {\n      this[left.type](left, state)\n    }\n    // Identifying whether node.type is `ForInStatement` or `ForOfStatement`\n    state.write(node.type[3] === 'I' ? ' in ' : ' of ')\n    this[node.right.type](node.right, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  }),\n  ForOfStatement: ForInStatement,\n  DebuggerStatement(node, state) {\n    state.write('debugger;', node)\n  },\n  FunctionDeclaration: (FunctionDeclaration = function (node, state) {\n    state.write(\n      (node.async ? 'async ' : '') +\n        (node.generator ? 'function* ' : 'function ') +\n        (node.id ? node.id.name : ''),\n      node,\n    )\n    formatSequence(state, node.params)\n    state.write(' ')\n    this[node.body.type](node.body, state)\n  }),\n  FunctionExpression: FunctionDeclaration,\n  VariableDeclaration(node, state) {\n    formatVariableDeclaration(state, node)\n    state.write(';')\n  },\n  VariableDeclarator(node, state) {\n    this[node.id.type](node.id, state)\n    if (node.init != null) {\n      state.write(' = ')\n      this[node.init.type](node.init, state)\n    }\n  },\n  ClassDeclaration(node, state) {\n    state.write('class ' + (node.id ? `${node.id.name} ` : ''), node)\n    if (node.superClass) {\n      state.write('extends ')\n      const { superClass } = node\n      const { type } = superClass\n      const precedence = state.expressionsPrecedence[type]\n      if (\n        (type[0] !== 'C' || type[1] !== 'l' || type[5] !== 'E') &&\n        (precedence === NEEDS_PARENTHESES ||\n          precedence < state.expressionsPrecedence.ClassExpression)\n      ) {\n        // Not a ClassExpression that needs parentheses\n        state.write('(')\n        this[node.superClass.type](superClass, state)\n        state.write(')')\n      } else {\n        this[superClass.type](superClass, state)\n      }\n      state.write(' ')\n    }\n    this.ClassBody(node.body, state)\n  },\n  ImportDeclaration(node, state) {\n    state.write('import ')\n    const { specifiers, attributes } = node\n    const { length } = specifiers\n    // TODO: Once babili is fixed, put this after condition\n    // https://github.com/babel/babili/issues/430\n    let i = 0\n    if (length > 0) {\n      for (; i < length; ) {\n        if (i > 0) {\n          state.write(', ')\n        }\n        const specifier = specifiers[i]\n        const type = specifier.type[6]\n        if (type === 'D') {\n          // ImportDefaultSpecifier\n          state.write(specifier.local.name, specifier)\n          i++\n        } else if (type === 'N') {\n          // ImportNamespaceSpecifier\n          state.write('* as ' + specifier.local.name, specifier)\n          i++\n        } else {\n          // ImportSpecifier\n          break\n        }\n      }\n      if (i < length) {\n        state.write('{')\n        for (;;) {\n          const specifier = specifiers[i]\n          const { name } = specifier.imported\n          state.write(name, specifier)\n          if (name !== specifier.local.name) {\n            state.write(' as ' + specifier.local.name)\n          }\n          if (++i < length) {\n            state.write(', ')\n          } else {\n            break\n          }\n        }\n        state.write('}')\n      }\n      state.write(' from ')\n    }\n    this.Literal(node.source, state)\n\n    if (attributes && attributes.length > 0) {\n      state.write(' with { ')\n      for (let i = 0; i < attributes.length; i++) {\n        this.ImportAttribute(attributes[i], state)\n        if (i < attributes.length - 1) state.write(', ')\n      }\n\n      state.write(' }')\n    }\n    state.write(';')\n  },\n  ImportAttribute(node, state) {\n    this.Identifier(node.key, state)\n    state.write(': ')\n    this.Literal(node.value, state)\n  },\n  ImportExpression(node, state) {\n    state.write('import(')\n    this[node.source.type](node.source, state)\n    state.write(')')\n  },\n  ExportDefaultDeclaration(node, state) {\n    state.write('export default ')\n    this[node.declaration.type](node.declaration, state)\n    if (\n      state.expressionsPrecedence[node.declaration.type] != null &&\n      node.declaration.type[0] !== 'F'\n    ) {\n      // All expression nodes except `FunctionExpression`\n      state.write(';')\n    }\n  },\n  ExportNamedDeclaration(node, state) {\n    state.write('export ')\n    if (node.declaration) {\n      this[node.declaration.type](node.declaration, state)\n    } else {\n      state.write('{')\n      const { specifiers } = node,\n        { length } = specifiers\n      if (length > 0) {\n        for (let i = 0; ; ) {\n          const specifier = specifiers[i]\n          const { name } = specifier.local\n          state.write(name, specifier)\n          if (name !== specifier.exported.name) {\n            state.write(' as ' + specifier.exported.name)\n          }\n          if (++i < length) {\n            state.write(', ')\n          } else {\n            break\n          }\n        }\n      }\n      state.write('}')\n      if (node.source) {\n        state.write(' from ')\n        this.Literal(node.source, state)\n      }\n\n      if (node.attributes && node.attributes.length > 0) {\n        state.write(' with { ')\n        for (let i = 0; i < node.attributes.length; i++) {\n          this.ImportAttribute(node.attributes[i], state)\n          if (i < node.attributes.length - 1) state.write(', ')\n        }\n\n        state.write(' }')\n      }\n\n      state.write(';')\n    }\n  },\n  ExportAllDeclaration(node, state) {\n    if (node.exported != null) {\n      state.write('export * as ' + node.exported.name + ' from ')\n    } else {\n      state.write('export * from ')\n    }\n    this.Literal(node.source, state)\n\n    if (node.attributes && node.attributes.length > 0) {\n      state.write(' with { ')\n      for (let i = 0; i < node.attributes.length; i++) {\n        this.ImportAttribute(node.attributes[i], state)\n        if (i < node.attributes.length - 1) state.write(', ')\n      }\n\n      state.write(' }')\n    }\n\n    state.write(';')\n  },\n  MethodDefinition(node, state) {\n    if (node.static) {\n      state.write('static ')\n    }\n    const kind = node.kind[0]\n    if (kind === 'g' || kind === 's') {\n      // Getter or setter\n      state.write(node.kind + ' ')\n    }\n    if (node.value.async) {\n      state.write('async ')\n    }\n    if (node.value.generator) {\n      state.write('*')\n    }\n    if (node.computed) {\n      state.write('[')\n      this[node.key.type](node.key, state)\n      state.write(']')\n    } else {\n      this[node.key.type](node.key, state)\n    }\n    formatSequence(state, node.value.params)\n    state.write(' ')\n    this[node.value.body.type](node.value.body, state)\n  },\n  ClassExpression(node, state) {\n    this.ClassDeclaration(node, state)\n  },\n  ArrowFunctionExpression(node, state) {\n    state.write(node.async ? 'async ' : '', node)\n    const { params } = node\n    if (params != null) {\n      // Omit parenthesis if only one named parameter\n      if (params.length === 1 && params[0].type[0] === 'I') {\n        // If params[0].type[0] starts with 'I', it can't be `ImportDeclaration` nor `IfStatement` and thus is `Identifier`\n        state.write(params[0].name, params[0])\n      } else {\n        formatSequence(state, node.params)\n      }\n    }\n    state.write(' => ')\n    if (node.body.type[0] === 'O') {\n      // Body is an object expression\n      state.write('(')\n      this.ObjectExpression(node.body, state)\n      state.write(')')\n    } else {\n      this[node.body.type](node.body, state)\n    }\n  },\n  ThisExpression(node, state) {\n    state.write('this', node)\n  },\n  Super(node, state) {\n    state.write('super', node)\n  },\n  RestElement: (RestElement = function (node, state) {\n    state.write('...')\n    this[node.argument.type](node.argument, state)\n  }),\n  SpreadElement: RestElement,\n  YieldExpression(node, state) {\n    state.write(node.delegate ? 'yield*' : 'yield')\n    if (node.argument) {\n      state.write(' ')\n      this[node.argument.type](node.argument, state)\n    }\n  },\n  AwaitExpression(node, state) {\n    state.write('await ', node)\n    formatExpression(state, node.argument, node)\n  },\n  TemplateLiteral(node, state) {\n    const { quasis, expressions } = node\n    state.write('`')\n    const { length } = expressions\n    for (let i = 0; i < length; i++) {\n      const expression = expressions[i]\n      const quasi = quasis[i]\n      state.write(quasi.value.raw, quasi)\n      state.write('${')\n      this[expression.type](expression, state)\n      state.write('}')\n    }\n    const quasi = quasis[quasis.length - 1]\n    state.write(quasi.value.raw, quasi)\n    state.write('`')\n  },\n  TemplateElement(node, state) {\n    state.write(node.value.raw, node)\n  },\n  TaggedTemplateExpression(node, state) {\n    formatExpression(state, node.tag, node)\n    this[node.quasi.type](node.quasi, state)\n  },\n  ArrayExpression: (ArrayExpression = function (node, state) {\n    state.write('[')\n    if (node.elements.length > 0) {\n      const { elements } = node,\n        { length } = elements\n      for (let i = 0; ; ) {\n        const element = elements[i]\n        if (element != null) {\n          this[element.type](element, state)\n        }\n        if (++i < length) {\n          state.write(', ')\n        } else {\n          if (element == null) {\n            state.write(', ')\n          }\n          break\n        }\n      }\n    }\n    state.write(']')\n  }),\n  ArrayPattern: ArrayExpression,\n  ObjectExpression(node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    const propertyIndent = indent + state.indent\n    state.write('{')\n    if (node.properties.length > 0) {\n      state.write(lineEnd)\n      if (writeComments && node.comments != null) {\n        formatComments(state, node.comments, propertyIndent, lineEnd)\n      }\n      const comma = ',' + lineEnd\n      const { properties } = node,\n        { length } = properties\n      for (let i = 0; ; ) {\n        const property = properties[i]\n        if (writeComments && property.comments != null) {\n          formatComments(state, property.comments, propertyIndent, lineEnd)\n        }\n        state.write(propertyIndent)\n        this[property.type](property, state)\n        if (++i < length) {\n          state.write(comma)\n        } else {\n          break\n        }\n      }\n      state.write(lineEnd)\n      if (writeComments && node.trailingComments != null) {\n        formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n      }\n      state.write(indent + '}')\n    } else if (writeComments) {\n      if (node.comments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.comments, propertyIndent, lineEnd)\n        if (node.trailingComments != null) {\n          formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n        }\n        state.write(indent + '}')\n      } else if (node.trailingComments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n        state.write(indent + '}')\n      } else {\n        state.write('}')\n      }\n    } else {\n      state.write('}')\n    }\n    state.indentLevel--\n  },\n  Property(node, state) {\n    if (node.method || node.kind[0] !== 'i') {\n      // Either a method or of kind `set` or `get` (not `init`)\n      this.MethodDefinition(node, state)\n    } else {\n      if (!node.shorthand) {\n        if (node.computed) {\n          state.write('[')\n          this[node.key.type](node.key, state)\n          state.write(']')\n        } else {\n          this[node.key.type](node.key, state)\n        }\n        state.write(': ')\n      }\n      this[node.value.type](node.value, state)\n    }\n  },\n  PropertyDefinition(node, state) {\n    if (node.static) {\n      state.write('static ')\n    }\n    if (node.computed) {\n      state.write('[')\n    }\n    this[node.key.type](node.key, state)\n    if (node.computed) {\n      state.write(']')\n    }\n    if (node.value == null) {\n      if (node.key.type[0] !== 'F') {\n        state.write(';')\n      }\n      return\n    }\n    state.write(' = ')\n    this[node.value.type](node.value, state)\n    state.write(';')\n  },\n  ObjectPattern(node, state) {\n    state.write('{')\n    if (node.properties.length > 0) {\n      const { properties } = node,\n        { length } = properties\n      for (let i = 0; ; ) {\n        this[properties[i].type](properties[i], state)\n        if (++i < length) {\n          state.write(', ')\n        } else {\n          break\n        }\n      }\n    }\n    state.write('}')\n  },\n  SequenceExpression(node, state) {\n    formatSequence(state, node.expressions)\n  },\n  UnaryExpression(node, state) {\n    if (node.prefix) {\n      const {\n        operator,\n        argument,\n        argument: { type },\n      } = node\n      state.write(operator)\n      const needsParentheses = expressionNeedsParenthesis(state, argument, node)\n      if (\n        !needsParentheses &&\n        (operator.length > 1 ||\n          (type[0] === 'U' &&\n            (type[1] === 'n' || type[1] === 'p') &&\n            argument.prefix &&\n            argument.operator[0] === operator &&\n            (operator === '+' || operator === '-')))\n      ) {\n        // Large operator or argument is UnaryExpression or UpdateExpression node\n        state.write(' ')\n      }\n      if (needsParentheses) {\n        state.write(operator.length > 1 ? ' (' : '(')\n        this[type](argument, state)\n        state.write(')')\n      } else {\n        this[type](argument, state)\n      }\n    } else {\n      // FIXME: This case never occurs\n      this[node.argument.type](node.argument, state)\n      state.write(node.operator)\n    }\n  },\n  UpdateExpression(node, state) {\n    // Always applied to identifiers or members, no parenthesis check needed\n    if (node.prefix) {\n      state.write(node.operator)\n      this[node.argument.type](node.argument, state)\n    } else {\n      this[node.argument.type](node.argument, state)\n      state.write(node.operator)\n    }\n  },\n  AssignmentExpression(node, state) {\n    this[node.left.type](node.left, state)\n    state.write(' ' + node.operator + ' ')\n    this[node.right.type](node.right, state)\n  },\n  AssignmentPattern(node, state) {\n    this[node.left.type](node.left, state)\n    state.write(' = ')\n    this[node.right.type](node.right, state)\n  },\n  BinaryExpression: (BinaryExpression = function (node, state) {\n    const isIn = node.operator === 'in'\n    if (isIn) {\n      // Avoids confusion in `for` loops initializers\n      state.write('(')\n    }\n    formatExpression(state, node.left, node, false)\n    state.write(' ' + node.operator + ' ')\n    formatExpression(state, node.right, node, true)\n    if (isIn) {\n      state.write(')')\n    }\n  }),\n  LogicalExpression: BinaryExpression,\n  ConditionalExpression(node, state) {\n    const { test } = node\n    const precedence = state.expressionsPrecedence[test.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence <= state.expressionsPrecedence.ConditionalExpression\n    ) {\n      state.write('(')\n      this[test.type](test, state)\n      state.write(')')\n    } else {\n      this[test.type](test, state)\n    }\n    state.write(' ? ')\n    this[node.consequent.type](node.consequent, state)\n    state.write(' : ')\n    this[node.alternate.type](node.alternate, state)\n  },\n  NewExpression(node, state) {\n    state.write('new ')\n    const precedence = state.expressionsPrecedence[node.callee.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.CallExpression ||\n      hasCallExpression(node.callee)\n    ) {\n      state.write('(')\n      this[node.callee.type](node.callee, state)\n      state.write(')')\n    } else {\n      this[node.callee.type](node.callee, state)\n    }\n    formatSequence(state, node['arguments'])\n  },\n  CallExpression(node, state) {\n    const precedence = state.expressionsPrecedence[node.callee.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.CallExpression\n    ) {\n      state.write('(')\n      this[node.callee.type](node.callee, state)\n      state.write(')')\n    } else {\n      this[node.callee.type](node.callee, state)\n    }\n    if (node.optional) {\n      state.write('?.')\n    }\n    formatSequence(state, node['arguments'])\n  },\n  ChainExpression(node, state) {\n    this[node.expression.type](node.expression, state)\n  },\n  MemberExpression(node, state) {\n    const precedence = state.expressionsPrecedence[node.object.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.MemberExpression\n    ) {\n      state.write('(')\n      this[node.object.type](node.object, state)\n      state.write(')')\n    } else {\n      this[node.object.type](node.object, state)\n    }\n    if (node.computed) {\n      if (node.optional) {\n        state.write('?.')\n      }\n      state.write('[')\n      this[node.property.type](node.property, state)\n      state.write(']')\n    } else {\n      if (node.optional) {\n        state.write('?.')\n      } else {\n        state.write('.')\n      }\n      this[node.property.type](node.property, state)\n    }\n  },\n  MetaProperty(node, state) {\n    state.write(node.meta.name + '.' + node.property.name, node)\n  },\n  Identifier(node, state) {\n    state.write(node.name, node)\n  },\n  PrivateIdentifier(node, state) {\n    state.write(`#${node.name}`, node)\n  },\n  Literal(node, state) {\n    if (node.raw != null) {\n      // Non-standard property\n      state.write(node.raw, node)\n    } else if (node.regex != null) {\n      this.RegExpLiteral(node, state)\n    } else if (node.bigint != null) {\n      state.write(node.bigint + 'n', node)\n    } else {\n      state.write(stringify(node.value), node)\n    }\n  },\n  RegExpLiteral(node, state) {\n    const { regex } = node\n    state.write(`/${regex.pattern}/${regex.flags}`, node)\n  },\n}\n\nconst EMPTY_OBJECT = {}\n\n/*\nDEPRECATED: Alternate export of `GENERATOR`.\n*/\nconst baseGenerator = GENERATOR\n\nclass State {\n  constructor(options) {\n    const setup = options == null ? EMPTY_OBJECT : options\n    this.output = ''\n    // Functional options\n    if (setup.output != null) {\n      this.output = setup.output\n      this.write = this.writeToStream\n    } else {\n      this.output = ''\n    }\n    this.generator = setup.generator != null ? setup.generator : GENERATOR\n    this.expressionsPrecedence =\n      setup.expressionsPrecedence != null\n        ? setup.expressionsPrecedence\n        : EXPRESSIONS_PRECEDENCE\n    // Formating setup\n    this.indent = setup.indent != null ? setup.indent : '  '\n    this.lineEnd = setup.lineEnd != null ? setup.lineEnd : '\\n'\n    this.indentLevel =\n      setup.startingIndentLevel != null ? setup.startingIndentLevel : 0\n    this.writeComments = setup.comments ? setup.comments : false\n    // Source map\n    if (setup.sourceMap != null) {\n      this.write =\n        setup.output == null ? this.writeAndMap : this.writeToStreamAndMap\n      this.sourceMap = setup.sourceMap\n      this.line = 1\n      this.column = 0\n      this.lineEndSize = this.lineEnd.split('\\n').length - 1\n      this.mapping = {\n        original: null,\n        // Uses the entire state to avoid generating ephemeral objects\n        generated: this,\n        name: undefined,\n        source: setup.sourceMap.file || setup.sourceMap._file,\n      }\n    }\n  }\n\n  write(code) {\n    this.output += code\n  }\n\n  writeToStream(code) {\n    this.output.write(code)\n  }\n\n  writeAndMap(code, node) {\n    this.output += code\n    this.map(code, node)\n  }\n\n  writeToStreamAndMap(code, node) {\n    this.output.write(code)\n    this.map(code, node)\n  }\n\n  map(code, node) {\n    if (node != null) {\n      const { type } = node\n      if (type[0] === 'L' && type[2] === 'n') {\n        // LineComment\n        this.column = 0\n        this.line++\n        return\n      }\n      if (node.loc != null) {\n        const { mapping } = this\n        mapping.original = node.loc.start\n        mapping.name = node.name\n        this.sourceMap.addMapping(mapping)\n      }\n      if (\n        (type[0] === 'T' && type[8] === 'E') ||\n        (type[0] === 'L' && type[1] === 'i' && typeof node.value === 'string')\n      ) {\n        // TemplateElement or Literal string node\n        const { length } = code\n        let { column, line } = this\n        for (let i = 0; i < length; i++) {\n          if (code[i] === '\\n') {\n            column = 0\n            line++\n          } else {\n            column++\n          }\n        }\n        this.column = column\n        this.line = line\n        return\n      }\n    }\n    const { length } = code\n    const { lineEnd } = this\n    if (length > 0) {\n      if (\n        this.lineEndSize > 0 &&\n        (lineEnd.length === 1\n          ? code[length - 1] === lineEnd\n          : code.endsWith(lineEnd))\n      ) {\n        this.line += this.lineEndSize\n        this.column = 0\n      } else {\n        this.column += length\n      }\n    }\n  }\n\n  toString() {\n    return this.output\n  }\n}\n\nfunction generate(node, options) {\n  /*\n  Returns a string representing the rendered code of the provided AST `node`.\n  The `options` are:\n\n  - `indent`: string to use for indentation (defaults to `␣␣`)\n  - `lineEnd`: string to use for line endings (defaults to `\\n`)\n  - `startingIndentLevel`: indent level to start from (defaults to `0`)\n  - `comments`: generate comments if `true` (defaults to `false`)\n  - `output`: output stream to write the rendered code to (defaults to `null`)\n  - `generator`: custom code generator (defaults to `GENERATOR`)\n  - `expressionsPrecedence`: custom map of node types and their precedence level (defaults to `EXPRESSIONS_PRECEDENCE`)\n  */\n  const state = new State(options)\n  // Travel through the AST node and generate the code\n  state.generator[node.type](node, state)\n  return state.output\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FzdHJpbmdAMS45LjAvbm9kZV9tb2R1bGVzL2FzdHJpbmcvZGlzdC9hc3RyaW5nLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPOztBQUVBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGNBQWMsZUFBZTtBQUM3Qix3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdWFuZWxhX2NvbW8vRG9jdW1lbnRzL2RldmVsb3BtZW50L25vZGVqcy9hcmtvcy9ub2RlX21vZHVsZXMvLnBucG0vYXN0cmluZ0AxLjkuMC9ub2RlX21vZHVsZXMvYXN0cmluZy9kaXN0L2FzdHJpbmcubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEFzdHJpbmcgaXMgYSB0aW55IGFuZCBmYXN0IEphdmFTY3JpcHQgY29kZSBnZW5lcmF0b3IgZnJvbSBhbiBFU1RyZWUtY29tcGxpYW50IEFTVC5cbi8vXG4vLyBBc3RyaW5nIHdhcyB3cml0dGVuIGJ5IERhdmlkIEJvbm5ldCBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2UuXG4vL1xuLy8gVGhlIEdpdCByZXBvc2l0b3J5IGZvciBBc3RyaW5nIGlzIGF2YWlsYWJsZSBhdDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGJvbm5ldC9hc3RyaW5nLmdpdFxuLy9cbi8vIFBsZWFzZSB1c2UgdGhlIEdpdEh1YiBidWcgdHJhY2tlciB0byByZXBvcnQgaXNzdWVzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkYm9ubmV0L2FzdHJpbmcvaXNzdWVzXG5cbmNvbnN0IHsgc3RyaW5naWZ5IH0gPSBKU09OXG5cbi8qIGM4IGlnbm9yZSBpZiAqL1xuaWYgKCFTdHJpbmcucHJvdG90eXBlLnJlcGVhdCkge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ1N0cmluZy5wcm90b3R5cGUucmVwZWF0IGlzIHVuZGVmaW5lZCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGJvbm5ldC9hc3RyaW5nI2luc3RhbGxhdGlvbicsXG4gIClcbn1cblxuLyogYzggaWdub3JlIGlmICovXG5pZiAoIVN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgpIHtcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICdTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoIGlzIHVuZGVmaW5lZCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGJvbm5ldC9hc3RyaW5nI2luc3RhbGxhdGlvbicsXG4gIClcbn1cblxuY29uc3QgT1BFUkFUT1JfUFJFQ0VERU5DRSA9IHtcbiAgJ3x8JzogMixcbiAgJz8/JzogMyxcbiAgJyYmJzogNCxcbiAgJ3wnOiA1LFxuICAnXic6IDYsXG4gICcmJzogNyxcbiAgJz09JzogOCxcbiAgJyE9JzogOCxcbiAgJz09PSc6IDgsXG4gICchPT0nOiA4LFxuICAnPCc6IDksXG4gICc+JzogOSxcbiAgJzw9JzogOSxcbiAgJz49JzogOSxcbiAgaW46IDksXG4gIGluc3RhbmNlb2Y6IDksXG4gICc8PCc6IDEwLFxuICAnPj4nOiAxMCxcbiAgJz4+Pic6IDEwLFxuICAnKyc6IDExLFxuICAnLSc6IDExLFxuICAnKic6IDEyLFxuICAnJSc6IDEyLFxuICAnLyc6IDEyLFxuICAnKionOiAxMyxcbn1cblxuLy8gRW5hYmxlcyBwYXJlbnRoZXNpcyByZWdhcmRsZXNzIG9mIHByZWNlZGVuY2VcbmV4cG9ydCBjb25zdCBORUVEU19QQVJFTlRIRVNFUyA9IDE3XG5cbmV4cG9ydCBjb25zdCBFWFBSRVNTSU9OU19QUkVDRURFTkNFID0ge1xuICAvLyBEZWZpbml0aW9uc1xuICBBcnJheUV4cHJlc3Npb246IDIwLFxuICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246IDIwLFxuICBUaGlzRXhwcmVzc2lvbjogMjAsXG4gIElkZW50aWZpZXI6IDIwLFxuICBQcml2YXRlSWRlbnRpZmllcjogMjAsXG4gIExpdGVyYWw6IDE4LFxuICBUZW1wbGF0ZUxpdGVyYWw6IDIwLFxuICBTdXBlcjogMjAsXG4gIFNlcXVlbmNlRXhwcmVzc2lvbjogMjAsXG4gIC8vIE9wZXJhdGlvbnNcbiAgTWVtYmVyRXhwcmVzc2lvbjogMTksXG4gIENoYWluRXhwcmVzc2lvbjogMTksXG4gIENhbGxFeHByZXNzaW9uOiAxOSxcbiAgTmV3RXhwcmVzc2lvbjogMTksXG4gIC8vIE90aGVyIGRlZmluaXRpb25zXG4gIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiBORUVEU19QQVJFTlRIRVNFUyxcbiAgQ2xhc3NFeHByZXNzaW9uOiBORUVEU19QQVJFTlRIRVNFUyxcbiAgRnVuY3Rpb25FeHByZXNzaW9uOiBORUVEU19QQVJFTlRIRVNFUyxcbiAgT2JqZWN0RXhwcmVzc2lvbjogTkVFRFNfUEFSRU5USEVTRVMsXG4gIC8vIE90aGVyIG9wZXJhdGlvbnNcbiAgVXBkYXRlRXhwcmVzc2lvbjogMTYsXG4gIFVuYXJ5RXhwcmVzc2lvbjogMTUsXG4gIEF3YWl0RXhwcmVzc2lvbjogMTUsXG4gIEJpbmFyeUV4cHJlc3Npb246IDE0LFxuICBMb2dpY2FsRXhwcmVzc2lvbjogMTMsXG4gIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogNCxcbiAgQXNzaWdubWVudEV4cHJlc3Npb246IDMsXG4gIFlpZWxkRXhwcmVzc2lvbjogMixcbiAgUmVzdEVsZW1lbnQ6IDEsXG59XG5cbmZ1bmN0aW9uIGZvcm1hdFNlcXVlbmNlKHN0YXRlLCBub2Rlcykge1xuICAvKlxuICBXcml0ZXMgaW50byBgc3RhdGVgIGEgc2VxdWVuY2Ugb2YgYG5vZGVzYC5cbiAgKi9cbiAgY29uc3QgeyBnZW5lcmF0b3IgfSA9IHN0YXRlXG4gIHN0YXRlLndyaXRlKCcoJylcbiAgaWYgKG5vZGVzICE9IG51bGwgJiYgbm9kZXMubGVuZ3RoID4gMCkge1xuICAgIGdlbmVyYXRvcltub2Rlc1swXS50eXBlXShub2Rlc1swXSwgc3RhdGUpXG4gICAgY29uc3QgeyBsZW5ndGggfSA9IG5vZGVzXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFyYW0gPSBub2Rlc1tpXVxuICAgICAgc3RhdGUud3JpdGUoJywgJylcbiAgICAgIGdlbmVyYXRvcltwYXJhbS50eXBlXShwYXJhbSwgc3RhdGUpXG4gICAgfVxuICB9XG4gIHN0YXRlLndyaXRlKCcpJylcbn1cblxuZnVuY3Rpb24gZXhwcmVzc2lvbk5lZWRzUGFyZW50aGVzaXMoc3RhdGUsIG5vZGUsIHBhcmVudE5vZGUsIGlzUmlnaHRIYW5kKSB7XG4gIGNvbnN0IG5vZGVQcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW25vZGUudHlwZV1cbiAgaWYgKG5vZGVQcmVjZWRlbmNlID09PSBORUVEU19QQVJFTlRIRVNFUykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgY29uc3QgcGFyZW50Tm9kZVByZWNlZGVuY2UgPSBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2VbcGFyZW50Tm9kZS50eXBlXVxuICBpZiAobm9kZVByZWNlZGVuY2UgIT09IHBhcmVudE5vZGVQcmVjZWRlbmNlKSB7XG4gICAgLy8gRGlmZmVyZW50IG5vZGUgdHlwZXNcbiAgICByZXR1cm4gKFxuICAgICAgKCFpc1JpZ2h0SGFuZCAmJlxuICAgICAgICBub2RlUHJlY2VkZW5jZSA9PT0gMTUgJiZcbiAgICAgICAgcGFyZW50Tm9kZVByZWNlZGVuY2UgPT09IDE0ICYmXG4gICAgICAgIHBhcmVudE5vZGUub3BlcmF0b3IgPT09ICcqKicpIHx8XG4gICAgICBub2RlUHJlY2VkZW5jZSA8IHBhcmVudE5vZGVQcmVjZWRlbmNlXG4gICAgKVxuICB9XG4gIGlmIChub2RlUHJlY2VkZW5jZSAhPT0gMTMgJiYgbm9kZVByZWNlZGVuY2UgIT09IDE0KSB7XG4gICAgLy8gTm90IGEgYExvZ2ljYWxFeHByZXNzaW9uYCBvciBgQmluYXJ5RXhwcmVzc2lvbmBcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS5vcGVyYXRvciA9PT0gJyoqJyAmJiBwYXJlbnROb2RlLm9wZXJhdG9yID09PSAnKionKSB7XG4gICAgLy8gRXhwb25lbnRpYXRpb24gb3BlcmF0b3IgaGFzIHJpZ2h0LXRvLWxlZnQgYXNzb2NpYXRpdml0eVxuICAgIHJldHVybiAhaXNSaWdodEhhbmRcbiAgfVxuICBpZiAoXG4gICAgbm9kZVByZWNlZGVuY2UgPT09IDEzICYmXG4gICAgcGFyZW50Tm9kZVByZWNlZGVuY2UgPT09IDEzICYmXG4gICAgKG5vZGUub3BlcmF0b3IgPT09ICc/PycgfHwgcGFyZW50Tm9kZS5vcGVyYXRvciA9PT0gJz8/JylcbiAgKSB7XG4gICAgLy8gTnVsbGlzaCBjb2FsZXNjaW5nIGFuZCBib29sZWFuIG9wZXJhdG9ycyBjYW5ub3QgYmUgY29tYmluZWRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1JpZ2h0SGFuZCkge1xuICAgIC8vIFBhcmVudGhlc2lzIGFyZSB1c2VkIGlmIGJvdGggb3BlcmF0b3JzIGhhdmUgdGhlIHNhbWUgcHJlY2VkZW5jZVxuICAgIHJldHVybiAoXG4gICAgICBPUEVSQVRPUl9QUkVDRURFTkNFW25vZGUub3BlcmF0b3JdIDw9XG4gICAgICBPUEVSQVRPUl9QUkVDRURFTkNFW3BhcmVudE5vZGUub3BlcmF0b3JdXG4gICAgKVxuICB9XG4gIHJldHVybiAoXG4gICAgT1BFUkFUT1JfUFJFQ0VERU5DRVtub2RlLm9wZXJhdG9yXSA8XG4gICAgT1BFUkFUT1JfUFJFQ0VERU5DRVtwYXJlbnROb2RlLm9wZXJhdG9yXVxuICApXG59XG5cbmZ1bmN0aW9uIGZvcm1hdEV4cHJlc3Npb24oc3RhdGUsIG5vZGUsIHBhcmVudE5vZGUsIGlzUmlnaHRIYW5kKSB7XG4gIC8qXG4gIFdyaXRlcyBpbnRvIGBzdGF0ZWAgdGhlIHByb3ZpZGVkIGBub2RlYCwgYWRkaW5nIHBhcmVudGhlc2lzIGFyb3VuZCBpZiB0aGUgcHJvdmlkZWQgYHBhcmVudE5vZGVgIG5lZWRzIGl0LiBJZiBgbm9kZWAgaXMgYSByaWdodC1oYW5kIGFyZ3VtZW50LCB0aGUgcHJvdmlkZWQgYGlzUmlnaHRIYW5kYCBwYXJhbWV0ZXIgc2hvdWxkIGJlIGB0cnVlYC5cbiAgKi9cbiAgY29uc3QgeyBnZW5lcmF0b3IgfSA9IHN0YXRlXG4gIGlmIChleHByZXNzaW9uTmVlZHNQYXJlbnRoZXNpcyhzdGF0ZSwgbm9kZSwgcGFyZW50Tm9kZSwgaXNSaWdodEhhbmQpKSB7XG4gICAgc3RhdGUud3JpdGUoJygnKVxuICAgIGdlbmVyYXRvcltub2RlLnR5cGVdKG5vZGUsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpJylcbiAgfSBlbHNlIHtcbiAgICBnZW5lcmF0b3Jbbm9kZS50eXBlXShub2RlLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiByZWluZGVudChzdGF0ZSwgdGV4dCwgaW5kZW50LCBsaW5lRW5kKSB7XG4gIC8qXG4gIFdyaXRlcyBpbnRvIGBzdGF0ZWAgdGhlIGB0ZXh0YCBzdHJpbmcgcmVpbmRlbnRlZCB3aXRoIHRoZSBwcm92aWRlZCBgaW5kZW50YC5cbiAgKi9cbiAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKVxuICBjb25zdCBlbmQgPSBsaW5lcy5sZW5ndGggLSAxXG4gIHN0YXRlLndyaXRlKGxpbmVzWzBdLnRyaW0oKSlcbiAgaWYgKGVuZCA+IDApIHtcbiAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHN0YXRlLndyaXRlKGluZGVudCArIGxpbmVzW2ldLnRyaW0oKSArIGxpbmVFbmQpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKGluZGVudCArIGxpbmVzW2VuZF0udHJpbSgpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBjb21tZW50cywgaW5kZW50LCBsaW5lRW5kKSB7XG4gIC8qXG4gIFdyaXRlcyBpbnRvIGBzdGF0ZWAgdGhlIHByb3ZpZGVkIGxpc3Qgb2YgYGNvbW1lbnRzYCwgd2l0aCB0aGUgZ2l2ZW4gYGluZGVudGAgYW5kIGBsaW5lRW5kYCBzdHJpbmdzLlxuICBMaW5lIGNvbW1lbnRzIHdpbGwgZW5kIHdpdGggYFwiXFxuXCJgIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIGBsaW5lRW5kYC5cbiAgRXhwZWN0cyB0byBzdGFydCBvbiBhIG5ldyB1bmluZGVudGVkIGxpbmUuXG4gICovXG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBjb21tZW50c1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29tbWVudCA9IGNvbW1lbnRzW2ldXG4gICAgc3RhdGUud3JpdGUoaW5kZW50KVxuICAgIGlmIChjb21tZW50LnR5cGVbMF0gPT09ICdMJykge1xuICAgICAgLy8gTGluZSBjb21tZW50XG4gICAgICBzdGF0ZS53cml0ZSgnLy8gJyArIGNvbW1lbnQudmFsdWUudHJpbSgpICsgJ1xcbicsIGNvbW1lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJsb2NrIGNvbW1lbnRcbiAgICAgIHN0YXRlLndyaXRlKCcvKicpXG4gICAgICByZWluZGVudChzdGF0ZSwgY29tbWVudC52YWx1ZSwgaW5kZW50LCBsaW5lRW5kKVxuICAgICAgc3RhdGUud3JpdGUoJyovJyArIGxpbmVFbmQpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0NhbGxFeHByZXNzaW9uKG5vZGUpIHtcbiAgLypcbiAgUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3ZpZGVkIGBub2RlYCBjb250YWlucyBhIGNhbGwgZXhwcmVzc2lvbiBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gICovXG4gIGxldCBjdXJyZW50Tm9kZSA9IG5vZGVcbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICBjb25zdCB7IHR5cGUgfSA9IGN1cnJlbnROb2RlXG4gICAgaWYgKHR5cGVbMF0gPT09ICdDJyAmJiB0eXBlWzFdID09PSAnYScpIHtcbiAgICAgIC8vIElzIENhbGxFeHByZXNzaW9uXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAodHlwZVswXSA9PT0gJ00nICYmIHR5cGVbMV0gPT09ICdlJyAmJiB0eXBlWzJdID09PSAnbScpIHtcbiAgICAgIC8vIElzIE1lbWJlckV4cHJlc3Npb25cbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUub2JqZWN0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRWYXJpYWJsZURlY2xhcmF0aW9uKHN0YXRlLCBub2RlKSB7XG4gIC8qXG4gIFdyaXRlcyBpbnRvIGBzdGF0ZWAgYSB2YXJpYWJsZSBkZWNsYXJhdGlvbi5cbiAgKi9cbiAgY29uc3QgeyBnZW5lcmF0b3IgfSA9IHN0YXRlXG4gIGNvbnN0IHsgZGVjbGFyYXRpb25zIH0gPSBub2RlXG4gIHN0YXRlLndyaXRlKG5vZGUua2luZCArICcgJylcbiAgY29uc3QgeyBsZW5ndGggfSA9IGRlY2xhcmF0aW9uc1xuICBpZiAobGVuZ3RoID4gMCkge1xuICAgIGdlbmVyYXRvci5WYXJpYWJsZURlY2xhcmF0b3IoZGVjbGFyYXRpb25zWzBdLCBzdGF0ZSlcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgZ2VuZXJhdG9yLlZhcmlhYmxlRGVjbGFyYXRvcihkZWNsYXJhdGlvbnNbaV0sIHN0YXRlKVxuICAgIH1cbiAgfVxufVxuXG5sZXQgRm9ySW5TdGF0ZW1lbnQsXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gIFJlc3RFbGVtZW50LFxuICBCaW5hcnlFeHByZXNzaW9uLFxuICBBcnJheUV4cHJlc3Npb24sXG4gIEJsb2NrU3RhdGVtZW50XG5cbmV4cG9ydCBjb25zdCBHRU5FUkFUT1IgPSB7XG4gIC8qXG4gIERlZmF1bHQgZ2VuZXJhdG9yLlxuICAqL1xuICBQcm9ncmFtKG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgaW5kZW50ID0gc3RhdGUuaW5kZW50LnJlcGVhdChzdGF0ZS5pbmRlbnRMZXZlbClcbiAgICBjb25zdCB7IGxpbmVFbmQsIHdyaXRlQ29tbWVudHMgfSA9IHN0YXRlXG4gICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgbm9kZS5jb21tZW50cyAhPSBudWxsKSB7XG4gICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS5jb21tZW50cywgaW5kZW50LCBsaW5lRW5kKVxuICAgIH1cbiAgICBjb25zdCBzdGF0ZW1lbnRzID0gbm9kZS5ib2R5XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHN0YXRlbWVudHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGF0ZW1lbnQgPSBzdGF0ZW1lbnRzW2ldXG4gICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBzdGF0ZW1lbnQuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgc3RhdGVtZW50LmNvbW1lbnRzLCBpbmRlbnQsIGxpbmVFbmQpXG4gICAgICB9XG4gICAgICBzdGF0ZS53cml0ZShpbmRlbnQpXG4gICAgICB0aGlzW3N0YXRlbWVudC50eXBlXShzdGF0ZW1lbnQsIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICB9XG4gICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgbm9kZS50cmFpbGluZ0NvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLnRyYWlsaW5nQ29tbWVudHMsIGluZGVudCwgbGluZUVuZClcbiAgICB9XG4gIH0sXG4gIEJsb2NrU3RhdGVtZW50OiAoQmxvY2tTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQucmVwZWF0KHN0YXRlLmluZGVudExldmVsKyspXG4gICAgY29uc3QgeyBsaW5lRW5kLCB3cml0ZUNvbW1lbnRzIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHN0YXRlbWVudEluZGVudCA9IGluZGVudCArIHN0YXRlLmluZGVudFxuICAgIHN0YXRlLndyaXRlKCd7JylcbiAgICBjb25zdCBzdGF0ZW1lbnRzID0gbm9kZS5ib2R5XG4gICAgaWYgKHN0YXRlbWVudHMgIT0gbnVsbCAmJiBzdGF0ZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YXRlLndyaXRlKGxpbmVFbmQpXG4gICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBub2RlLmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUuY29tbWVudHMsIHN0YXRlbWVudEluZGVudCwgbGluZUVuZClcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBzdGF0ZW1lbnRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlbWVudCA9IHN0YXRlbWVudHNbaV1cbiAgICAgICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgc3RhdGVtZW50LmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgc3RhdGVtZW50LmNvbW1lbnRzLCBzdGF0ZW1lbnRJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JpdGUoc3RhdGVtZW50SW5kZW50KVxuICAgICAgICB0aGlzW3N0YXRlbWVudC50eXBlXShzdGF0ZW1lbnQsIHN0YXRlKVxuICAgICAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoaW5kZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBub2RlLmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUuY29tbWVudHMsIHN0YXRlbWVudEluZGVudCwgbGluZUVuZClcbiAgICAgICAgc3RhdGUud3JpdGUoaW5kZW50KVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAod3JpdGVDb21tZW50cyAmJiBub2RlLnRyYWlsaW5nQ29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUudHJhaWxpbmdDb21tZW50cywgc3RhdGVtZW50SW5kZW50LCBsaW5lRW5kKVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnfScpXG4gICAgc3RhdGUuaW5kZW50TGV2ZWwtLVxuICB9KSxcbiAgQ2xhc3NCb2R5OiBCbG9ja1N0YXRlbWVudCxcbiAgU3RhdGljQmxvY2sobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnc3RhdGljICcpXG4gICAgdGhpcy5CbG9ja1N0YXRlbWVudChub2RlLCBzdGF0ZSlcbiAgfSxcbiAgRW1wdHlTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIEV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW25vZGUuZXhwcmVzc2lvbi50eXBlXVxuICAgIGlmIChcbiAgICAgIHByZWNlZGVuY2UgPT09IE5FRURTX1BBUkVOVEhFU0VTIHx8XG4gICAgICAocHJlY2VkZW5jZSA9PT0gMyAmJiBub2RlLmV4cHJlc3Npb24ubGVmdC50eXBlWzBdID09PSAnTycpXG4gICAgKSB7XG4gICAgICAvLyBTaG91bGQgYWx3YXlzIGhhdmUgcGFyZW50aGVzZXMgb3IgaXMgYW4gQXNzaWdubWVudEV4cHJlc3Npb24gdG8gYW4gT2JqZWN0UGF0dGVyblxuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgICAgdGhpc1tub2RlLmV4cHJlc3Npb24udHlwZV0obm9kZS5leHByZXNzaW9uLCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLmV4cHJlc3Npb24udHlwZV0obm9kZS5leHByZXNzaW9uLCBzdGF0ZSlcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBJZlN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdpZiAoJylcbiAgICB0aGlzW25vZGUudGVzdC50eXBlXShub2RlLnRlc3QsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpICcpXG4gICAgdGhpc1tub2RlLmNvbnNlcXVlbnQudHlwZV0obm9kZS5jb25zZXF1ZW50LCBzdGF0ZSlcbiAgICBpZiAobm9kZS5hbHRlcm5hdGUgIT0gbnVsbCkge1xuICAgICAgc3RhdGUud3JpdGUoJyBlbHNlICcpXG4gICAgICB0aGlzW25vZGUuYWx0ZXJuYXRlLnR5cGVdKG5vZGUuYWx0ZXJuYXRlLCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIExhYmVsZWRTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICB0aGlzW25vZGUubGFiZWwudHlwZV0obm9kZS5sYWJlbCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJzogJylcbiAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICB9LFxuICBCcmVha1N0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdicmVhaycpXG4gICAgaWYgKG5vZGUubGFiZWwgIT0gbnVsbCkge1xuICAgICAgc3RhdGUud3JpdGUoJyAnKVxuICAgICAgdGhpc1tub2RlLmxhYmVsLnR5cGVdKG5vZGUubGFiZWwsIHN0YXRlKVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIENvbnRpbnVlU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2NvbnRpbnVlJylcbiAgICBpZiAobm9kZS5sYWJlbCAhPSBudWxsKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnICcpXG4gICAgICB0aGlzW25vZGUubGFiZWwudHlwZV0obm9kZS5sYWJlbCwgc3RhdGUpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgV2l0aFN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCd3aXRoICgnKVxuICAgIHRoaXNbbm9kZS5vYmplY3QudHlwZV0obm9kZS5vYmplY3QsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpICcpXG4gICAgdGhpc1tub2RlLmJvZHkudHlwZV0obm9kZS5ib2R5LCBzdGF0ZSlcbiAgfSxcbiAgU3dpdGNoU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgaW5kZW50ID0gc3RhdGUuaW5kZW50LnJlcGVhdChzdGF0ZS5pbmRlbnRMZXZlbCsrKVxuICAgIGNvbnN0IHsgbGluZUVuZCwgd3JpdGVDb21tZW50cyB9ID0gc3RhdGVcbiAgICBzdGF0ZS5pbmRlbnRMZXZlbCsrXG4gICAgY29uc3QgY2FzZUluZGVudCA9IGluZGVudCArIHN0YXRlLmluZGVudFxuICAgIGNvbnN0IHN0YXRlbWVudEluZGVudCA9IGNhc2VJbmRlbnQgKyBzdGF0ZS5pbmRlbnRcbiAgICBzdGF0ZS53cml0ZSgnc3dpdGNoICgnKVxuICAgIHRoaXNbbm9kZS5kaXNjcmltaW5hbnQudHlwZV0obm9kZS5kaXNjcmltaW5hbnQsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpIHsnICsgbGluZUVuZClcbiAgICBjb25zdCB7IGNhc2VzOiBvY2N1cmVuY2VzIH0gPSBub2RlXG4gICAgY29uc3QgeyBsZW5ndGg6IG9jY3VyZW5jZXNDb3VudCB9ID0gb2NjdXJlbmNlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2NjdXJlbmNlc0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IG9jY3VyZW5jZSA9IG9jY3VyZW5jZXNbaV1cbiAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG9jY3VyZW5jZS5jb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBvY2N1cmVuY2UuY29tbWVudHMsIGNhc2VJbmRlbnQsIGxpbmVFbmQpXG4gICAgICB9XG4gICAgICBpZiAob2NjdXJlbmNlLnRlc3QpIHtcbiAgICAgICAgc3RhdGUud3JpdGUoY2FzZUluZGVudCArICdjYXNlICcpXG4gICAgICAgIHRoaXNbb2NjdXJlbmNlLnRlc3QudHlwZV0ob2NjdXJlbmNlLnRlc3QsIHN0YXRlKVxuICAgICAgICBzdGF0ZS53cml0ZSgnOicgKyBsaW5lRW5kKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUud3JpdGUoY2FzZUluZGVudCArICdkZWZhdWx0OicgKyBsaW5lRW5kKVxuICAgICAgfVxuICAgICAgY29uc3QgeyBjb25zZXF1ZW50IH0gPSBvY2N1cmVuY2VcbiAgICAgIGNvbnN0IHsgbGVuZ3RoOiBjb25zZXF1ZW50Q291bnQgfSA9IGNvbnNlcXVlbnRcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uc2VxdWVudENvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhdGVtZW50ID0gY29uc2VxdWVudFtpXVxuICAgICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBzdGF0ZW1lbnQuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBzdGF0ZW1lbnQuY29tbWVudHMsIHN0YXRlbWVudEluZGVudCwgbGluZUVuZClcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS53cml0ZShzdGF0ZW1lbnRJbmRlbnQpXG4gICAgICAgIHRoaXNbc3RhdGVtZW50LnR5cGVdKHN0YXRlbWVudCwgc3RhdGUpXG4gICAgICAgIHN0YXRlLndyaXRlKGxpbmVFbmQpXG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLmluZGVudExldmVsIC09IDJcbiAgICBzdGF0ZS53cml0ZShpbmRlbnQgKyAnfScpXG4gIH0sXG4gIFJldHVyblN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdyZXR1cm4nKVxuICAgIGlmIChub2RlLmFyZ3VtZW50KSB7XG4gICAgICBzdGF0ZS53cml0ZSgnICcpXG4gICAgICB0aGlzW25vZGUuYXJndW1lbnQudHlwZV0obm9kZS5hcmd1bWVudCwgc3RhdGUpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgVGhyb3dTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgndGhyb3cgJylcbiAgICB0aGlzW25vZGUuYXJndW1lbnQudHlwZV0obm9kZS5hcmd1bWVudCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBUcnlTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgndHJ5ICcpXG4gICAgdGhpc1tub2RlLmJsb2NrLnR5cGVdKG5vZGUuYmxvY2ssIHN0YXRlKVxuICAgIGlmIChub2RlLmhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IHsgaGFuZGxlciB9ID0gbm9kZVxuICAgICAgaWYgKGhhbmRsZXIucGFyYW0gPT0gbnVsbCkge1xuICAgICAgICBzdGF0ZS53cml0ZSgnIGNhdGNoICcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS53cml0ZSgnIGNhdGNoICgnKVxuICAgICAgICB0aGlzW2hhbmRsZXIucGFyYW0udHlwZV0oaGFuZGxlci5wYXJhbSwgc3RhdGUpXG4gICAgICAgIHN0YXRlLndyaXRlKCcpICcpXG4gICAgICB9XG4gICAgICB0aGlzW2hhbmRsZXIuYm9keS50eXBlXShoYW5kbGVyLmJvZHksIHN0YXRlKVxuICAgIH1cbiAgICBpZiAobm9kZS5maW5hbGl6ZXIpIHtcbiAgICAgIHN0YXRlLndyaXRlKCcgZmluYWxseSAnKVxuICAgICAgdGhpc1tub2RlLmZpbmFsaXplci50eXBlXShub2RlLmZpbmFsaXplciwgc3RhdGUpXG4gICAgfVxuICB9LFxuICBXaGlsZVN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCd3aGlsZSAoJylcbiAgICB0aGlzW25vZGUudGVzdC50eXBlXShub2RlLnRlc3QsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpICcpXG4gICAgdGhpc1tub2RlLmJvZHkudHlwZV0obm9kZS5ib2R5LCBzdGF0ZSlcbiAgfSxcbiAgRG9XaGlsZVN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdkbyAnKVxuICAgIHRoaXNbbm9kZS5ib2R5LnR5cGVdKG5vZGUuYm9keSwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJyB3aGlsZSAoJylcbiAgICB0aGlzW25vZGUudGVzdC50eXBlXShub2RlLnRlc3QsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpOycpXG4gIH0sXG4gIEZvclN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdmb3IgKCcpXG4gICAgaWYgKG5vZGUuaW5pdCAhPSBudWxsKSB7XG4gICAgICBjb25zdCB7IGluaXQgfSA9IG5vZGVcbiAgICAgIGlmIChpbml0LnR5cGVbMF0gPT09ICdWJykge1xuICAgICAgICBmb3JtYXRWYXJpYWJsZURlY2xhcmF0aW9uKHN0YXRlLCBpbml0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1tpbml0LnR5cGVdKGluaXQsIHN0YXRlKVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnOyAnKVxuICAgIGlmIChub2RlLnRlc3QpIHtcbiAgICAgIHRoaXNbbm9kZS50ZXN0LnR5cGVdKG5vZGUudGVzdCwgc3RhdGUpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCc7ICcpXG4gICAgaWYgKG5vZGUudXBkYXRlKSB7XG4gICAgICB0aGlzW25vZGUudXBkYXRlLnR5cGVdKG5vZGUudXBkYXRlLCBzdGF0ZSlcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJykgJylcbiAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICB9LFxuICBGb3JJblN0YXRlbWVudDogKEZvckluU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoYGZvciAke25vZGUuYXdhaXQgPyAnYXdhaXQgJyA6ICcnfShgKVxuICAgIGNvbnN0IHsgbGVmdCB9ID0gbm9kZVxuICAgIGlmIChsZWZ0LnR5cGVbMF0gPT09ICdWJykge1xuICAgICAgZm9ybWF0VmFyaWFibGVEZWNsYXJhdGlvbihzdGF0ZSwgbGVmdClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tsZWZ0LnR5cGVdKGxlZnQsIHN0YXRlKVxuICAgIH1cbiAgICAvLyBJZGVudGlmeWluZyB3aGV0aGVyIG5vZGUudHlwZSBpcyBgRm9ySW5TdGF0ZW1lbnRgIG9yIGBGb3JPZlN0YXRlbWVudGBcbiAgICBzdGF0ZS53cml0ZShub2RlLnR5cGVbM10gPT09ICdJJyA/ICcgaW4gJyA6ICcgb2YgJylcbiAgICB0aGlzW25vZGUucmlnaHQudHlwZV0obm9kZS5yaWdodCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJykgJylcbiAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICB9KSxcbiAgRm9yT2ZTdGF0ZW1lbnQ6IEZvckluU3RhdGVtZW50LFxuICBEZWJ1Z2dlclN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdkZWJ1Z2dlcjsnLCBub2RlKVxuICB9LFxuICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAoRnVuY3Rpb25EZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKFxuICAgICAgKG5vZGUuYXN5bmMgPyAnYXN5bmMgJyA6ICcnKSArXG4gICAgICAgIChub2RlLmdlbmVyYXRvciA/ICdmdW5jdGlvbiogJyA6ICdmdW5jdGlvbiAnKSArXG4gICAgICAgIChub2RlLmlkID8gbm9kZS5pZC5uYW1lIDogJycpLFxuICAgICAgbm9kZSxcbiAgICApXG4gICAgZm9ybWF0U2VxdWVuY2Uoc3RhdGUsIG5vZGUucGFyYW1zKVxuICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICB9KSxcbiAgRnVuY3Rpb25FeHByZXNzaW9uOiBGdW5jdGlvbkRlY2xhcmF0aW9uLFxuICBWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgZm9ybWF0VmFyaWFibGVEZWNsYXJhdGlvbihzdGF0ZSwgbm9kZSlcbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIFZhcmlhYmxlRGVjbGFyYXRvcihub2RlLCBzdGF0ZSkge1xuICAgIHRoaXNbbm9kZS5pZC50eXBlXShub2RlLmlkLCBzdGF0ZSlcbiAgICBpZiAobm9kZS5pbml0ICE9IG51bGwpIHtcbiAgICAgIHN0YXRlLndyaXRlKCcgPSAnKVxuICAgICAgdGhpc1tub2RlLmluaXQudHlwZV0obm9kZS5pbml0LCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIENsYXNzRGVjbGFyYXRpb24obm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnY2xhc3MgJyArIChub2RlLmlkID8gYCR7bm9kZS5pZC5uYW1lfSBgIDogJycpLCBub2RlKVxuICAgIGlmIChub2RlLnN1cGVyQ2xhc3MpIHtcbiAgICAgIHN0YXRlLndyaXRlKCdleHRlbmRzICcpXG4gICAgICBjb25zdCB7IHN1cGVyQ2xhc3MgfSA9IG5vZGVcbiAgICAgIGNvbnN0IHsgdHlwZSB9ID0gc3VwZXJDbGFzc1xuICAgICAgY29uc3QgcHJlY2VkZW5jZSA9IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZVt0eXBlXVxuICAgICAgaWYgKFxuICAgICAgICAodHlwZVswXSAhPT0gJ0MnIHx8IHR5cGVbMV0gIT09ICdsJyB8fCB0eXBlWzVdICE9PSAnRScpICYmXG4gICAgICAgIChwcmVjZWRlbmNlID09PSBORUVEU19QQVJFTlRIRVNFUyB8fFxuICAgICAgICAgIHByZWNlZGVuY2UgPCBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2UuQ2xhc3NFeHByZXNzaW9uKVxuICAgICAgKSB7XG4gICAgICAgIC8vIE5vdCBhIENsYXNzRXhwcmVzc2lvbiB0aGF0IG5lZWRzIHBhcmVudGhlc2VzXG4gICAgICAgIHN0YXRlLndyaXRlKCcoJylcbiAgICAgICAgdGhpc1tub2RlLnN1cGVyQ2xhc3MudHlwZV0oc3VwZXJDbGFzcywgc3RhdGUpXG4gICAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbc3VwZXJDbGFzcy50eXBlXShzdXBlckNsYXNzLCBzdGF0ZSlcbiAgICAgIH1cbiAgICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICB9XG4gICAgdGhpcy5DbGFzc0JvZHkobm9kZS5ib2R5LCBzdGF0ZSlcbiAgfSxcbiAgSW1wb3J0RGVjbGFyYXRpb24obm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnaW1wb3J0ICcpXG4gICAgY29uc3QgeyBzcGVjaWZpZXJzLCBhdHRyaWJ1dGVzIH0gPSBub2RlXG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHNwZWNpZmllcnNcbiAgICAvLyBUT0RPOiBPbmNlIGJhYmlsaSBpcyBmaXhlZCwgcHV0IHRoaXMgYWZ0ZXIgY29uZGl0aW9uXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmlsaS9pc3N1ZXMvNDMwXG4gICAgbGV0IGkgPSAwXG4gICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyApIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgc3RhdGUud3JpdGUoJywgJylcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGVjaWZpZXIgPSBzcGVjaWZpZXJzW2ldXG4gICAgICAgIGNvbnN0IHR5cGUgPSBzcGVjaWZpZXIudHlwZVs2XVxuICAgICAgICBpZiAodHlwZSA9PT0gJ0QnKSB7XG4gICAgICAgICAgLy8gSW1wb3J0RGVmYXVsdFNwZWNpZmllclxuICAgICAgICAgIHN0YXRlLndyaXRlKHNwZWNpZmllci5sb2NhbC5uYW1lLCBzcGVjaWZpZXIpXG4gICAgICAgICAgaSsrXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ04nKSB7XG4gICAgICAgICAgLy8gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXG4gICAgICAgICAgc3RhdGUud3JpdGUoJyogYXMgJyArIHNwZWNpZmllci5sb2NhbC5uYW1lLCBzcGVjaWZpZXIpXG4gICAgICAgICAgaSsrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW1wb3J0U3BlY2lmaWVyXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJ3snKVxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgY29uc3Qgc3BlY2lmaWVyID0gc3BlY2lmaWVyc1tpXVxuICAgICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gc3BlY2lmaWVyLmltcG9ydGVkXG4gICAgICAgICAgc3RhdGUud3JpdGUobmFtZSwgc3BlY2lmaWVyKVxuICAgICAgICAgIGlmIChuYW1lICE9PSBzcGVjaWZpZXIubG9jYWwubmFtZSkge1xuICAgICAgICAgICAgc3RhdGUud3JpdGUoJyBhcyAnICsgc3BlY2lmaWVyLmxvY2FsLm5hbWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLndyaXRlKCd9JylcbiAgICAgIH1cbiAgICAgIHN0YXRlLndyaXRlKCcgZnJvbSAnKVxuICAgIH1cbiAgICB0aGlzLkxpdGVyYWwobm9kZS5zb3VyY2UsIHN0YXRlKVxuXG4gICAgaWYgKGF0dHJpYnV0ZXMgJiYgYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnIHdpdGggeyAnKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuSW1wb3J0QXR0cmlidXRlKGF0dHJpYnV0ZXNbaV0sIHN0YXRlKVxuICAgICAgICBpZiAoaSA8IGF0dHJpYnV0ZXMubGVuZ3RoIC0gMSkgc3RhdGUud3JpdGUoJywgJylcbiAgICAgIH1cblxuICAgICAgc3RhdGUud3JpdGUoJyB9JylcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBJbXBvcnRBdHRyaWJ1dGUobm9kZSwgc3RhdGUpIHtcbiAgICB0aGlzLklkZW50aWZpZXIobm9kZS5rZXksIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCc6ICcpXG4gICAgdGhpcy5MaXRlcmFsKG5vZGUudmFsdWUsIHN0YXRlKVxuICB9LFxuICBJbXBvcnRFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2ltcG9ydCgnKVxuICAgIHRoaXNbbm9kZS5zb3VyY2UudHlwZV0obm9kZS5zb3VyY2UsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpJylcbiAgfSxcbiAgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2V4cG9ydCBkZWZhdWx0ICcpXG4gICAgdGhpc1tub2RlLmRlY2xhcmF0aW9uLnR5cGVdKG5vZGUuZGVjbGFyYXRpb24sIHN0YXRlKVxuICAgIGlmIChcbiAgICAgIHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZVtub2RlLmRlY2xhcmF0aW9uLnR5cGVdICE9IG51bGwgJiZcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24udHlwZVswXSAhPT0gJ0YnXG4gICAgKSB7XG4gICAgICAvLyBBbGwgZXhwcmVzc2lvbiBub2RlcyBleGNlcHQgYEZ1bmN0aW9uRXhwcmVzc2lvbmBcbiAgICAgIHN0YXRlLndyaXRlKCc7JylcbiAgICB9XG4gIH0sXG4gIEV4cG9ydE5hbWVkRGVjbGFyYXRpb24obm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnZXhwb3J0ICcpXG4gICAgaWYgKG5vZGUuZGVjbGFyYXRpb24pIHtcbiAgICAgIHRoaXNbbm9kZS5kZWNsYXJhdGlvbi50eXBlXShub2RlLmRlY2xhcmF0aW9uLCBzdGF0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUud3JpdGUoJ3snKVxuICAgICAgY29uc3QgeyBzcGVjaWZpZXJzIH0gPSBub2RlLFxuICAgICAgICB7IGxlbmd0aCB9ID0gc3BlY2lmaWVyc1xuICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IDsgKSB7XG4gICAgICAgICAgY29uc3Qgc3BlY2lmaWVyID0gc3BlY2lmaWVyc1tpXVxuICAgICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gc3BlY2lmaWVyLmxvY2FsXG4gICAgICAgICAgc3RhdGUud3JpdGUobmFtZSwgc3BlY2lmaWVyKVxuICAgICAgICAgIGlmIChuYW1lICE9PSBzcGVjaWZpZXIuZXhwb3J0ZWQubmFtZSkge1xuICAgICAgICAgICAgc3RhdGUud3JpdGUoJyBhcyAnICsgc3BlY2lmaWVyLmV4cG9ydGVkLm5hbWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZS53cml0ZSgnfScpXG4gICAgICBpZiAobm9kZS5zb3VyY2UpIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJyBmcm9tICcpXG4gICAgICAgIHRoaXMuTGl0ZXJhbChub2RlLnNvdXJjZSwgc3RhdGUpXG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmF0dHJpYnV0ZXMgJiYgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJyB3aXRoIHsgJylcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLkltcG9ydEF0dHJpYnV0ZShub2RlLmF0dHJpYnV0ZXNbaV0sIHN0YXRlKVxuICAgICAgICAgIGlmIChpIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCAtIDEpIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS53cml0ZSgnIH0nKVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS53cml0ZSgnOycpXG4gICAgfVxuICB9LFxuICBFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIGlmIChub2RlLmV4cG9ydGVkICE9IG51bGwpIHtcbiAgICAgIHN0YXRlLndyaXRlKCdleHBvcnQgKiBhcyAnICsgbm9kZS5leHBvcnRlZC5uYW1lICsgJyBmcm9tICcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLndyaXRlKCdleHBvcnQgKiBmcm9tICcpXG4gICAgfVxuICAgIHRoaXMuTGl0ZXJhbChub2RlLnNvdXJjZSwgc3RhdGUpXG5cbiAgICBpZiAobm9kZS5hdHRyaWJ1dGVzICYmIG5vZGUuYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnIHdpdGggeyAnKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5JbXBvcnRBdHRyaWJ1dGUobm9kZS5hdHRyaWJ1dGVzW2ldLCBzdGF0ZSlcbiAgICAgICAgaWYgKGkgPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoIC0gMSkgc3RhdGUud3JpdGUoJywgJylcbiAgICAgIH1cblxuICAgICAgc3RhdGUud3JpdGUoJyB9JylcbiAgICB9XG5cbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIE1ldGhvZERlZmluaXRpb24obm9kZSwgc3RhdGUpIHtcbiAgICBpZiAobm9kZS5zdGF0aWMpIHtcbiAgICAgIHN0YXRlLndyaXRlKCdzdGF0aWMgJylcbiAgICB9XG4gICAgY29uc3Qga2luZCA9IG5vZGUua2luZFswXVxuICAgIGlmIChraW5kID09PSAnZycgfHwga2luZCA9PT0gJ3MnKSB7XG4gICAgICAvLyBHZXR0ZXIgb3Igc2V0dGVyXG4gICAgICBzdGF0ZS53cml0ZShub2RlLmtpbmQgKyAnICcpXG4gICAgfVxuICAgIGlmIChub2RlLnZhbHVlLmFzeW5jKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnYXN5bmMgJylcbiAgICB9XG4gICAgaWYgKG5vZGUudmFsdWUuZ2VuZXJhdG9yKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnKicpXG4gICAgfVxuICAgIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnWycpXG4gICAgICB0aGlzW25vZGUua2V5LnR5cGVdKG5vZGUua2V5LCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCddJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLmtleS50eXBlXShub2RlLmtleSwgc3RhdGUpXG4gICAgfVxuICAgIGZvcm1hdFNlcXVlbmNlKHN0YXRlLCBub2RlLnZhbHVlLnBhcmFtcylcbiAgICBzdGF0ZS53cml0ZSgnICcpXG4gICAgdGhpc1tub2RlLnZhbHVlLmJvZHkudHlwZV0obm9kZS52YWx1ZS5ib2R5LCBzdGF0ZSlcbiAgfSxcbiAgQ2xhc3NFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgdGhpcy5DbGFzc0RlY2xhcmF0aW9uKG5vZGUsIHN0YXRlKVxuICB9LFxuICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKG5vZGUuYXN5bmMgPyAnYXN5bmMgJyA6ICcnLCBub2RlKVxuICAgIGNvbnN0IHsgcGFyYW1zIH0gPSBub2RlXG4gICAgaWYgKHBhcmFtcyAhPSBudWxsKSB7XG4gICAgICAvLyBPbWl0IHBhcmVudGhlc2lzIGlmIG9ubHkgb25lIG5hbWVkIHBhcmFtZXRlclxuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEgJiYgcGFyYW1zWzBdLnR5cGVbMF0gPT09ICdJJykge1xuICAgICAgICAvLyBJZiBwYXJhbXNbMF0udHlwZVswXSBzdGFydHMgd2l0aCAnSScsIGl0IGNhbid0IGJlIGBJbXBvcnREZWNsYXJhdGlvbmAgbm9yIGBJZlN0YXRlbWVudGAgYW5kIHRodXMgaXMgYElkZW50aWZpZXJgXG4gICAgICAgIHN0YXRlLndyaXRlKHBhcmFtc1swXS5uYW1lLCBwYXJhbXNbMF0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtYXRTZXF1ZW5jZShzdGF0ZSwgbm9kZS5wYXJhbXMpXG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCcgPT4gJylcbiAgICBpZiAobm9kZS5ib2R5LnR5cGVbMF0gPT09ICdPJykge1xuICAgICAgLy8gQm9keSBpcyBhbiBvYmplY3QgZXhwcmVzc2lvblxuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgICAgdGhpcy5PYmplY3RFeHByZXNzaW9uKG5vZGUuYm9keSwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbm9kZS5ib2R5LnR5cGVdKG5vZGUuYm9keSwgc3RhdGUpXG4gICAgfVxuICB9LFxuICBUaGlzRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCd0aGlzJywgbm9kZSlcbiAgfSxcbiAgU3VwZXIobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnc3VwZXInLCBub2RlKVxuICB9LFxuICBSZXN0RWxlbWVudDogKFJlc3RFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJy4uLicpXG4gICAgdGhpc1tub2RlLmFyZ3VtZW50LnR5cGVdKG5vZGUuYXJndW1lbnQsIHN0YXRlKVxuICB9KSxcbiAgU3ByZWFkRWxlbWVudDogUmVzdEVsZW1lbnQsXG4gIFlpZWxkRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKG5vZGUuZGVsZWdhdGUgPyAneWllbGQqJyA6ICd5aWVsZCcpXG4gICAgaWYgKG5vZGUuYXJndW1lbnQpIHtcbiAgICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICAgIHRoaXNbbm9kZS5hcmd1bWVudC50eXBlXShub2RlLmFyZ3VtZW50LCBzdGF0ZSlcbiAgICB9XG4gIH0sXG4gIEF3YWl0RXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdhd2FpdCAnLCBub2RlKVxuICAgIGZvcm1hdEV4cHJlc3Npb24oc3RhdGUsIG5vZGUuYXJndW1lbnQsIG5vZGUpXG4gIH0sXG4gIFRlbXBsYXRlTGl0ZXJhbChub2RlLCBzdGF0ZSkge1xuICAgIGNvbnN0IHsgcXVhc2lzLCBleHByZXNzaW9ucyB9ID0gbm9kZVxuICAgIHN0YXRlLndyaXRlKCdgJylcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gZXhwcmVzc2lvbnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBleHByZXNzaW9uID0gZXhwcmVzc2lvbnNbaV1cbiAgICAgIGNvbnN0IHF1YXNpID0gcXVhc2lzW2ldXG4gICAgICBzdGF0ZS53cml0ZShxdWFzaS52YWx1ZS5yYXcsIHF1YXNpKVxuICAgICAgc3RhdGUud3JpdGUoJyR7JylcbiAgICAgIHRoaXNbZXhwcmVzc2lvbi50eXBlXShleHByZXNzaW9uLCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCd9JylcbiAgICB9XG4gICAgY29uc3QgcXVhc2kgPSBxdWFzaXNbcXVhc2lzLmxlbmd0aCAtIDFdXG4gICAgc3RhdGUud3JpdGUocXVhc2kudmFsdWUucmF3LCBxdWFzaSlcbiAgICBzdGF0ZS53cml0ZSgnYCcpXG4gIH0sXG4gIFRlbXBsYXRlRWxlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKG5vZGUudmFsdWUucmF3LCBub2RlKVxuICB9LFxuICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBmb3JtYXRFeHByZXNzaW9uKHN0YXRlLCBub2RlLnRhZywgbm9kZSlcbiAgICB0aGlzW25vZGUucXVhc2kudHlwZV0obm9kZS5xdWFzaSwgc3RhdGUpXG4gIH0sXG4gIEFycmF5RXhwcmVzc2lvbjogKEFycmF5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdbJylcbiAgICBpZiAobm9kZS5lbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB7IGVsZW1lbnRzIH0gPSBub2RlLFxuICAgICAgICB7IGxlbmd0aCB9ID0gZWxlbWVudHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyA7ICkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV1cbiAgICAgICAgaWYgKGVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXNbZWxlbWVudC50eXBlXShlbGVtZW50LCBzdGF0ZSlcbiAgICAgICAgfVxuICAgICAgICBpZiAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgc3RhdGUud3JpdGUoJywgJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCddJylcbiAgfSksXG4gIEFycmF5UGF0dGVybjogQXJyYXlFeHByZXNzaW9uLFxuICBPYmplY3RFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgaW5kZW50ID0gc3RhdGUuaW5kZW50LnJlcGVhdChzdGF0ZS5pbmRlbnRMZXZlbCsrKVxuICAgIGNvbnN0IHsgbGluZUVuZCwgd3JpdGVDb21tZW50cyB9ID0gc3RhdGVcbiAgICBjb25zdCBwcm9wZXJ0eUluZGVudCA9IGluZGVudCArIHN0YXRlLmluZGVudFxuICAgIHN0YXRlLndyaXRlKCd7JylcbiAgICBpZiAobm9kZS5wcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YXRlLndyaXRlKGxpbmVFbmQpXG4gICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBub2RlLmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUuY29tbWVudHMsIHByb3BlcnR5SW5kZW50LCBsaW5lRW5kKVxuICAgICAgfVxuICAgICAgY29uc3QgY29tbWEgPSAnLCcgKyBsaW5lRW5kXG4gICAgICBjb25zdCB7IHByb3BlcnRpZXMgfSA9IG5vZGUsXG4gICAgICAgIHsgbGVuZ3RoIH0gPSBwcm9wZXJ0aWVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgOyApIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldXG4gICAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIHByb3BlcnR5LmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgcHJvcGVydHkuY29tbWVudHMsIHByb3BlcnR5SW5kZW50LCBsaW5lRW5kKVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLndyaXRlKHByb3BlcnR5SW5kZW50KVxuICAgICAgICB0aGlzW3Byb3BlcnR5LnR5cGVdKHByb3BlcnR5LCBzdGF0ZSlcbiAgICAgICAgaWYgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgIHN0YXRlLndyaXRlKGNvbW1hKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLndyaXRlKGxpbmVFbmQpXG4gICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBub2RlLnRyYWlsaW5nQ29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS50cmFpbGluZ0NvbW1lbnRzLCBwcm9wZXJ0eUluZGVudCwgbGluZUVuZClcbiAgICAgIH1cbiAgICAgIHN0YXRlLndyaXRlKGluZGVudCArICd9JylcbiAgICB9IGVsc2UgaWYgKHdyaXRlQ29tbWVudHMpIHtcbiAgICAgIGlmIChub2RlLmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUuY29tbWVudHMsIHByb3BlcnR5SW5kZW50LCBsaW5lRW5kKVxuICAgICAgICBpZiAobm9kZS50cmFpbGluZ0NvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS50cmFpbGluZ0NvbW1lbnRzLCBwcm9wZXJ0eUluZGVudCwgbGluZUVuZClcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS53cml0ZShpbmRlbnQgKyAnfScpXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudHJhaWxpbmdDb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKGxpbmVFbmQpXG4gICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLnRyYWlsaW5nQ29tbWVudHMsIHByb3BlcnR5SW5kZW50LCBsaW5lRW5kKVxuICAgICAgICBzdGF0ZS53cml0ZShpbmRlbnQgKyAnfScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS53cml0ZSgnfScpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLndyaXRlKCd9JylcbiAgICB9XG4gICAgc3RhdGUuaW5kZW50TGV2ZWwtLVxuICB9LFxuICBQcm9wZXJ0eShub2RlLCBzdGF0ZSkge1xuICAgIGlmIChub2RlLm1ldGhvZCB8fCBub2RlLmtpbmRbMF0gIT09ICdpJykge1xuICAgICAgLy8gRWl0aGVyIGEgbWV0aG9kIG9yIG9mIGtpbmQgYHNldGAgb3IgYGdldGAgKG5vdCBgaW5pdGApXG4gICAgICB0aGlzLk1ldGhvZERlZmluaXRpb24obm9kZSwgc3RhdGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghbm9kZS5zaG9ydGhhbmQpIHtcbiAgICAgICAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICAgICAgICBzdGF0ZS53cml0ZSgnWycpXG4gICAgICAgICAgdGhpc1tub2RlLmtleS50eXBlXShub2RlLmtleSwgc3RhdGUpXG4gICAgICAgICAgc3RhdGUud3JpdGUoJ10nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNbbm9kZS5rZXkudHlwZV0obm9kZS5rZXksIHN0YXRlKVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLndyaXRlKCc6ICcpXG4gICAgICB9XG4gICAgICB0aGlzW25vZGUudmFsdWUudHlwZV0obm9kZS52YWx1ZSwgc3RhdGUpXG4gICAgfVxuICB9LFxuICBQcm9wZXJ0eURlZmluaXRpb24obm9kZSwgc3RhdGUpIHtcbiAgICBpZiAobm9kZS5zdGF0aWMpIHtcbiAgICAgIHN0YXRlLndyaXRlKCdzdGF0aWMgJylcbiAgICB9XG4gICAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICAgIHN0YXRlLndyaXRlKCdbJylcbiAgICB9XG4gICAgdGhpc1tub2RlLmtleS50eXBlXShub2RlLmtleSwgc3RhdGUpXG4gICAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICAgIHN0YXRlLndyaXRlKCddJylcbiAgICB9XG4gICAgaWYgKG5vZGUudmFsdWUgPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUua2V5LnR5cGVbMF0gIT09ICdGJykge1xuICAgICAgICBzdGF0ZS53cml0ZSgnOycpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJyA9ICcpXG4gICAgdGhpc1tub2RlLnZhbHVlLnR5cGVdKG5vZGUudmFsdWUsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgT2JqZWN0UGF0dGVybihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCd7JylcbiAgICBpZiAobm9kZS5wcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gbm9kZSxcbiAgICAgICAgeyBsZW5ndGggfSA9IHByb3BlcnRpZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyA7ICkge1xuICAgICAgICB0aGlzW3Byb3BlcnRpZXNbaV0udHlwZV0ocHJvcGVydGllc1tpXSwgc3RhdGUpXG4gICAgICAgIGlmICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJ30nKVxuICB9LFxuICBTZXF1ZW5jZUV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBmb3JtYXRTZXF1ZW5jZShzdGF0ZSwgbm9kZS5leHByZXNzaW9ucylcbiAgfSxcbiAgVW5hcnlFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUucHJlZml4KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9wZXJhdG9yLFxuICAgICAgICBhcmd1bWVudCxcbiAgICAgICAgYXJndW1lbnQ6IHsgdHlwZSB9LFxuICAgICAgfSA9IG5vZGVcbiAgICAgIHN0YXRlLndyaXRlKG9wZXJhdG9yKVxuICAgICAgY29uc3QgbmVlZHNQYXJlbnRoZXNlcyA9IGV4cHJlc3Npb25OZWVkc1BhcmVudGhlc2lzKHN0YXRlLCBhcmd1bWVudCwgbm9kZSlcbiAgICAgIGlmIChcbiAgICAgICAgIW5lZWRzUGFyZW50aGVzZXMgJiZcbiAgICAgICAgKG9wZXJhdG9yLmxlbmd0aCA+IDEgfHxcbiAgICAgICAgICAodHlwZVswXSA9PT0gJ1UnICYmXG4gICAgICAgICAgICAodHlwZVsxXSA9PT0gJ24nIHx8IHR5cGVbMV0gPT09ICdwJykgJiZcbiAgICAgICAgICAgIGFyZ3VtZW50LnByZWZpeCAmJlxuICAgICAgICAgICAgYXJndW1lbnQub3BlcmF0b3JbMF0gPT09IG9wZXJhdG9yICYmXG4gICAgICAgICAgICAob3BlcmF0b3IgPT09ICcrJyB8fCBvcGVyYXRvciA9PT0gJy0nKSkpXG4gICAgICApIHtcbiAgICAgICAgLy8gTGFyZ2Ugb3BlcmF0b3Igb3IgYXJndW1lbnQgaXMgVW5hcnlFeHByZXNzaW9uIG9yIFVwZGF0ZUV4cHJlc3Npb24gbm9kZVxuICAgICAgICBzdGF0ZS53cml0ZSgnICcpXG4gICAgICB9XG4gICAgICBpZiAobmVlZHNQYXJlbnRoZXNlcykge1xuICAgICAgICBzdGF0ZS53cml0ZShvcGVyYXRvci5sZW5ndGggPiAxID8gJyAoJyA6ICcoJylcbiAgICAgICAgdGhpc1t0eXBlXShhcmd1bWVudCwgc3RhdGUpXG4gICAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbdHlwZV0oYXJndW1lbnQsIHN0YXRlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGSVhNRTogVGhpcyBjYXNlIG5ldmVyIG9jY3Vyc1xuICAgICAgdGhpc1tub2RlLmFyZ3VtZW50LnR5cGVdKG5vZGUuYXJndW1lbnQsIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUobm9kZS5vcGVyYXRvcilcbiAgICB9XG4gIH0sXG4gIFVwZGF0ZUV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICAvLyBBbHdheXMgYXBwbGllZCB0byBpZGVudGlmaWVycyBvciBtZW1iZXJzLCBubyBwYXJlbnRoZXNpcyBjaGVjayBuZWVkZWRcbiAgICBpZiAobm9kZS5wcmVmaXgpIHtcbiAgICAgIHN0YXRlLndyaXRlKG5vZGUub3BlcmF0b3IpXG4gICAgICB0aGlzW25vZGUuYXJndW1lbnQudHlwZV0obm9kZS5hcmd1bWVudCwgc3RhdGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbm9kZS5hcmd1bWVudC50eXBlXShub2RlLmFyZ3VtZW50LCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKG5vZGUub3BlcmF0b3IpXG4gICAgfVxuICB9LFxuICBBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIHRoaXNbbm9kZS5sZWZ0LnR5cGVdKG5vZGUubGVmdCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJyAnICsgbm9kZS5vcGVyYXRvciArICcgJylcbiAgICB0aGlzW25vZGUucmlnaHQudHlwZV0obm9kZS5yaWdodCwgc3RhdGUpXG4gIH0sXG4gIEFzc2lnbm1lbnRQYXR0ZXJuKG5vZGUsIHN0YXRlKSB7XG4gICAgdGhpc1tub2RlLmxlZnQudHlwZV0obm9kZS5sZWZ0LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnID0gJylcbiAgICB0aGlzW25vZGUucmlnaHQudHlwZV0obm9kZS5yaWdodCwgc3RhdGUpXG4gIH0sXG4gIEJpbmFyeUV4cHJlc3Npb246IChCaW5hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgaXNJbiA9IG5vZGUub3BlcmF0b3IgPT09ICdpbidcbiAgICBpZiAoaXNJbikge1xuICAgICAgLy8gQXZvaWRzIGNvbmZ1c2lvbiBpbiBgZm9yYCBsb29wcyBpbml0aWFsaXplcnNcbiAgICAgIHN0YXRlLndyaXRlKCcoJylcbiAgICB9XG4gICAgZm9ybWF0RXhwcmVzc2lvbihzdGF0ZSwgbm9kZS5sZWZ0LCBub2RlLCBmYWxzZSlcbiAgICBzdGF0ZS53cml0ZSgnICcgKyBub2RlLm9wZXJhdG9yICsgJyAnKVxuICAgIGZvcm1hdEV4cHJlc3Npb24oc3RhdGUsIG5vZGUucmlnaHQsIG5vZGUsIHRydWUpXG4gICAgaWYgKGlzSW4pIHtcbiAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICB9XG4gIH0pLFxuICBMb2dpY2FsRXhwcmVzc2lvbjogQmluYXJ5RXhwcmVzc2lvbixcbiAgQ29uZGl0aW9uYWxFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgeyB0ZXN0IH0gPSBub2RlXG4gICAgY29uc3QgcHJlY2VkZW5jZSA9IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZVt0ZXN0LnR5cGVdXG4gICAgaWYgKFxuICAgICAgcHJlY2VkZW5jZSA9PT0gTkVFRFNfUEFSRU5USEVTRVMgfHxcbiAgICAgIHByZWNlZGVuY2UgPD0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlLkNvbmRpdGlvbmFsRXhwcmVzc2lvblxuICAgICkge1xuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgICAgdGhpc1t0ZXN0LnR5cGVdKHRlc3QsIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUoJyknKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW3Rlc3QudHlwZV0odGVzdCwgc3RhdGUpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCcgPyAnKVxuICAgIHRoaXNbbm9kZS5jb25zZXF1ZW50LnR5cGVdKG5vZGUuY29uc2VxdWVudCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJyA6ICcpXG4gICAgdGhpc1tub2RlLmFsdGVybmF0ZS50eXBlXShub2RlLmFsdGVybmF0ZSwgc3RhdGUpXG4gIH0sXG4gIE5ld0V4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnbmV3ICcpXG4gICAgY29uc3QgcHJlY2VkZW5jZSA9IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZVtub2RlLmNhbGxlZS50eXBlXVxuICAgIGlmIChcbiAgICAgIHByZWNlZGVuY2UgPT09IE5FRURTX1BBUkVOVEhFU0VTIHx8XG4gICAgICBwcmVjZWRlbmNlIDwgc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlLkNhbGxFeHByZXNzaW9uIHx8XG4gICAgICBoYXNDYWxsRXhwcmVzc2lvbihub2RlLmNhbGxlZSlcbiAgICApIHtcbiAgICAgIHN0YXRlLndyaXRlKCcoJylcbiAgICAgIHRoaXNbbm9kZS5jYWxsZWUudHlwZV0obm9kZS5jYWxsZWUsIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUoJyknKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW25vZGUuY2FsbGVlLnR5cGVdKG5vZGUuY2FsbGVlLCBzdGF0ZSlcbiAgICB9XG4gICAgZm9ybWF0U2VxdWVuY2Uoc3RhdGUsIG5vZGVbJ2FyZ3VtZW50cyddKVxuICB9LFxuICBDYWxsRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIGNvbnN0IHByZWNlZGVuY2UgPSBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2Vbbm9kZS5jYWxsZWUudHlwZV1cbiAgICBpZiAoXG4gICAgICBwcmVjZWRlbmNlID09PSBORUVEU19QQVJFTlRIRVNFUyB8fFxuICAgICAgcHJlY2VkZW5jZSA8IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZS5DYWxsRXhwcmVzc2lvblxuICAgICkge1xuICAgICAgc3RhdGUud3JpdGUoJygnKVxuICAgICAgdGhpc1tub2RlLmNhbGxlZS50eXBlXShub2RlLmNhbGxlZSwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbm9kZS5jYWxsZWUudHlwZV0obm9kZS5jYWxsZWUsIHN0YXRlKVxuICAgIH1cbiAgICBpZiAobm9kZS5vcHRpb25hbCkge1xuICAgICAgc3RhdGUud3JpdGUoJz8uJylcbiAgICB9XG4gICAgZm9ybWF0U2VxdWVuY2Uoc3RhdGUsIG5vZGVbJ2FyZ3VtZW50cyddKVxuICB9LFxuICBDaGFpbkV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICB0aGlzW25vZGUuZXhwcmVzc2lvbi50eXBlXShub2RlLmV4cHJlc3Npb24sIHN0YXRlKVxuICB9LFxuICBNZW1iZXJFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgcHJlY2VkZW5jZSA9IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZVtub2RlLm9iamVjdC50eXBlXVxuICAgIGlmIChcbiAgICAgIHByZWNlZGVuY2UgPT09IE5FRURTX1BBUkVOVEhFU0VTIHx8XG4gICAgICBwcmVjZWRlbmNlIDwgc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlLk1lbWJlckV4cHJlc3Npb25cbiAgICApIHtcbiAgICAgIHN0YXRlLndyaXRlKCcoJylcbiAgICAgIHRoaXNbbm9kZS5vYmplY3QudHlwZV0obm9kZS5vYmplY3QsIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUoJyknKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW25vZGUub2JqZWN0LnR5cGVdKG5vZGUub2JqZWN0LCBzdGF0ZSlcbiAgICB9XG4gICAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICAgIGlmIChub2RlLm9wdGlvbmFsKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCc/LicpXG4gICAgICB9XG4gICAgICBzdGF0ZS53cml0ZSgnWycpXG4gICAgICB0aGlzW25vZGUucHJvcGVydHkudHlwZV0obm9kZS5wcm9wZXJ0eSwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnXScpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChub2RlLm9wdGlvbmFsKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCc/LicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS53cml0ZSgnLicpXG4gICAgICB9XG4gICAgICB0aGlzW25vZGUucHJvcGVydHkudHlwZV0obm9kZS5wcm9wZXJ0eSwgc3RhdGUpXG4gICAgfVxuICB9LFxuICBNZXRhUHJvcGVydHkobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZShub2RlLm1ldGEubmFtZSArICcuJyArIG5vZGUucHJvcGVydHkubmFtZSwgbm9kZSlcbiAgfSxcbiAgSWRlbnRpZmllcihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKG5vZGUubmFtZSwgbm9kZSlcbiAgfSxcbiAgUHJpdmF0ZUlkZW50aWZpZXIobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZShgIyR7bm9kZS5uYW1lfWAsIG5vZGUpXG4gIH0sXG4gIExpdGVyYWwobm9kZSwgc3RhdGUpIHtcbiAgICBpZiAobm9kZS5yYXcgIT0gbnVsbCkge1xuICAgICAgLy8gTm9uLXN0YW5kYXJkIHByb3BlcnR5XG4gICAgICBzdGF0ZS53cml0ZShub2RlLnJhdywgbm9kZSlcbiAgICB9IGVsc2UgaWYgKG5vZGUucmVnZXggIT0gbnVsbCkge1xuICAgICAgdGhpcy5SZWdFeHBMaXRlcmFsKG5vZGUsIHN0YXRlKVxuICAgIH0gZWxzZSBpZiAobm9kZS5iaWdpbnQgIT0gbnVsbCkge1xuICAgICAgc3RhdGUud3JpdGUobm9kZS5iaWdpbnQgKyAnbicsIG5vZGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLndyaXRlKHN0cmluZ2lmeShub2RlLnZhbHVlKSwgbm9kZSlcbiAgICB9XG4gIH0sXG4gIFJlZ0V4cExpdGVyYWwobm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCB7IHJlZ2V4IH0gPSBub2RlXG4gICAgc3RhdGUud3JpdGUoYC8ke3JlZ2V4LnBhdHRlcm59LyR7cmVnZXguZmxhZ3N9YCwgbm9kZSlcbiAgfSxcbn1cblxuY29uc3QgRU1QVFlfT0JKRUNUID0ge31cblxuLypcbkRFUFJFQ0FURUQ6IEFsdGVybmF0ZSBleHBvcnQgb2YgYEdFTkVSQVRPUmAuXG4qL1xuZXhwb3J0IGNvbnN0IGJhc2VHZW5lcmF0b3IgPSBHRU5FUkFUT1JcblxuY2xhc3MgU3RhdGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgY29uc3Qgc2V0dXAgPSBvcHRpb25zID09IG51bGwgPyBFTVBUWV9PQkpFQ1QgOiBvcHRpb25zXG4gICAgdGhpcy5vdXRwdXQgPSAnJ1xuICAgIC8vIEZ1bmN0aW9uYWwgb3B0aW9uc1xuICAgIGlmIChzZXR1cC5vdXRwdXQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5vdXRwdXQgPSBzZXR1cC5vdXRwdXRcbiAgICAgIHRoaXMud3JpdGUgPSB0aGlzLndyaXRlVG9TdHJlYW1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vdXRwdXQgPSAnJ1xuICAgIH1cbiAgICB0aGlzLmdlbmVyYXRvciA9IHNldHVwLmdlbmVyYXRvciAhPSBudWxsID8gc2V0dXAuZ2VuZXJhdG9yIDogR0VORVJBVE9SXG4gICAgdGhpcy5leHByZXNzaW9uc1ByZWNlZGVuY2UgPVxuICAgICAgc2V0dXAuZXhwcmVzc2lvbnNQcmVjZWRlbmNlICE9IG51bGxcbiAgICAgICAgPyBzZXR1cC5leHByZXNzaW9uc1ByZWNlZGVuY2VcbiAgICAgICAgOiBFWFBSRVNTSU9OU19QUkVDRURFTkNFXG4gICAgLy8gRm9ybWF0aW5nIHNldHVwXG4gICAgdGhpcy5pbmRlbnQgPSBzZXR1cC5pbmRlbnQgIT0gbnVsbCA/IHNldHVwLmluZGVudCA6ICcgICdcbiAgICB0aGlzLmxpbmVFbmQgPSBzZXR1cC5saW5lRW5kICE9IG51bGwgPyBzZXR1cC5saW5lRW5kIDogJ1xcbidcbiAgICB0aGlzLmluZGVudExldmVsID1cbiAgICAgIHNldHVwLnN0YXJ0aW5nSW5kZW50TGV2ZWwgIT0gbnVsbCA/IHNldHVwLnN0YXJ0aW5nSW5kZW50TGV2ZWwgOiAwXG4gICAgdGhpcy53cml0ZUNvbW1lbnRzID0gc2V0dXAuY29tbWVudHMgPyBzZXR1cC5jb21tZW50cyA6IGZhbHNlXG4gICAgLy8gU291cmNlIG1hcFxuICAgIGlmIChzZXR1cC5zb3VyY2VNYXAgIT0gbnVsbCkge1xuICAgICAgdGhpcy53cml0ZSA9XG4gICAgICAgIHNldHVwLm91dHB1dCA9PSBudWxsID8gdGhpcy53cml0ZUFuZE1hcCA6IHRoaXMud3JpdGVUb1N0cmVhbUFuZE1hcFxuICAgICAgdGhpcy5zb3VyY2VNYXAgPSBzZXR1cC5zb3VyY2VNYXBcbiAgICAgIHRoaXMubGluZSA9IDFcbiAgICAgIHRoaXMuY29sdW1uID0gMFxuICAgICAgdGhpcy5saW5lRW5kU2l6ZSA9IHRoaXMubGluZUVuZC5zcGxpdCgnXFxuJykubGVuZ3RoIC0gMVxuICAgICAgdGhpcy5tYXBwaW5nID0ge1xuICAgICAgICBvcmlnaW5hbDogbnVsbCxcbiAgICAgICAgLy8gVXNlcyB0aGUgZW50aXJlIHN0YXRlIHRvIGF2b2lkIGdlbmVyYXRpbmcgZXBoZW1lcmFsIG9iamVjdHNcbiAgICAgICAgZ2VuZXJhdGVkOiB0aGlzLFxuICAgICAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgIHNvdXJjZTogc2V0dXAuc291cmNlTWFwLmZpbGUgfHwgc2V0dXAuc291cmNlTWFwLl9maWxlLFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdyaXRlKGNvZGUpIHtcbiAgICB0aGlzLm91dHB1dCArPSBjb2RlXG4gIH1cblxuICB3cml0ZVRvU3RyZWFtKGNvZGUpIHtcbiAgICB0aGlzLm91dHB1dC53cml0ZShjb2RlKVxuICB9XG5cbiAgd3JpdGVBbmRNYXAoY29kZSwgbm9kZSkge1xuICAgIHRoaXMub3V0cHV0ICs9IGNvZGVcbiAgICB0aGlzLm1hcChjb2RlLCBub2RlKVxuICB9XG5cbiAgd3JpdGVUb1N0cmVhbUFuZE1hcChjb2RlLCBub2RlKSB7XG4gICAgdGhpcy5vdXRwdXQud3JpdGUoY29kZSlcbiAgICB0aGlzLm1hcChjb2RlLCBub2RlKVxuICB9XG5cbiAgbWFwKGNvZGUsIG5vZGUpIHtcbiAgICBpZiAobm9kZSAhPSBudWxsKSB7XG4gICAgICBjb25zdCB7IHR5cGUgfSA9IG5vZGVcbiAgICAgIGlmICh0eXBlWzBdID09PSAnTCcgJiYgdHlwZVsyXSA9PT0gJ24nKSB7XG4gICAgICAgIC8vIExpbmVDb21tZW50XG4gICAgICAgIHRoaXMuY29sdW1uID0gMFxuICAgICAgICB0aGlzLmxpbmUrK1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmxvYyAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHsgbWFwcGluZyB9ID0gdGhpc1xuICAgICAgICBtYXBwaW5nLm9yaWdpbmFsID0gbm9kZS5sb2Muc3RhcnRcbiAgICAgICAgbWFwcGluZy5uYW1lID0gbm9kZS5uYW1lXG4gICAgICAgIHRoaXMuc291cmNlTWFwLmFkZE1hcHBpbmcobWFwcGluZylcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgKHR5cGVbMF0gPT09ICdUJyAmJiB0eXBlWzhdID09PSAnRScpIHx8XG4gICAgICAgICh0eXBlWzBdID09PSAnTCcgJiYgdHlwZVsxXSA9PT0gJ2knICYmIHR5cGVvZiBub2RlLnZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICkge1xuICAgICAgICAvLyBUZW1wbGF0ZUVsZW1lbnQgb3IgTGl0ZXJhbCBzdHJpbmcgbm9kZVxuICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0gY29kZVxuICAgICAgICBsZXQgeyBjb2x1bW4sIGxpbmUgfSA9IHRoaXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChjb2RlW2ldID09PSAnXFxuJykge1xuICAgICAgICAgICAgY29sdW1uID0gMFxuICAgICAgICAgICAgbGluZSsrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbHVtbisrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uXG4gICAgICAgIHRoaXMubGluZSA9IGxpbmVcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBjb2RlXG4gICAgY29uc3QgeyBsaW5lRW5kIH0gPSB0aGlzXG4gICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5saW5lRW5kU2l6ZSA+IDAgJiZcbiAgICAgICAgKGxpbmVFbmQubGVuZ3RoID09PSAxXG4gICAgICAgICAgPyBjb2RlW2xlbmd0aCAtIDFdID09PSBsaW5lRW5kXG4gICAgICAgICAgOiBjb2RlLmVuZHNXaXRoKGxpbmVFbmQpKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMubGluZSArPSB0aGlzLmxpbmVFbmRTaXplXG4gICAgICAgIHRoaXMuY29sdW1uID0gMFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb2x1bW4gKz0gbGVuZ3RoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlKG5vZGUsIG9wdGlvbnMpIHtcbiAgLypcbiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHJlbmRlcmVkIGNvZGUgb2YgdGhlIHByb3ZpZGVkIEFTVCBgbm9kZWAuXG4gIFRoZSBgb3B0aW9uc2AgYXJlOlxuXG4gIC0gYGluZGVudGA6IHN0cmluZyB0byB1c2UgZm9yIGluZGVudGF0aW9uIChkZWZhdWx0cyB0byBg4pCj4pCjYClcbiAgLSBgbGluZUVuZGA6IHN0cmluZyB0byB1c2UgZm9yIGxpbmUgZW5kaW5ncyAoZGVmYXVsdHMgdG8gYFxcbmApXG4gIC0gYHN0YXJ0aW5nSW5kZW50TGV2ZWxgOiBpbmRlbnQgbGV2ZWwgdG8gc3RhcnQgZnJvbSAoZGVmYXVsdHMgdG8gYDBgKVxuICAtIGBjb21tZW50c2A6IGdlbmVyYXRlIGNvbW1lbnRzIGlmIGB0cnVlYCAoZGVmYXVsdHMgdG8gYGZhbHNlYClcbiAgLSBgb3V0cHV0YDogb3V0cHV0IHN0cmVhbSB0byB3cml0ZSB0aGUgcmVuZGVyZWQgY29kZSB0byAoZGVmYXVsdHMgdG8gYG51bGxgKVxuICAtIGBnZW5lcmF0b3JgOiBjdXN0b20gY29kZSBnZW5lcmF0b3IgKGRlZmF1bHRzIHRvIGBHRU5FUkFUT1JgKVxuICAtIGBleHByZXNzaW9uc1ByZWNlZGVuY2VgOiBjdXN0b20gbWFwIG9mIG5vZGUgdHlwZXMgYW5kIHRoZWlyIHByZWNlZGVuY2UgbGV2ZWwgKGRlZmF1bHRzIHRvIGBFWFBSRVNTSU9OU19QUkVDRURFTkNFYClcbiAgKi9cbiAgY29uc3Qgc3RhdGUgPSBuZXcgU3RhdGUob3B0aW9ucylcbiAgLy8gVHJhdmVsIHRocm91Z2ggdGhlIEFTVCBub2RlIGFuZCBnZW5lcmF0ZSB0aGUgY29kZVxuICBzdGF0ZS5nZW5lcmF0b3Jbbm9kZS50eXBlXShub2RlLCBzdGF0ZSlcbiAgcmV0dXJuIHN0YXRlLm91dHB1dFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/astring@1.9.0/node_modules/astring/dist/astring.mjs\n");

/***/ })

};
;