---
sidebar_position: 3
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Interceptor Middlewares

## How To Intercept Requests In Arkos

Although Arkos handles the API endpoints generation automatically with basically all you will need for a well structured RESTful API, there are cases where you need to do some specific things related to your own application `business logic` and if we were working with plain Express we would use the middlewares.

Hence Arkos allows you to even intercept those requests that are automatically handled and let you write middlewares to do whatever you want as if you were `writing plain express app`.

## Writing Express Middlewares To Handle Custom Business Logic Before And After Requests

On a conventional Express app you intercept requests with middlewares by adding them directly in the router, for example:

```ts
// src/routers/post.router.ts
import { Router } from "express";
import * as postController from "./post.controller.ts";
import {
    someProcessingBefore,
    someProcessingAfter,
} from "./post.middlewares.ts";

const router = Router();

router.post(
    "/api/posts",
    someProcessingBefore,
    postController.createPost,
    someProcessingAfter
);
```

This way **Arkos** allows you to define middlewares for developers to intercept the auto generated endpoints to handle app custom `business logic`, so that you don't lose the power of customization and not being able to do things of your own app domain.

## Intercepting Requests Before And After Processing

### 1. Interceptor Middlewares Folder Structure

To add custom middleware, create a folder structure that follows Arkos conventions:

```
my-arkos-project/
└── src/
    └── modules/
        └── [model-name]/
            └── [model-name].middlewares.ts
```

Create interceptors in your module's middleware file for the post model:

```typescript
// src/modules/post/post.middlewares.ts
import { ArkosRequest, ArkosResponse, ArkosNextFunction } from "arkos";

export const beforeCreateOne = async (
    req: ArkosRequest,
    res: ArkosResponse,
    next: ArkosNextFunction
) => {
    // Your logic here
    next();
};

export const afterCreateOne = async (
    req: ArkosRequest,
    res: ArkosResponse,
    next: ArkosNextFunction
) => {
    // Your logic here
    next();
};
```

:::info
On previous versions before v1.2-beta it was a good practice to wrap your interceptor middlewares inside the `catchAsync` function so that you could harness the power of the built-in error handler Arkos.js provides. After v1.2-beta it is no longer needed because behind the scenes wraps it for you so that you can avoid this little boilerplate.
:::

See that in **Arkos** we've 2 groups of interceptor middlewares `Before` and `After`, which are used to intercept the auto generated request flow before and after as their names state.

### 2. Understanding `Before` Interceptor Middlewares

This kind of middlewares are used to intercept any requests before the final main handler generated by Arkos internally. Arkos allows you to intercept all the requests from endpoints generated for the models.

For each model endpoints you can intercept the request before the final operation by using the following middlewares:

```ts
// src/modules/post/post.middlewares.ts

// Before operations for models
export const beforeCreateOne = async (req, res, next) => {};
export const beforeUpdateOne = async (req, res, next) => {};
export const beforeDeleteOne = async (req, res, next) => {};
export const beforeFindOne = async (req, res, next) => {};
export const beforeFindMany = async (req, res, next) => {};
```

:::info
For the middlewares to work you must define them under `src/modules/model-name/model-name.middlewares.ts` and then export the middlewares as above. You understand more about the folder structure [clicking here](/docs/project-structure)
:::

:::danger
You must pay attention to the model names so that you don't end up writing something that doesn't work. The model names on the files' name and folders' name must be in kebab-case and must be in singular. Read more about kebab-case [clicking here](https://developer.mozilla.org/en-US/docs/Glossary/Kebab_case).
:::

If you wish to pass some data from `before` to `after` while handling the request you can attach it on `req` object.

#### Example

```ts
// src/modules/author/author.middlewares.ts
import { ArkosRequest, ArkosResponse, ArkosNextFunction } from "arkos";

export const beforeCreateOne = async (
    req: ArkosRequest,
    res: ArkosResponse,
    next: ArkosNextFunction
) => {
    // some code
    (req as any).someFieldToPassToAfter = someData;
    // some code
    next();
};

export const afterFindMany = async (
    req: ArkosRequest,
    res: ArkosResponse,
    next: ArkosNextFunction
) => {
    // some code
    console.log((req as any).someFieldToPassToAfter); // will log the data
    // some code
    next();
};
```

### 3. Understanding `After` Interceptor Middlewares

This kind of middlewares are used to intercept any requests after the final main handler generated by Arkos internally. Arkos allows you to intercept all the requests from endpoints generated for the model.

**1. Differences with `Before` interceptor middlewares:** As these are middlewares that run after the request, here Arkos provides ways to access the data that would be sent normally by the final operation that ran before it or will be sent if you call next() on an `After` interceptor middleware.

- **`req.responseData`** - Allows you to access the response data that was created/modified on the final handler that ran before it and would be sent if there was no `After` interceptor middleware or if you call next() on the `After` interceptor middleware.
- **`req.responseStatus`** - Allows you to access the response http status code that would be sent if there was no `After` interceptor middleware or if you call next() on the `After` interceptor middleware.
- **`req.additionalData`** - Here Arkos provides you a way to access some additional data that was generated on the final operation and would not go anywhere in the response, for example when using authentication and there is a `signup` Arkos may generate an email verification otp which you will be able to access through this.

:::tip
You don't need to worry too much about `req.additionalData` because most of the time and in most of the `After` Interceptor Middlewares it will just be null.
:::

For each model endpoints you can intercept the request after the final operation by using the following middlewares:

```ts
// src/modules/post/post.middlewares.ts

// Before operations for models
export const beforeCreateOne = (req, res, next) => {};
export const beforeUpdateOne = (req, res, next) => {};
export const beforeDeleteOne = (req, res, next) => {};
export const beforeFindOne = (req, res, next) => {};
export const beforeFindMany = (req, res, next) => {};

// After operations for models
export const afterCreateOne = (req, res, next) => {};
export const afterUpdateOne = (req, res, next) => {};
export const afterDeleteOne = (req, res, next) => {};
export const afterFindOne = (req, res, next) => {};
export const afterFindMany = (req, res, next) => {};
```

:::info
Notice that all kinds of middlewares stay at the same file as shown above, whether it is a `Before` or `After` Interceptor Middleware.
:::

### 4. Creating Interceptor/Custom Middleware

Example middleware implementation with author model:

```ts
// src/modules/author/author.middlewares.ts
import { ArkosRequest, ArkosResponse, ArkosNextFunction } from "arkos";

export const beforeCreateOne = async (
    req: ArkosRequest,
    res: ArkosResponse,
    next: ArkosNextFunction
) => {
    // Add custom logic before creating an author
    console.log("Creating author:", req.body);
    // You can modify req.body here
    next();
};

export const afterFindMany = async (
    req: ArkosRequest,
    res: ArkosResponse,
    next: ArkosNextFunction
) => {
    // Modify response data after fetching authors
    const data = req.responseData.data.map((author) => {
        // Remove sensitive data or transform response
        delete author.country; // Just an example
        return author;
    });
    req.responseData.data = data;
    next();
};
```

Example middleware implementation with post model:

```typescript
// src/modules/post/post.middlewares.ts
import { ArkosRequest, ArkosResponse, ArkosNextFunction } from "arkos";
import { AppError } from "arkos/error-handler";

export const beforeUpdateOne = async (
    req: ArkosRequest,
    res: ArkosResponse,
    next: ArkosNextFunction
) => {
    // Custom logic to prevent an author from changing other authors' posts
    if (req.user.roles.some((role) => role.name === "Author")) {
        const postToUpdate = await prisma.post.findUnique({
            where: {
                id: req.query.id,
                author: {
                    id: req.user.id,
                },
            },
        });

        // If the post does not belong to the author trying to update throw an error
        if (!postToUpdate)
            throw new AppError("You can only update your own posts", 403);
    }

    next();
};
```

:::tip
**AppError**: when you want to throw an error you can use the AppError class, which is highly recommended, that allows you to easily setup an error with http code and other things, [see more about AppError](/docs/api-reference/the-app-error-class).
:::

### 5. Automatically Generating Interceptor Middlewares

Is worth mentioning that you can quickly generate interceptor middlewares by using Arkos built-in cli commands:

```bash
npx arkos generate middlwares --model user
```

**Shorthand**

```bash
npx arkos g m -m user
```

> You can if you wish read more about the built-in Arkos.js cli that was introduced at v1.2-beta at [Built-in Arkos Cli](/docs/cli/built-in-cli).

### 6. Customizing Base Query Options

Most of the time when designing your applications, you will want to customize your models base query options so that you have control over what is exposed, what must not and so on, for example, hiding sensitive data like password field in all user requests or including some fields like profile as it is not included by default, by doing something like this in normal Express app:

> You can [read more](/docs/advanced-guide/custom-prisma-query-options) advanced guide about customizing prisma query options.

```ts
import { prisma } from "../../utils/prisma";

export const findOneUser = async (req, res, next) => {
    const user = await prisma.user.findUnique({
        where: {
            id: req.params.id,
        },
        include: {
            password: false,
            profile: true,
        },
    });

    res.status(200).json({ data: user });
};
```

In **Arkos** yes you can do this just if you want, because **Arkos** was designed to make your development easy and fast mainly to avoid unnecessary tasks like these ones. You can have an overview on how **Arkos** allows you to customize your base query options without the need to write any single controller or service.

**Arkos** uses what is called the `prismaQueryOptions` configuration, that allows you to customize how Prisma queries are executed by default in all your requests for a given model, you can even customize by methods like findOne, findMany, etc:

In order to do this you must export a `modelNamePrismaQueryOptions` under `src/modules/model-name/model-name.query.ts`.

#### Example Customizing Prisma Query Options

```ts
// src/modules/user/user.query.ts
import { Prisma } from "@prisma/client";
import { PrismaQueryOptions } from "arkos/prisma";
import { prisma } from "../../utils/prisma";

const userPrismaQueryOptions: PrismaQueryOptions<typeof prisma.user> = {
    global: {
        // Used to manage custom prisma query options across all operations
        include: {
            password: false,
            passwordChangedAt: false,
            isActive: false,
        } as any,
    },
    findMany: {
        // Only applies for findMany operations, it will be merged with the queryOptions above
        select: {
            id: true,
            name: true,
            email: true,
            password: false,
            // Excluded sensitive data, etc.
        },
    },
    createOne: {
        // Only on createOne operations
        include: {
            postsLiked: true,
        },
    },
};

export default userPrismaQueryOptions;
```

:::tip
Bear in mind that the model name on the file and folder names must be singular and in kebab-case, e.g: UserProfile to user-profile.
:::

This way Arkos reinforces one of its biggest strengths which is abstraction but still allowing the developer to customize basically everything he wants. For more you can [see about](/docs/advanced-guide/custom-prisma-query-options) advanced usage.

### 7. More Variations Of Interceptor Middlewares

On this guide we've covered all about interceptor middlewares as core concept inside Arkos.js, but there are two more variations of interceptor middlewares specific for Authentication and File Upload modules, as the endpoints and actions that they provide are slightly different for the ones that areavailable and auto generated for your prisma models.

- Find out more about [Authentication Interceptor Middlewares](/docs/guide/authentication-system/authentication-interceptor-middlewares).
- Find out more about [File Upload Interceptor Middlewares](/docs/core-concepts/file-uploads#file-upload-interceptor-middlewares).
