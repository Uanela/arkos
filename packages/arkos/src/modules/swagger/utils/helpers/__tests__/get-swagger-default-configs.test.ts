// tests/unit/swagger/get-swagger-default-config.test.ts

import portAndHostAllocator from "../../../../../utils/features/port-and-host-allocator";
import { capitalize } from "../../../../../utils/helpers/text.helpers";
import getSwaggerDefaultConfig from "../get-swagger-default-configs";

// Mock dependencies
jest.mock("../../../../../utils/features/port-and-host-allocator");
jest.mock("../../../../../utils/helpers/text.helpers");

describe("getSwaggerDefaultConfig", () => {
  const mockDefaultModelsPaths: any = {
    "/users": {
      get: {
        description: "Get all users",
      },
    },
  };

  const mockDefaultJsonSchemas: any = {
    User: {
      type: "object",
      properties: {
        id: { type: "string" },
      },
    },
  };

  beforeEach(() => {
    jest.clearAllMocks();
    (
      portAndHostAllocator.getHostAndAvailablePort as jest.Mock
    ).mockResolvedValue({
      host: "localhost",
      port: 3000,
    });
    (capitalize as jest.Mock).mockImplementation(
      (str) => str.charAt(0).toUpperCase() + str.slice(1)
    );
  });

  it("should return default swagger config with correct structure", async () => {
    const result = (await getSwaggerDefaultConfig(
      mockDefaultModelsPaths,
      mockDefaultJsonSchemas
    )) as any;

    expect(result).toHaveProperty("endpoint", "/docs");
    expect(result).toHaveProperty("mode", "prisma");
    expect(result).toHaveProperty("strict", false);
    expect(result.options.definition.info.title).toBe("Powered By Arkos.js");
    expect(result.options.definition.servers[0].url).toBe(
      "http://localhost:3000"
    );
  });

  it("should use provided models and schemas", async () => {
    const result = (await getSwaggerDefaultConfig(
      mockDefaultModelsPaths,
      mockDefaultJsonSchemas
    )) as any;

    expect(result.options.definition.paths).toEqual(mockDefaultModelsPaths);
    expect(result.options.definition.components.schemas).toEqual(
      mockDefaultJsonSchemas
    );
  });

  it("should include BearerAuth security scheme", async () => {
    const result = (await getSwaggerDefaultConfig(
      mockDefaultModelsPaths,
      mockDefaultJsonSchemas
    )) as any;

    expect(
      result.options.definition.components.securitySchemes.BearerAuth
    ).toEqual({
      type: "http",
      scheme: "bearer",
      bearerFormat: "JWT",
    });
  });

  it("should use capitalized NODE_ENV in server description", async () => {
    process.env.NODE_ENV = "production";
    const result = (await getSwaggerDefaultConfig(
      mockDefaultModelsPaths,
      mockDefaultJsonSchemas
    )) as any;

    expect(result.options.definition.servers[0].description).toBe(
      "Local Production Server"
    );
    expect(capitalize).toHaveBeenCalledWith("production");
  });

  it("should use capitalized NODE_ENV fallback (development) in server description", async () => {
    process.env.NODE_ENV = "";
    const result = (await getSwaggerDefaultConfig(
      mockDefaultModelsPaths,
      mockDefaultJsonSchemas
    )) as any;

    expect(result.options.definition.servers[0].description).toBe(
      "Local Development Server"
    );
    expect(capitalize).toHaveBeenCalledWith("development");
  });

  it("should handle empty paths and schemas", async () => {
    const result = (await (getSwaggerDefaultConfig as any)(
      {},
      undefined
    )) as any;

    expect(result.options.definition.paths).toEqual({});
    expect(result.options.definition.components.schemas).toEqual({});
  });

  it("should include scalar API reference configuration", async () => {
    const result = (await getSwaggerDefaultConfig(
      mockDefaultModelsPaths,
      mockDefaultJsonSchemas
    )) as any;

    expect(result.scalarApiReferenceConfiguration).toEqual({
      theme: "deepSpace",
      darkMode: true,
      layout: "modern",
      showSidebar: true,
      hideDownloadButton: false,
      metaData: {
        title: "Arkos.js API Documentation",
        description: "API documentation generated by Arkos.js",
      },
      pageTitle: "Arkos.js API Documentation",
    });
  });

  it("should handle port allocation errors gracefully", async () => {
    (
      portAndHostAllocator.getHostAndAvailablePort as jest.Mock
    ).mockRejectedValue(new Error("Port error"));

    await expect(
      getSwaggerDefaultConfig(mockDefaultModelsPaths, mockDefaultJsonSchemas)
    ).rejects.toThrow("Port error");
  });
});
