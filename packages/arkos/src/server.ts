import { IncomingMessage, Server, ServerResponse } from "http";
import AppError from "./modules/error-handler/utils/app-error";
import { Express } from "express";
import { bootstrap } from "./app";
import { ArkosConfig } from "./types/arkos-config";
import deepmerge from "./utils/helpers/deepmerge.helper";
import http from "http";
import sheu from "./utils/sheu";
import { capitalize } from "./utils/helpers/text.helpers";
import portAndHostAllocator from "./utils/features/port-and-host-allocator";

process.on("uncaughtException", (err) => {
  if (err.message.includes("EPIPE")) return;

  sheu.error("\nUNCAUGHT EXCEPTION! SHUTTING DOWN...\n", {
    timestamp: true,
    bold: true,
  });

  console.log(err.message, sheu.error("some thign again"));
  console.error(err.name, err.message);
  console.error(err);
  process.exit(1);
});

let server: Server<typeof IncomingMessage, typeof ServerResponse>;
let _app: Express;

export let _arkosConfig: ArkosConfig & { available?: boolean } = {
  welcomeMessage:
    "Welcome to our RESTful API generated by Arkos, find out more about Arkos at www.arkosjs.com",
  port: Number(process.env.CLI_PORT) || Number(process.env.PORT) || 8000,
  host: process.env.CLI_HOST || process.env.HOST || "localhost",
  fileUpload: {
    baseUploadDir: "uploads",
    baseRoute: "/api/uploads",
  },
  routers: {
    strict: false,
  },
  available: false,
};

/**
 * Initializes the application server.
 *
 * This function starts the server by listening on a specified port.
 * The port is determined by the following order of precedence:
 * 1. The `port` argument passed to the function.
 * 2. Defaults to `8000` if neither is provided.
 *
 * @param {ArkosConfig} arkosConfig - initial configs for the api ( authentication, port).
 * @returns {Promise<Express>} This function returns the Express App after all middlewares configurations.
 * You can prevent it from listen py passing port as undefined
 *
 */
async function initApp(
  arkosConfig: ArkosConfig = {}
): Promise<Express | undefined> {
  try {
    _arkosConfig.available = true;

    const portAndHost = await portAndHostAllocator.getHostAndAvailablePort(
      process.env,
      arkosConfig
    );

    _arkosConfig = deepmerge(_arkosConfig, arkosConfig);

    _app = await bootstrap(_arkosConfig);
    const time = new Date().toTimeString().split(" ")[0];

    if (
      ("port" in arkosConfig && arkosConfig?.port !== undefined) ||
      !("port" in arkosConfig)
    ) {
      server = http.createServer(_app);

      if (_arkosConfig?.configureServer)
        await _arkosConfig.configureServer(server);

      server.listen(
        Number(portAndHost?.port),
        portAndHost.host! === "localhost" ? "127.0.0.1" : portAndHost.host!,
        () => {
          const message = `${sheu.gray(time)} {{server}} waiting on http://${portAndHost?.host}:${portAndHost?.port}`;

          sheu.ready(
            message.replace(
              "{{server}}",
              `${capitalize(process.env.NODE_ENV || "development")} server`
            )
          );
          if (_arkosConfig?.swagger?.mode)
            sheu.ready(
              `${message.replace("{{server}}", "Documentation")}${_arkosConfig?.swagger?.endpoint || "/api/docs"}`
            );
        }
      );
    } else {
      sheu.warn(
        `${sheu.gray(time)} Port set to undefined, hence no internal http server was setup.`
      );
    }

    return _app;
  } catch (err: any) {
    sheu.error(
      err?.message || "Something went wrong while starting your application!"
    );
    console.error(err);
  }
}

process.on("unhandledRejection", (err: AppError) => {
  sheu.error("\nUNHANDLED REJECTION! SHUTTING DOWN...\n", {
    timestamp: true,
    bold: true,
  });
  console.error(err.name, err.message);
  console.error(err);
  server?.close(() => {
    process.exit(1);
  });
});

/**
 * Terminates the current running express application, server and process.
 *
 * @returns {void}
 */
export function terminateApplicationRunningProcessAndServer(): void {
  server?.close(() => {
    process.exit(1);
  });
}

/**
 * Gives access to the underlying current configurations being used by **Arkos** by default and also passed through `arkos.init()`
 *
 * @returns {ArkosConfig}
 */
export function getArkosConfig(): ArkosConfig {
  return _arkosConfig;
}

export function getExpressApp() {
  return _app;
}

export { server, initApp };
